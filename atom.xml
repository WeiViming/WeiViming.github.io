<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[云中雨雾]]></title>
  <link href="https://weiviming.github.io/atom.xml" rel="self"/>
  <link href="https://weiviming.github.io/"/>
  <updated>2022-06-20T10:18:01+08:00</updated>
  <id>https://weiviming.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Tetrad: Actively Secure 4PC for Secure Training and Inference]]></title>
    <link href="https://weiviming.github.io/16553844634309.html"/>
    <updated>2022-06-16T21:01:03+08:00</updated>
    <id>https://weiviming.github.io/16553844634309.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>今天给大家带来的是发表于NDSS'22上的一篇文章 Tetrad: Actively Secure 4PC for Secure Training and Inference, 原文链接: <a href="https://arxiv.org/pdf/2106.02850.pdf">https://arxiv.org/pdf/2106.02850.pdf</a></p>
</blockquote>
<h2><a id="abstract" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Abstract</h2>
<p>本文在诚实大多数假设下提出了一个环上抵抗1个恶意敌手的四方计算框架Tetrad, 所提出的两种变体Tetrad, Tetrad-R可以分别达到公平性(Fairness)和输出可达性(Guaranteed output delivery, GOD)/鲁棒性(Robustness). Tetard通过改进Trident的方案实现Fairness, 实现Fairness的乘法协议只需通信5个环元素. 而Tetrad-R实现GOD几乎是免费的, 通过改进SWIFT和Fantastic Four的方案实现GOD. 这两种变体的其他亮点有: (a)无开销的概率截断; (b)多输入乘法协议; (c)通过专用的混淆电路, 支持算术/布尔计算域之间的相互转换, 可同时用于安全训练和安全推理. 实验部分, 在LeNet, VGG16等DNN中进行了性能测试, 发现Tetrad在ML训练速度提高了6倍, 在ML推理中速度提高了5倍. Tetrad在实际部署中所需的货币成本也比Trident低6倍.</p>
<h3><a id="main-contributions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Main Contributions</h3>
<p>与Trident相比, Tetrad的公平乘法协议只需通信5个环元素(Trident需要6个), 而鲁棒乘法协议的实现在均摊意义下几乎是免费的(在二次幂环\(\mathbb Z_{2^{64}}\), 统计安全参数为\(40\)的情况下, 计算一个包含\(2^{20}\)个乘法的电路, 平均每个乘法仅需通信0.027bits). Tetrad的其他亮点包括:</p>
<ol>
<li>通过并行化来支持按需计算, 这在依赖于函数的预处理模型中通常是不可能的;</li>
<li>首次在公平性和输出可达性的前提下实现无开销的概率截断;</li>
<li>可以一个在线通信轮次内计算3输入和4输入的乘法, 与2输入乘法相同, 而以往的方案需要两个轮次;</li>
<li>大多数基于MPC的PPML框架中的大部分计算都在算术世界和布尔世界中完成的, 而混淆世界仅用于在算术/布尔世界中代价高昂的非线性算子的计算(如SoftMax), 然后需要将混淆输出再转换回其他两个世界, 为了进一步优化这个过程, 本文提出了4PC混合协议框架, 可在计算域与专用的基于混淆电路的端到端转换协议, 使混淆世界的输出直接变为其他世界的输出, 从而减少所需的通信量和轮数.</li>
</ol>
<p>本文与其他现有的3PC, 4PC主动安全的框架对比如下:</p>
<img src="media/16553844634309/16553848135376.png" alt="image-20220406200000091" style="zoom:50%;" />
<h2><a id="preliminaries-and-definitions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Preliminaries and Definitions</h2>
<p>服务器代理模式, 四方诚实大多数假设下的安全外包计算, 静态主动敌手至多腐化1个服务器(服务器即为MPC协议的参与方). 参与方之间共享一次分享密钥用于非交互地生成相关随机性.</p>
<ol>
<li>
<p>安全训练: 数据所有者将数据通过秘密共享外包给服务器, 由服务器进行MPC训练模型, 最后向数据所有者重构经过训练的模型.</p>
</li>
<li>
<p>安全推理: 模型所有者在服务器之间秘密共享一个预先训练的模型, 客户端在服务器之间秘密共享其查询, 服务器通过MPC进行安全推理, 并将输出重构给客户端.</p>
</li>
</ol>
<p>所涉及的计算域为算术环和布尔环\(\mathbb Z_{2^{\ell}}=\mathbb Z_{2^{64}}\), \(\mathbb Z_2\). 所有浮点数都表示为\(\ell=64\)比特定点数, 精度\(x=13\)比特, 整数部分为\(\ell-x-1=40\)比特.</p>
<h3><a id="sharing-semantics" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sharing Semantics</h3>
<p>本文中根据实际参与方的不同, 使用了四种分享语义: 两方下的ASS\([\cdot]\), 三方下的ASS\((\cdot)\), 三方下的RSS\(\langle \cdot\rangle\)和四方下的RSS+mask\([[\cdot]]\). 秘密\(v\in\mathbb Z_{2^\ell}\)在\((4,1)\)RSS下的其中三个份额\(\lambda_v^1,\lambda_v^2,\lambda_v^3\)可以在预处理阶段生成, 而第四个份额取决于\(v\)的值, 因此由在线阶段生成. \(\lambda_v=\lambda_v^1+\lambda_v^2+\lambda_v^3\)作为掩码, 掩盖值为\(m_v=v+\lambda_v\). Tetrad中的\(v\)的不同秘密共享语义下参与方拥有的份额可表示为下表, 其中\(v=v_1+v_2(+v_3)\), \(v=m_v+\lambda_v\). 使用的三种中间分享语义\([\cdot],(\cdot),\langle\cdot\rangle\)都是线性的, 因此线性算子的安全计算是不需要交互的. 将四方分成两个集合: 计算集合\(\mathcal E=\{P_1,P_2\}\), 这里的参与方被分配了计算任务, 在整个在线阶段中都是活动的; 帮助集合\(\mathcal D=\{P_0,P_3\}\)用于辅助\(\mathcal E\)进行验证, 只在计算接近尾声的阶段才活动.</p>
<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center">\(P_0\)</th>
<th style="text-align: center">\(P_1\)</th>
<th style="text-align: center">\(P_2\)</th>
<th style="text-align: center">\(P_3\)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">\([\cdot]\)-sharing</td>
<td style="text-align: center">—</td>
<td style="text-align: center">\(v^1\)</td>
<td style="text-align: center">\(v^2\)</td>
<td style="text-align: center">—</td>
</tr>
<tr>
<td style="text-align: center">\((\cdot)\)-sharing</td>
<td style="text-align: center">—</td>
<td style="text-align: center">\(v^1\)</td>
<td style="text-align: center">\(v^2\)</td>
<td style="text-align: center">\(v^3\)</td>
</tr>
<tr>
<td style="text-align: center">\(\langle\cdot\rangle\)-sharing</td>
<td style="text-align: center">—</td>
<td style="text-align: center">\((v^1,v^3)\)</td>
<td style="text-align: center">\((v^2,v^3)\)</td>
<td style="text-align: center">\((v^1,v^2)\)</td>
</tr>
<tr>
<td style="text-align: center">\([[\cdot]]\)-sharing</td>
<td style="text-align: center">\((\lambda_v^1,\lambda_v^2,\lambda_v^3)\)</td>
<td style="text-align: center">\((m_v,\lambda_v^1,\lambda_v^3)\)</td>
<td style="text-align: center">\((m_v,\lambda_v^2,\lambda_v^3)\)</td>
<td style="text-align: center">\((m_v,\lambda_v^2,\lambda_v^3)\)</td>
</tr>
</tbody>
</table>
<p>一些符号: \(\gamma_{a_1\cdots a_n}=\prod_{i=1}^n\lambda_{a_i}, m_{a_1\cdots a_n}=\prod_{i=1}^nm_{a_i}\). \([[\cdot]]^\mathbf B\)表示布尔份额, \([[\cdot]]^\mathbf G\)表示混淆份额, 没有上标表示算术份额.</p>
<h2><a id="4pc-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4PC Protocol</h2>
<h3><a id="primitives" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Primitives</h3>
<ul>
<li>
<p>Joint-Send/jsnd: 允许\(P_i,P_j\)将信息转发给\(P_k\)进行验证, 当传递的信息不一致时输出\(\mathtt{abort}\). 具体做法是, \(P_i\)发送\(v\), \(P_j\)发送\(\mathsf H(v)\), \(P_k\)使用Hash验证\(v\)的结果是否为\(P_j\)发送的信息\(\mathsf H(v)\), 若一致则接受, 否则发出中止信号\(\mathtt{abort}\). 为均摊开销, Hash的结果可以在协议结束后将信息组合在一起发送一次来均摊通信开销.</p>
</li>
<li>
<p>Joint-Send for robust protocols: 为实现鲁棒性, Tetrad同时借鉴了Fantastic Four和SWIFT的做法: 当\(P_k\)发现信息不一致时, 会建立一个至多有两方的参与方集合, 其中必有一个参与方是被敌手腐化的, 这意味着剩下的两方都是诚实的, 因此让其中一方作为TTP(\(\mathsf P_\mathsf{TP}\)​)进行相关明文计算.  jsnd包含两个阶段: 发送阶段(send)和验证阶段(verify). 验证阶段只在协议结束后执行一次以均摊通信开销. 具体协议过程如下, 均摊的通信开销为\(\ell\)比特, 2轮.</p>
</li>
</ul>
<img src="media/16553844634309/16553848135395.png" alt="image-20220407110842191" style="zoom:50%;" />
<ul>
<li>Sharing: \(\Pi_\mathsf{Sh}\)协议允许\(P_i\)生成\(v\)的\([[\cdot]]\)份额. 具体协议见图1, 当参与方发现接收到的信息不一致时, 根据公平性和鲁棒性的要求, 具体处理方式略有不同, 参与方输出\(\mathtt{abort}\)以实现公平性, 参与方使用一个默认值以实现鲁棒性. 在线阶段均摊通信开销: 至多\(3\ell\)比特, 1轮.</li>
</ul>
<img src="media/16553844634309/16553848135426.png" alt="image-20220126210603681" style="zoom: 50%;" />
<ul>
<li>
<p>Joint Sharing: \(\Pi_\mathsf{JSh}\)协议允许\(P_i,P_j\)联合生成\(v\)的\([[\cdot]]\)份额, 与\(\Pi_\mathsf{Sh}\)不同的是, 在线阶段的最后部分需要调用jsnd发送\(m_v\)给\(P_1,P_2,P_3\). 特别地, 若\(P_0\)与另一方联合生成\(v\)的\([[\cdot]]\)份额, 则可以进一步优化通信, 具体来说,</p>
<ul>
<li>\((P_0,P_1)\):  \(\mathcal P\backslash\{P_2\}\)选取\(\lambda_v^1\in_R\mathbb Z_{2^\ell}\); 令\(\lambda_v^2=m_v=0\); \(P_0,P_1\)调用jsnd发送\(\lambda_v^3=-v-\lambda_v^1\)给\(P_2\).</li>
<li>\((P_0,P_2)\):  \(\mathcal P\backslash\{P_3\}\)选取\(\lambda_v^3\in_R\mathbb Z_{2^\ell}\); 令\(\lambda_v^1=m_v=0\); \(P_0,P_2\)调用jsnd发送\(\lambda_v^2=-v-\lambda_v^3\)给\(P_3\).</li>
<li>\((P_0,P_3)\):  \(\mathcal P\backslash\{P_1\}\)选取\(\lambda_v^2\in_R\mathbb Z_{2^\ell}\); 令\(\lambda_v^3=m_v=0\); \(P_0,P_3\)调用jsnd发送\(\lambda_v^1=-v-\lambda_v^2\)给\(P_1\).</li>
</ul>
</li>
<li>
<p>Reconstruction: \(\Pi_\mathsf{Rec}\)协议输入\([[v]]\), 参与方得到\(v\). 因为一个参与方缺失的份额都由其余三方持有, 三方中任意两方通过jsnd发送所需份额即可重构秘密\(v\). 具体协议过程如下, 在线阶段均摊通信开销为\(4\ell\)比特, 1轮.</p>
</li>
</ul>
<img src="media/16553844634309/16553848135456.png" alt="image-20220407111530823" style="zoom:50%;" />
<ul>
<li>
<p>\(\mathcal{F}_\mathsf{zero}\) - 生成0的ASS份额(Zero sharing): 对于\(i\in\{1,2,3\}\), 使\(P_0,P_i\)得到\(Z_i\), 满足\(Z_1+Z_2+Z_3=0\). 与ABY3一样, 可以通过预分享密钥结合PRF来生成. 对\(j\in\{1,2,3\}\), \(\mathcal P\backslash\{P_j\}\)通过预分享密钥和PRF选取随机\(r_j\), 份额定义为\(Z_1=r_3-r_2\), \(Z_2=r_1-r_3\), \(Z_3=r_2-r_1\).</p>
</li>
<li>
<p>Multiplication \(\Pi_\mathsf{MulR}\): 给定\(\langle a\rangle,\langle b\rangle\), 生成\(\langle z\rangle\), 其中\(z=xy\), \(P_0\)有明文的\(a,b\). 原理与ABY3中的RSS乘法一致, 结合zero sharing即可计算, 而resharing则通过调用jsnd来实现. 协议过程如下:</p>
</li>
</ul>
<img src="media/16553844634309/16553848135485.png" alt="image-20220404205938015" style="zoom:50%;" />
<h3><a id="multiplication-in-tetrad" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiplication in Tetrad</h3>
<p>给定\(a,b\)的份额\([[a]],[[b]]\), 计算\(z=ab\)的份额\([[z]]\). 协议设计使得\(P_0,P_3\)在预处理阶段得到\(r\)的茫化值\(r\), \(P_1,P_2\)在在线阶段得到\(z\)的茫化值\(z-r\), 然后参与方通过执行\(\Pi_\mathsf{Jsh}\)生成这些值的\([[\cdot]]\)份额, 最后本地计算\([[z-r]]+[[r]]\)得到输出.</p>
<p>(1) 在线阶段: 因为</p>
\[\begin{aligned}
z-r&amp;=ab-r=(m_a-\lambda_a)(m_b-\lambda_b)-r\\
&amp;=m_{ab}-m_a\lambda_b-m_b\lambda_a+\gamma_{ab}-r.
\end{aligned}\tag{1}
\]
<p>在等式\((1)\)中, \(P_1,P_2\)可以本地计算\(m_{ab}\), 关键在于如何计算\(y=(z-r)-m_{ab}=-m_a\lambda_{b}-m_b\lambda_a+\gamma_{ab}-r\). 设\(y=y_1+y_2+y_3\), 其中\(y_1,y_2\)由\(P_1,P_2\)分别计算, 而\(y_3\)由\(P_1,P_2\)共同计算如下:</p>
\[\begin{aligned}
P_1&amp;:y_1=-\lambda_{a}^1m_b-\lambda_{b}^1m_a+[\gamma_{ab}-r]_1\\
P_2&amp;:y_2=-\lambda_{a}^2m_b-\lambda_{b}^2m_a+[\gamma_{ab}-r]_2\\
P_1,P_2&amp;:y_3=-\lambda_{a}^3m_b-\lambda_{b}^3m_a.
\end{aligned}\tag{2}
\]
<p>预处理阶段使得\(P_1,P_2\)收到\(\gamma_{ab}-r\)的\([\cdot]\)份额. \(P_1,P_2\)互相交换缺失的份额重构\(y\), 随后可以重构\(z-r\).</p>
<p>(2) 验证阶段: 为了确保在线阶段交换的值的正确性, 为此可以通过\(P_3\)来辅助验证. 具体而言, 让\(P_3\)得到\(y_1+y_2+s\), 其中\(s\)是\(P_0,P_1,P_2\)都已知的随机掩码. 为此, \(P_3\)需要在预处理阶段得到\(\gamma_{xy}+s\). 这里的掩码\(s\)用于茫化\(\gamma_{ab}\)防止泄漏给\(P_3\). \(P_3\)计算\(\mathcal H(y_1+y_2+s)\)并发送给\(P_1,P_2\), 若不一致则输出\(\mathtt{abort}\).</p>
<p>(3) 预处理阶段: 参与方需要在预处理阶段得到如下值: (i) \(P_1,P_2\)需得到\([\gamma_{ab}-r]\); (ii) \(P_0,P_3\)需得到\(r\); (iii) \(P_3\)需得到\(\gamma_{ab}+s\).</p>
<p>对于(i)和(ii), 令\(\gamma_{ab}=\gamma_{ab}^1+\gamma_{ab}^2+\gamma_{ab}^3\), 其中\(P_0\)和\(P_i\)可计算\(\gamma_{ab}^i\). 对\(P_1,P_2\), 为了组成\((\gamma_{ab}-r)\)的加法份额, 定义\(\gamma_{ab}-r=\gamma_{ab}^1+\gamma_{ab}^2+[\gamma_{ab}^3-r]\). 此时\(P_0,P_3\)不随机选取\(r\), 而是让\(P_0,P_3\)先连同\(P_j\)选取\(\gamma_{ab}^3-r\)的份额\(u^j\), \(j\in\{1,2\}\), 然后\(P_0,P_3\)计算\(r=\gamma_{ab}^3-u^1-u^2\). 注意到如此计算的\(r\)仍是均匀随机的, 因为\(u^1,u^2\)的选取是均匀随机的.</p>
<p>对于(iii), \(P_3\)需要得到\(w=\gamma_{ab}^1+\gamma_{ab}^2+s\). 为此, \(P_0,P_1,P_2\)选取\(s_1,s_2\), 并设\(s=s_1+s_2\). 对\(i\in\{1,2\}\), \(P_0,P_i\)调用jsnd发送\(\gamma_{ab}^i+s_i\)给\(P_3\), 这需要通信2个元素. 作为优化, 可让\(P_0\)发送\(w\)给\(P_3\). 若\(P_0\)是恶意的, 则可能发送错误的\(w\)给\(P_3\). 然而, 在这种情况下, 在线阶段\(P_1,P_2,P_3\)都将是诚实方, 因为\(P_1,P_2\)在计算中不需要\(w\), 而错误的\(w\)在验证阶段会被发现.</p>
<p>(4) 截断: 设需要截断的值为\(z\), 本文中的方法与ABY3的方法类似, 只是在本文的秘密共享语义下无需额外的通信开销. 在ABY3中, 首先预处理阶段生成截断对\((r,r^t)\), 其中\(r^t\)是随机值\(r\)截断后的结果. 然后在在线阶段重构\(z-r\), 并计算\(z^t=(z-r)^t+r^t\). 本文中的处理方式如下: \(P_1,P_2\)在在线阶段本地截断\((z-r)\), 并生成\([[(z-r)^t]]\). 类似地, \(P_0,P_3\)在预处理阶段截断\(r\)并生成\([[r^t]]\). 最后本地计算\([[z^t]]=[[(z-r)^t]]+[[r^t]]\).</p>
<p>(5) 标量积: 本地计算, 给定常数\(\alpha\)和\([[v]]\), 计算\(\alpha v=\beta^1+\beta^2\), 其中\(\beta^1=\alpha(m_v-\lambda^3_v)\), \(\beta^2=\alpha(-\lambda_v^1-\lambda^2_v)\). 然而, 在定点表示形式下, 输出需要进行截断. 为此, \(P_1,P_2\)截断\(\beta^1\)并执行\(\Pi_\mathsf{JSh}\), \(P_0,P_3\)截断\(\beta^2\)并执行\(\Pi_\mathsf{JSh}\)即可.</p>
<p>完整的乘法协议过程如下, 实现公平性预处理阶段需要\(2\ell\)比特通信量, 在线阶段需要\(3\ell\)比特通信量, 1轮. 实现鲁棒性预处理阶段需要\(2\ell\)比特通信量, 在线阶段需要\(3\ell\)比特通信量, 1轮.</p>
<img src="media/16553844634309/16553848135520.png" alt="image-20220405095527234" style="zoom:50%;" />
<h3><a id="achieving-fairness" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Achieving Fairness</h3>
<p>Tetrad实现公平性的思路与Trident相同. 输出重构之前, 需要确保在验证阶段过后所有诚实方都没有中止协议(alive). 为此, 所有参与方维护一个比特(aliveness bit)\(b\), 初始化为\(b=\mathtt{continue}\). 若验证阶段某个参与方验证失败, 则设定\(b=\mathtt{abort}\). 重构的第一轮, 参与方互相交换他们的\(b\), 并接受其中占大多数的那个值. 因为仅有一个腐化方, 因此可以保证所有诚实方的\(b\)都一致. 若\(b=\mathtt{continue}\), 则参与方互相交换他们所缺失的份额并接受其中占大多数的那个值. 作为优化, 可让两方发送重构所需的份额, 而第三方发送该份额对应的哈希值检验一致性.</p>
<h3><a id="achieving-robustness" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Achieving Robustness</h3>
<p>为了将安全性扩展到鲁棒性的Tetrad-R, 需要额外对乘法的预处理阶段进行验证. 此外, 重构协议与实现公平性的类似, 只是不需要再进行aliveness check, 因为恶意行为将导致识别出一个诚实方\(P_\mathsf{TP}\)进行明文计算.</p>
<p>乘法协议\(\Pi_\mathsf{Mult}\)修改如下: 首先将\(\Pi_\mathsf{JSh}\)替换为鲁棒版本, 这确保了传递的信息的正确性, 或者识别出一个参与方集合, 其中一方是腐化方. 接下来, 为了确保预处理阶段\(P_0\)发送的\(w\)的正确性, 引入下图4的协议\(\Pi_\mathsf{VrfyP0}\). 若该协议失败, 则参与方在预处理阶段识别出一个诚实方\(P_\mathsf{TP}\). 最后, 在线阶段若出现\(\mathtt{abort}\)的情况, 则\(P_0\)将被认定为\(P_\mathsf{TP}\). 因为\(P_0\)不参与乘法在线阶段的计算, 且预处理阶段的发送的信息可通过\(\Pi_\mathsf{VrfyP0}\)验证, 因此这样做是安全的.</p>
<p>现在说明在预处理阶段如何验证\(P_0\)的发送的信息\(w\)的正确性. 在乘法协议\(\Pi_\mathsf{Mult}\)中, \(P_0\)计算并发送\(w=\gamma_{ab}^1+\gamma_{ab}^2+s_1+s_2\)给\(P_3\), 其中\(P_0,P_1,P_2\)已知明文的\(s_1,s_2\). 注意到对\(w^1=\gamma_{ab}^1+s_1\)和\(w^2=\gamma_{ab}^2+s_2\), \(w=w^1+w^2\). \(P_0\)连同\(P_1,P_2,P_3\)分别拥有\(w^1,w^2\)和\(w\). 所以, 检验\(w\)的正确性, 可简化为验证\(w\overset{?}{=}w^1+w^2\)是否成立. 为了对所有\(M\)个乘法电路门验证这条关系, 即\(\{w_j\overset{?}{=}w_j^1+w_j^2\}_{j\in[M]}\), 一种方式是计算随机线性组合并验证总和的关系式. 当在\(\mathbb{F}_p\)上计算时, 这种方案有$1/|\mathbb F_p|$的错误概率, 其中$|\mathbb F_p|$是\(\mathbb F_p\)的大小. 然而, 这种方案不能直接在环上进行, 因为环上并非所有的元都有逆元. 具体而言, 恶意行为可通过检验的概率至多为\(1/2\). 为了降低恶意行为通过检验的概率, 可将检验重复\(\kappa\)次, 从而将概率降为\(1/2^\kappa\). 作为优化, 可选取\(\{0,1\}\)的随机组合验证. 如此, 对于一次检验, 参与方只需要使用预分享密钥选取\(M\)比特的二进制字符串. 完整的验证协议如下:</p>
<img src="media/16553844634309/16553848145181.png" alt="image-20220405151225897" style="zoom:50%;" />
<p>若在预处理阶段生成了\(\mathtt{abort}\)信号, 则鲁棒协议还可以进一步优化. 具体来说, 中止信号要么来自jsnd的验证阶段, 要么来自\(\Pi_\mathsf{VrfyP0}\)的输出. 当检测到恶意行为时, 发现腐化方的方法是: 参与方首先广播他们在密钥设置阶段建立的预分享密钥, 然后重新计算所有预处理数据并验证所传输的数据来找出腐化方. 这里泄漏预分享密钥不会泄漏输入, 因为预处理数据与输入无关. 在找出腐化方后做法与Fantastic Four相同, 将腐化方从计算中剔除, 然后执行半诚实安全的三方计算协议完成计算任务, 实现GOD.</p>
<h3><a id="supporting-on-demand-computations" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supporting On-demand Computations</h3>
<p>由于按需计算时底层函数是未知的, 因此无法进行预处理. 在Tetrad中, 通过将预处理阶段转移到在线阶段执行来支持按需计算, 同时仍保持相同的通信开销, 此时的在线阶段变为4PC计算. 与上面的\(\Pi_\mathsf{Mult}\)不同之处在于: 按需计算的乘法协议\(\Pi_\mathsf{Mult}^\mathsf{NoPre}\)将\(\Pi_\mathsf{Mult}\)的预处理阶段中的第1-3步直接移到在线阶段, 第4步直接移到验证阶段. 具体协议过程如下,</p>
<img src="media/16553844634309/16553848143405.png" alt="TETRAD14" style="zoom:50%;" />
<h2><a id="mixed-protocol-framework" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mixed Protocol Framework</h2>
<p>在本文中, 混淆电路被用于对某些函数进行中间评估, 其中函数的输入输出均为\([[\cdot]]\)-shared或\([[\cdot]]^\mathbf G\)形式. 为此, Tetrad中设计了形式为x-Garbled-x的端到端转换, 其中x可为Arithmetic或者Boolean. 与Trident类似, 本文通过三方混淆电路方案设计了一个实现公平性的混淆世界, 并进一步扩展实现鲁棒性, 而不会增加开销. 利用混淆者诚实占大多数的性质和jsnd, 只需要半诚实的GC计算即可达到主动安全. 本文与Trident相比的结果如下, 端到端转换的在线轮次可以进一步减少到1, 但代价是并行计算中需要再传递一个额外的GC, 记此为2GC变体.</p>
<img src="media/16553844634309/16553848142225.png" alt="image-20220520173629040" style="zoom:50%;" />
<h3><a id="gc-for-mixed-protocol-framework" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>GC for Mixed Protocol Framework</h3>
<p>2GC变体有两个并行执行实例, 每个执行包含3个混淆方和1个评估方. 两个独立的执行中\(P_1,P_2\)分别作为评估方, \(\Phi_1=\{P_0,P_2,P_3\}\), \(\Phi_2=\{P_0,P_1,P_3\}\)分别作为混淆方.</p>
<p>混淆评估分为三个阶段: 输入阶段、评估阶段、输出阶段. 输入阶段为GC的每个输入传输相应的密钥给评估方. 其输入形式为\([[\cdot]]^\mathbf B\)份额. 由于在每个混淆实例中函数输入的每个份额都被两个混淆方所持有, 因此可以通过jsnd来确保传输了正确的密钥. 评估阶段包含GC传输和GC评估. 最后在输出阶段, 评估方得到编码输出.</p>
<ul>
<li>
<p>输入阶段: 给定函数输入\(x\)的秘密份额形式\([[x]]^\mathbf B\), 布尔值\(m_x,\alpha_x,\lambda_x^3\), 其中\(\alpha_x=\lambda_x^1\oplus\lambda_x^2\)和\(x=m_x\oplus\alpha_x\oplus\lambda_x^3\), 作为混淆计算的新输入, 为这些值生成\([[\cdot]]^\mathbf{G}\)形式的混淆份额. \([[\cdot]]^\mathbf B\)的语义确保在每个混淆实例中有两个混淆方持有\((m_x,\alpha_x,\lambda_x^3)\). 面向份额的密钥要么调用jsnd正确地发送给了评估方, 要么检测出不一致. 这种密钥交付实质上为这三个值的每一个生成了\([[\cdot]]^\mathbf G\)-sharing, 从而让GC评估. 因此, 输入阶段的目标是对于要通过GC评估的函数的每个输入\(x\)建立组合份额\([[x]]^\mathbf C=([[m_x]]^\mathbf G,[[\alpha_x]]^\mathbf G,[[\lambda_x^3]]^\mathbf G)\). 下面先讨论\([[\cdot]]^\mathbf G\)-sharing的语义, 然后说明生成\([[\cdot]]^\mathbf C\)-sharing的步骤.</p>
</li>
<li>
<p>混淆份额语义: 秘密\(v\)在\(\mathcal P\)中是\([[\cdot]]^\mathbf G\)-shared, 若\(P_i\in\{P_0,P_3\}\)拥有\([[v]]_i^\mathbf G=(K_v^{0,1},K_v^{0,2})\), \(P_1\)拥有\([[v]]_1^\mathbf G=(K_v^{v,1},K_v^{0,2})\), \(P_2\)拥有\([[v]]_2^\mathbf G=(K_v^{0,1},K_v^{v,2})\). 这里, 对\(j\in\{1,2\}\), \(K_v^{v,j}=K_v^{0,j}\oplus v\Delta^j\), \(\Delta^j\)是\(\Phi_j\)中的混淆方已知的信息, 代表最后一比特为1的全局偏移量且电路中的每根导线都相同. \(x\in\mathbb Z_2\)被称为\([[\cdot]]^\mathbf C\)-shared (compound shared), 若来自\((m_x,\alpha_x,\lambda_x^3)\)的每个值, 都通过上述\([[\cdot]]\)-shared定义. 记\([[x]]^\mathbf C=([[m_x]]^\mathbf G,[[\alpha_x]]^\mathbf G,[[\lambda_x^3]]^\mathbf G)\).</p>
</li>
<li>
<p>生成\([[v]]^\mathbf G\)和\([[x]]^\mathbf C\): 下图中的协议\(\Pi_\mathsf{Sh}^\mathbf G(\mathcal P,v)\)可以生成\([[v]]^\mathbf G\), 在每个混淆实例中两个混淆方持有\(v\), 处理方式如下: 考虑第一个混淆实例, 评估方为\(P_1\), 混淆方\(P_k,P_l\)持有\(v\). \(\Phi_1\)中的混淆方生成\(\{K_v^{b,1}\}_{b\in\{0,1\}}\)代表导线\(w\)上\(b\)的密钥, 遵循free-XOR技术. \(P_k,P_l\)调用jsnd发送\(K_v^{v,1}\)给\(P_1\). 第二个混淆的实例类似处理, 最后\(\Phi_2\)中的混淆方生成\(\{K_v^{b,2}\}_{b\in\{0,1\}}\), \(P_2\)持有\(K_v^{v,2}\). 如此, \(P_s\in\mathcal P\)拥有的\([[v]]_s^\mathbf G\)定义为\([[v]]_0^\mathbf G=[[v]]_3^\mathbf G=(K_v^{0,1},K_v^{0,2})\), \([[v]]_1^\mathbf G=(K_v^{v,1},K_v^{0,2})\), \([[v]]_2^\mathbf{G}=(K_v^{0,1},K_v^{v,2})\).</p>
<p>为了生成\([[x]]^\mathbf C\), 给定\([[x]]^\mathbf B\), 需要生成\(([[m_x]]^\mathbf G,[[\alpha_x]]^\mathbf G,[[\lambda_x^3]]^\mathbf G)\). 为此, 可以对每个\(m_x,\alpha_x,\lambda_x^3\)调用\(\Pi_\mathsf{Sh}^\mathbf G\).</p>
</li>
</ul>
<img src="media/16553844634309/16553848144397.png" alt="image-20220405205838741" style="zoom:50%;" />
<h3><a id="2gc-variant" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2GC Variant</h3>
<h4><a id="evaluation-phase" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Evaluation phase</h4>
<p>令所要评估的函数为\(f(x)\), 函数输入为\([[\cdot]]^\mathbf C\), 即计算\(f(m_x,\alpha_x,\lambda_x^3)\). 令\(\mathsf{GC}_j\)表示\(\Phi_j\)发送给\(P_j\in\{P_1,P_2\}\)的混淆电路. 为了减少通信轮次, 在\([[x]]^\mathbf C\)生成期间, 发送\(\mathsf{GC}_j\)的同时也进行密钥传输, 其中\(\{P_0,P_3\}\)通过jsnd发送\(\mathsf{GC}_j\)给\(P_j\). 在收到\(\mathsf{GC}\)后, 评估方对相应的混淆电路进行求值得到输出对应的密钥\(z\)的份额\([[z]]^\mathbf G\).</p>
<h4><a id="output-phase" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Output phase</h4>
<p>输出阶段的目标是从\([[z]]^\mathbf G\)计算并输出\(z\). 为了向\(P_j\in\{P_1,P_2\}\)重构\(z\), \(\Phi_j\)中两个混淆方发送解码信息\(p^j=\mathsf{LSB}(K_z^{0,j})\)给\(P_j\). 若收到的信息一致, 则\(P_j\)使用收到的\(p^j\)重构\(z=p^j\oplus q^j\), 其中\(q^j=\mathsf{LSB}(K_z^{z,j})\); 否则\(P_j\)中止. 为了向混淆方\(P_g\in\{P_0,P_3\}\)重构\(z\), 评估方\(P_1\)发送\(q^1=\mathsf{LSB}(K_z^{z,1})\)和\(\mathcal H=\mathsf{H}(K_z^{z,1})\)给\(P_g\), 其中\(\mathsf{H}\)是一个抗碰撞哈希函数. 若混淆方从\(P_1\)收到的\((q^1,\mathcal H)\)满足存在\(K\in\{K_z^{0,1},K_z^{1,1}\}\), 使得\(q^1=\mathsf{LSB}(K)\), 且\(\mathsf{H}(K)=\mathcal H\), 则使用\(q^1\)重构\(z=p^1\oplus q^1\); 否则混淆方中止计算. 注意由于混淆方案的可靠性, 腐化的评估方\(P_1\)不能通过发送并非输出的密钥来欺骗\(\{P_0,P_3\}\)中的混淆方. 重构是轻量级的, 对于混淆方需要单轮, 而对评估方的重构可以与密钥传输同时进行, 不会产生额外的通信轮次. 具体协议如下:</p>
<img src="media/16553844634309/16553848150080.png" alt="image-20220521210830257" style="zoom:50%;" />
<h4><a id="optimizations" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Optimizations</h4>
<p>当部署到混合框架中时, 预处理阶段传输(通信密集的)GC, 并生成独立于输入\(x\)的\(\alpha_x,\lambda_x^3\)的\([[\cdot]]^\mathbf{G}\)份额. 因此, 在线阶段非常轻量级, 且仅需1轮生成\(x\)的\([[\cdot]]^\mathbf{G}\)份额中的\(m_x\). 由于评估是本地计算, 评估方在1轮结束时得到GC输出的\([[\cdot]]^\mathbf G\)份额.</p>
<h4><a id="security" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Security</h4>
<ul>
<li>Fairness: 首先确认所有参与方都仍在参与协议, 若是, 则按图19中的协议进行公平重构计算, 但主要的不同是: 对于向评估方的重构, 所有三个混淆方发送各自解码信息给评估方. 评估方选择出现最多的值进行重构; 对于向混淆方\(P_0,P_3\)的重构, 评估方发送输出密钥的最低位及其哈希值给混淆方, 由于至少存在一个评估方是诚实的, 因此混淆方将保持一致.</li>
<li>GOD: 与Fairness最主要的不同是, 使用了鲁棒的jsnd原语来保证当检测到恶意行为时识别出一个诚实方进行相关计算并向所有参与方输出计算结果.</li>
</ul>
<h3><a id="1gc-variant" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1GC Variant</h3>
<p>1GC变体的输入\(x=x_1\oplus x_2\oplus x_3\), 其中份额\(x_1=m_x\oplus\lambda_x^2\), \(x_2=\lambda_x^3\)和\(x_3=\lambda_x^1\), 定义\([[x]]^\mathbf B\)为\(m_x\), \(\lambda_x^1\), \(\lambda_x^2\), \(\lambda_x^3\). GC的密钥由三个混淆方\(P_0,P_2,P_3\)选取, 其中\(P_0\), \(P_3\)生产并通过jsnd发送GC给求值方\(P_1\), \(P_2\)负责辅助密钥传输. 具体来说, \(P_0\)和\(P_3\)在混淆之前, 将共同输入\(x_3\)硬编码到电路中. 如此只需要对输入\(x_1,x_2\)进行密钥传输. 混淆方\(P_0,P_2,P_3\)按照与2GC中类似的过程为输入生成密钥, 然后, \(P_2,P_3\)通过jsnd发送\(x_1\)给\(P_1\), 同时混淆方\(P_0,P_2\)通过jsnd发送\(x_2\)的密钥给\(P_1\).</p>
<p>评估阶段和输出重构阶段和2GC变体类似, 只是1GC变体仅有一个混淆实例. 在混合协议框架中, 必须向\(P_1,P_2\)重构输出. 向\(P_1\)的重构不会产生额外的通信轮次, 因为解码信息的发送可与密钥传输同时进行. 在2GC变体中, 向\(P_2\)的重构类似于向\(P_1\)的重构, 而在1GC变体中需要额外通信一轮, 因为\(P_2\)不再是求值方.</p>
<ul>
<li>Fairness: 为了实现公平重构协议, 参与方首先需要进行一次aliveness check. 然后按照如下方法重构\(z\). 首先, \(P_1\)发送\(q=\mathsf{LSB}(K_z^z)\)和\(\mathcal H=\mathsf{H}(K_z^z)\)给\(P_g\in\Phi_1\). 若混淆方从\(P_1\)处收到了一致的\((q,\mathcal H)\), 满足存在\(K\in\{K_z^{0},K_z^{1}\}\), 使得\(q=\mathsf{LSB}(K)\), 且\(\mathsf{H}(K)=\mathcal H\), 则使用\(q\)计算\(z\), 并发送\(z\)给与其协作的混淆方. 否则混淆方接受从协作混淆方收到的\(z\)作为输出. 由此混淆方对输出的进一步传播可以确保所有各方都保持一致. 如果混淆方接收到输出, 则对\(P_1\)进行\(z\)的重构. 为此, 所有接收输出的混淆方将解码信息发给\(P_1\), \(P_1\)选择多数值来重构\(z\).</li>
<li>GOD: 为实现鲁棒性, 与公平协议的主要不同如下: 首先, 需要使用鲁棒的jsnd. 其次, 在输入共享协议中, 只有混淆方\(P_0\)有\(x_1\), 腐化的\(P_0\)可能不会向\(P_1\)提供正确的密钥(作为承诺的打开信息发送). 为了确保达到鲁棒性, 如果\(P_1\)未能从\(P_0\)收到正确的密钥, 则让\(P_1\)发送不一致比特给所有参与方. 所有参与方交换该不一致比特, 并接受其中的多数值. 若所有参与方都确认了存在不一致, 则确定\(P_0,P_1\)中存在腐化方, 令\(P_2\)作为TTP进行剩下的计算. 为了确保鲁棒重构, 采用以下方法: 观察到只要\(P_1\)是诚实的, 公平的重构就提供了鲁棒性. 如果没有混淆方获得公平协议中输出, 则可以确认\(P_1\)是腐化方, 在这种情况下, 各方选取\(P_0\)作为TTP进行相关计算并重构输出实现鲁棒性.</li>
</ul>
<h3><a id="conversions-involving-garbled-world" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conversions involving Garbled World</h3>
<p>假设需用GC计算函数\(f\), 输入为\(x,y\in\mathbb Z_{2^\ell}\), 输出为\(f(x,y)\). 描述的所有转换均适用于2GC变体. 对于Fairness和Robustness变体, 转换是通用的, 其中的安全性来自于底层密码原语的安全性.</p>
<ul>
<li>Case I: Boolean-Garbled-Boolean. GC的输入为\([[x]]^\mathbf B,[[y]]^\mathbf B\), 参与方调用\(\Pi_\mathsf{Sh}^\mathbf G\)生成\([[x]]^\mathbf C, [[y]]^\mathbf C\). 此外, 参与方\(P_0,P_3\)采样\(R\in\mathbb Z_{2^\ell}\)茫化函数输出\(f(x,y)\), 生成\([[R]]^\mathbf B\)和\([[R]]^\mathbf G\). 混淆方\(P_g\in\{P_0,P_2,P_3\}\)混淆计算\(z=f(x,y)\oplus R\)的电路, 发送GC及其解码信息给评估方\(P_1\). 如此也对评估方\(P_2\)进行类似的步骤. 经过GC评估和输出解码后, 评估方可以得到\(z=f(x,y)\oplus R\), 并调用\(\Pi_\mathsf{JSh}^\mathbf B\)生成\([[z]]^\mathbf B\). 最后参与方计算\([[f(x,y)]]^\mathbf B=[[z]]^\mathbf B\oplus[[R]]^\mathbf B\).</li>
<li>Case II: Boolean-Garbled-Arithmetic. 与Case I类似, 除了电路计算的是\(z=f(x,y)+ R\). \(z\)的布尔份额替换为算术份额\([[z]]\), 最后计算\([[f(x,y)]]=[[z]]-[[R]]\).</li>
<li>Case III &amp; IV: Arithmetic-Garbled-Arithmetic, Arithmetic-Garbled-Boolean. 要计算的函数\(f(x,y)\)修改为\(f'(m_x,\alpha_x,\lambda_x^3,m_y,\alpha_y,\lambda_y^3)=f(m_x-\alpha_x-\lambda_x^3,m_y-\alpha_y-\lambda_y^3)\), 其中输入\(x,y\)被替换为\(\{m_x,\alpha_x,\lambda_x^3\}\), \(\{m_y,\alpha_y,\lambda_y^3\}\), \(\alpha_x=\lambda_x^1+\lambda_x^2\)和\(\alpha_y=\lambda_y^1+\lambda_y^2\). 输入的份额可由\(\Pi_\mathsf{Sh}^\mathbf G\)生成, 其余计算步骤同Case I和Case II, 取决于输出的份额形式.</li>
</ul>
<p>以上2GC变体转换通信量和通信轮次与Trident的相应方案理论对比:</p>
<img src="media/16553844634309/16553848142865.png" alt="image-20220406195314456" style="zoom:50%;" />
<h3><a id="other-conversions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Other Conversions</h3>
<ul>
<li>Arithmetic to Boolean (<strong>A2B</strong>): \([[v]]\rightarrow[[v]]^\mathbf B\). 因为\(v=v_1+v_2\), \(P_1,P_2\)可计算\(v_1=m_v-\lambda_v^3\), \(P_0,P_3\)可计算\(v_2=-(\lambda_v^1+\lambda_v^2)\). 因此, \([[v]]^\mathbf B=[[v_1]]^\mathbf B+[[v_2]]^\mathbf B\), 其中\([[v_2]]^\mathbf B\)可在预处理阶段生成, \([[v_1]]^\mathbf B\)可在在线阶段通过参与方执行\(\Pi_\mathsf{JSh}^\mathbf B\)生成. 完整的A2B协议过程如下:</li>
</ul>
<img src="media/16553844634309/16553848140996.png" alt="image-20220406093942463" style="zoom:50%;" />
<ul>
<li>Boolean to Arithmetic (<strong>B2A</strong>): \([[v]]^\mathbf B\rightarrow[[v]]\). 利用如下关系式</li>
</ul>
\[
  v=\sum_{i=0}^{\ell-1}2^iv_i=\sum_{i=0}^{\ell-1}2^i(\lambda_{v_i}\oplus m_{v_i})=\sum_{i=0}^{\ell-1}2^i\left({m_v}_i^\mathsf R+{\lambda_v}_i^\mathsf R(1-2{m_v}_i^\mathsf R)\right).
  
\]
<p>其中, \({\lambda_v}_i^\mathsf R, {m_v}_i^\mathsf R\)分别表示环\(\mathbb Z_{2^\ell}\)上的比特\({\lambda_v}_i, {m_v}_i\)的算术值. 计算中需要借助\(\Pi_\mathsf{bit2A}\)协议, 完整的B2A协议过程如下:</p>
<img src="media/16553844634309/16553848147988.png" alt="image-20220406094209368" style="zoom:50%;" />
<ul>
<li>
<p>Bit to Arithmetic (<strong>Bit2A</strong>): 给定比特\(b\)的布尔份额\([[b]]^\mathbf B\), \(\Pi_\mathsf{bit2A}\)计算其算术份额\([[b]]\). 设\(b^\mathsf R\)表示\(b\in\{0,1\}\)在算术环\(\mathbb Z_{2^\ell}\)的值, 则对于\(b=b_1\oplus b_2\), \(b^\mathsf R=(b_1^\mathsf R-b_2^\mathsf R)^2\). 令\(b_1=m_b\oplus\lambda_v^3\), \(b_2=\lambda_v^1\oplus\lambda_v^2\). 为计算\([[b]]\), 可让一对参与方执行\(\Pi_\mathsf{JSh}\)生成对应于\(b_1^\mathsf R\)和\(b_2^\mathsf R\)的算术份额, 然后调用一次\(\Pi_\mathsf{Mult}\), 输入\(x=y=b_1^\mathsf R-b_2^\mathsf R\)来计算\(b^\mathsf R\).</p>
<p>可以通过Trident和SWIFT中的方法进一步权衡预处理阶段的通信和计算开销. 计算原理如下:</p>
</li>
</ul>
\[
  b^\mathsf R=(m_b\oplus\lambda_b)^\mathsf R=m_b^\mathsf R+\lambda_b^\mathsf R-2m_b^\mathsf R\lambda_b^\mathsf R=m_b^\mathsf R+(\lambda_b^\mathsf R)(1-2m_b^\mathsf R)
  
\]
<p>具体协议过程如下, 预处理阶段需要\(3\ell+1\)比特通信量, 在线阶段需要\(3\ell\)比特通信量, 1轮.</p>
  <img src="media/16553844634309/16553848156426.png" alt="image-20220406160848869" style="zoom:50%;" />
<h2><a id="building-blocks" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building Blocks</h2>
<h3><a id="dot-product" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dot Product</h3>
<p>给定长度为\(d\)的向量份额\([[\vec{\mathbf a}]],[[\vec{\mathbf b}]]\), \(\Pi_\mathsf{dotp}\)计算\([[z]]\), 使得\(z=(\vec{\mathbf a}\odot\vec{\mathbf b})^t\)(截断)或者\(z=\vec{\mathbf a}\odot\vec{\mathbf b}\)(不截断). 整体思路与SWIFT和Trident类似, 先对\(d\)个乘法项的部分份额求和, 然后进行一次通信. 此外, 矩阵乘法可以看成点积协议的扩展形式, 卷积计算可以简化为矩阵乘法计算(参考SecureNN), 因此计算方式与之类似. 完整的点积计算协议如下, 预处理阶段需要\(2\ell\)比特通信量, 在线阶段需要\(3\ell\)比特通信量, 1轮.</p>
<img src="media/16553844634309/16553848151304.png" alt="image-20220406103954198" style="zoom:50%;" />
<h3><a id="multi-input-multiplication" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multi-input Multiplication</h3>
<p>多输入乘法计算的方法与ABY2.0相同. 例如, 考虑3输入乘法计算, 给定\([[a]],[[b]],[[c]]\), 计算\([[z]]\), 其中\(z=abc\). 计算原理与2输入乘法协议类似:</p>
\[\begin{aligned}
z-r&amp;=abc-r=(m_a-\lambda_a)(m_b-\lambda_b)(m_c-\lambda_c)-r\\
&amp;=m_{abc}-m_{ac}\lambda_b-m_{bc}\lambda_a-m_{ab}\lambda_c+m_a\gamma_{bc}+m_b\gamma_{ac}+m_c\gamma_{ab}-\gamma_{abc}-r.
\end{aligned}
\]
<p>类似于2输入乘法公平计算协议(图3), \(P_1,P_2\)需要在预处理阶段生成交叉项\(\gamma_{ab},\gamma_{ac},\gamma_{bc},\gamma_{abc}\)的加法份额, 不能本地计算的\(\gamma\)相关项可由\(P_0,P_3\)计算并分享给\(P_1,P_2\). 与\(\Pi_\mathsf{Mult}\)相比, 在线阶段的通信量不变, 但预处理阶段的通信量变为9个环元素. 完整的3输入乘法公平计算协议如下, 预处理阶段需要\(9\ell\)比特通信量, 在线阶段需要\(3\ell\)比特通信量, 1轮. 类似地可以定义4输入乘法计算协议.</p>
<img src="media/16553844634309/16553848148949.png" alt="Tetrad15" style="zoom:50%;" />
<h3><a id="secure-comparison" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secure Comparison</h3>
<p>给定\([[a]],[[b]]\), 比较协议计算\(a&gt;b\), 即通过\(\Pi_\mathsf{bitext}\)抽取\(v=a-b\)的最高有效位, 然后利用关系\((a&gt;b)=1\oplus\mathsf{MSB}(v)\)求解. 而\(\Pi_\mathsf{bitext}\)有两种方案:</p>
<ul>
<li>ABY3中通信量优化的Parallel prefix adder (PPA);</li>
<li>ABY2.0中通信轮次优化的比特抽取电路.</li>
</ul>
<p>由于\(v=m_v-\lambda_v=(m_v-\lambda_v^3)+(-\lambda_v^1-\lambda_v^2)\), 在预处理阶段\(P_0,P_3\)执行\(\Pi_\mathsf{JSh}^\mathbf B(-\lambda_v^1-\lambda_v^2)\rightarrow[[-\lambda_v^1-\lambda_v^2]]^\mathbf B\), 在线阶段\(P_0,P_3\)执行\(\Pi_\mathsf{JSh}^\mathbf B(m_v-\lambda_v^3)\rightarrow[[m_v-\lambda_v^3]]^\mathbf B\).</p>
<h3><a id="bit-injection" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bit Injection</h3>
<p>给定比特\(b\)的布尔份额\([[b]]^\mathbf B\), \(v\in\mathbb Z_{2^\ell}\)的算术份额\([[v]]\), \(\Pi_\mathsf{bitInj}\)计算\([[bv]]\). 类似于\(\Pi_\mathsf{bit2A}\), 计算原理如下:</p>
\[\begin{aligned}
(bv)^\mathsf R&amp;=(m_b\oplus\lambda_b)^\mathsf R(m_v-\lambda_v)\\
&amp;=(m_b^\mathsf R+(\lambda_b^\mathsf R)(1-2m_b^\mathsf R))(m_v-\lambda_v)\\
&amp;=m_b^\mathsf Rm_v-m_b^\mathsf R\lambda_v+(2m_b^\mathsf R-1)((\lambda_b^\mathsf R)\lambda_v-m_v(\lambda_b^\mathsf R)).
\end{aligned}
\]
<p>预处理阶段需\(6\ell+1\)比特通信量, 在线阶段需\(3\ell\)比特通信量, 1轮.</p>
<h3><a id="oblivious-selection" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Oblivious Selection</h3>
<p>与不经意传输类似, 给定\([[x_0]]\), \([[x_1]]\)和\([[b]]^\mathbf B\), 不经意选取协议\(\Pi_\mathsf{obv}\)可让参与方生成\(z=x_b\)的\([[\cdot]]\)份额\([[z]]\). 计算原理在于利用关系式\(z=b(x_1-x_0)+x_0\),  其中\([[b(x_1-x_0)]]\)可以通过\(\Pi_\mathsf{bitInj}\)来计算.</p>
<h3><a id="piece-wise-polynomial" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Piece-wise Polynomial</h3>
<p>与ABY3类似, 非线性的激活函数计算可通过分段多项式近似计算, 而分段多项式计算可看成是由一系列常数公开多项式\(f_1,\cdots,f_m\)和\(c_1&lt;\cdots&lt;c_m\)组成的, 使得</p>
\[f(y)=
\begin{cases}
0,&amp;y&lt;c_1\\
f_1,&amp;c_1\leq y&lt;c_2\\
\cdots\\
f_m,&amp;c_m\leq y
\end{cases}
\]
<p>则有\(f(y)=\sum_{i=1}^mb_i\cdot(f_i-f_{i-1})\), 其中\(f_0=0\), \(f_m=1\), 对于\(i\in\{1,\cdots,m\}\), 若\(y\geq c_i\), 则\(b_i=1\), 否则\(b_i=0\). 因此可以通过安全比较协议和\(\Pi_\mathsf{bitInj}\)来计算. 在线阶段若对每个\(b_i\cdot(f_i-f_{i-1})\)调用\(\Pi_\mathsf{JSh}\), 则需要调用\(m\)次, 可以首先计算\(f(y)\)的加法份额, 然后调用\(\Pi_\mathsf{JSh}\)一次从而独立于\(m\)来优化通信. 具体协议过程如下, 预处理阶段需要\(m(6\ell+1)\)比特通信量, 在线阶段需要\(3\ell\)比特通信量, 1轮.</p>
<img src="media/16553844634309/16553848148549.png" alt="image-20220406201023942" style="zoom:50%;" />
<ul>
<li>ReLU函数: \(\mathsf{ReLU}(v)=\begin{cases} 0,&amp; v&lt;0\\ v, &amp;0\leq v \end{cases}\)</li>
<li>Sigmoid函数: 与SecureML一致, \(\mathsf{Sig}(v)=\begin{cases}0,&amp; v&lt;-1/2\\ v+1/2,&amp;-1/2\leq v\leq 1/2\\ 1,&amp;1/2&lt;v \end{cases}\)</li>
</ul>
<h3><a id="argmin-argmax" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ArgMin / ArgMax</h3>
<p>给定长度为\(m\)的向量\(\vec{\mathbf x}=(x_1,\cdots,x_m)\)的\([[\cdot]]\)-sharing, \(\Pi_\mathsf{argmin}\)计算最小元素所在的索引, 输出长度为\(m\)的one-hot比特向量\(\vec{\mathbf b}\)的\([[\cdot]]^\mathbf B\)-shared, 其中最小元素所在索引置为1, 其余为0. 本文中使用的是Damgård等人在S&amp;P'19提出的基于二叉树的方法通过分组比较和递归的方式来计算\(\vec{\mathbf x}\)中的最小元素, 并同时更新\(\vec{\mathbf b}\). 首先将\(\vec{\mathbf b}\)的每个比特都初始化为1. 通过将\(\vec{\mathbf x}\)的元素进行分组, 逐对进行安全比较得出最小值所在位置, 并更新另一个位置的值为0. 如此递归最后只有整个向量中的最小值所在位置仍为1, 其余为0. 类似的思想可以用于\(\Pi_\mathsf{argmax}\)求最大值所在的索引. 完整的协议过程如下:</p>
<img src="media/16553844634309/16553848149026.png" alt="image-20220406201642426" style="zoom:50%;" />
<h2><a id="implementation-and-benchmarking" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation and Benchmarking</h2>
<p>实验部分只针对实现公平性的方案, 不考虑鲁棒性, 因为后者使用了鲁棒的联合发送原语(jsnd)且预处理阶段最后进行一次性验证, 相比前者, 后者开销更小.</p>
<p>实验相关基准含义如下:</p>
<img src="media/16553844634309/16553848150574.png" alt="image-20220406205748028" style="zoom:50%;" />
<h3><a id="ml-training" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ML Training</h3>
<img src="media/16553844634309/16553848156754.png" alt="image-20220406205916881" style="zoom:50%;" />
<img src="media/16553844634309/16553848153745.png" alt="image-20220406205955926" style="zoom:50%;" />
<img src="media/16553844634309/16553848153620.png" alt="image-20220406210030027" style="zoom:50%;" />
<h3><a id="ml-inference" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ML Inference</h3>
<img src="media/16553844634309/16553848153437.png" alt="image-20220406210649109" style="zoom:50%;" />
<img src="media/16553844634309/16553848151901.png" alt="image-20220406210716274" style="zoom:50%;" />
<img src="media/16553844634309/16553848153998.png" alt="image-20220406212626585" style="zoom:50%;" />
<h2><a id="conclusions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusions</h2>
<p>Tetrad是一个遵循离线-在线范式的主动安全的4PC机器学习框架, 分别实现了Fairness和GOD, 所使用的底层秘密共享语义和Trident框架基本相同, 主要的不同点在于四方份额分布以及在不同阶段中所起的作用, 协议设计在原理上并没有太大差别, 所构造协议的通信效率有所改进. Trident实现Fairness的核心思想则与Trident相同, 由于四方中只有一个腐化方, 因此验证阶段可以使其他诚实方达成一致的继续/中止信号. Tetrad实现GOD的核心思想结合了FALSH、SWIFT的思想, 通过Robust Joint-Send原语发现恶意行为后选出某个诚实方作为TTP进行明文计算, 此时不考虑对诚实方保持隐私, 因此Tetrad并不满足FaF安全性(Friends-and-Foes Security, CRYPTO'20).</p>
<h2><a id="references" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>References</h2>
<p>[1] M. Byali, H. Chaudhari, A. Patra, and A. Suresh, “FLASH: Fast and robust framework for privacy-preserving machine learning,” PoPETs, vol. 2020, no. 2, pp. 459–480, Apr. 2020.</p>
<p>[2] H. Chaudhari, R. Rachuri, and A. Suresh, “Trident: Efficient 4PC framework for privacy preserving machine learning,” in NDSS 2020. The Internet Society, Feb. 2020.</p>
<p>[3] P. Mohassel and P. Rindal, “ABY3: A mixed protocol framework for machine learning,” in ACM CCS 2018, D. Lie, M. Mannan, M. Backes, and X. Wang, Eds. ACM Press, Oct. 2018, pp. 35–52.</p>
<p>[4] S. Wagh, D. Gupta, and N. Chandran, “SecureNN: 3-party secure computation for neural network training,” PoPETs, vol. 2019, no. 3, pp. 26–49, Jul. 2019.</p>
<p>[5] N. Koti, M. Pancholi, A. Patra, and A. Suresh, “SWIFT: Super-fast and Robust Privacy-Preserving Machine Learning,” in USENIX Security’21, 2021.</p>
<p>[6] I.Damga ̊rd,D.Escudero,T.K.Frederiksen,M.Keller,P.Scholl,and N. Volgushev, “New primitives for actively-secure MPC over rings with applications to private machine learning,” in 2019 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2019, pp. 1102–1120.</p>
<p>[7] A. Patra, T. Schneider, A. Suresh, and H. Yalame, “ABY2.0: Improved Mixed-Protocol Secure Two-Party Computation,” in USENIX Security’21, 2021.</p>
<p>[8] A. Dalskov, D. Escudero, and M. Keller, “Fantastic Four: Honest-Majority Four-Party Secure Computation With Malicious Security,” in USENIX Security’21, 2021.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simulation-based Security]]></title>
    <link href="https://weiviming.github.io/16525868704962.html"/>
    <updated>2022-05-15T11:54:30+08:00</updated>
    <id>https://weiviming.github.io/16525868704962.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本文译自Daniel Escudero的文章An Introduction to Secret-Sharing-Based Secure Multiparty Computation, 原文链接: <a href="https://eprint.iacr.org/2022/062">https://eprint.iacr.org/2022/062</a></p>
</blockquote>
<h2><a id="%E8%83%8C%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>背景</h2>
<p>现代密码学的主要成就之一在于适当地将一些结构形式化, 如加密或数字签名, 从而使严格的数学推理可以应用于这些结构. 这样一来, 就可以实现具体的保障和不同概念之间的关系, “可证明安全”的想法便是一个例子.</p>
<p>安全多方计算在80年代末作为一项有趣的研究任务出现, 它有许多潜在的应用, 并涉及非常有趣的技术. 然而, 过了近十年后, 才出现了更多关于安全多方计算的正式理论, 从而能够对该领域进行更严格的处理. 安全多方计算任务的“数学框架”不是平凡的, 这无疑是对其本身的贡献.</p>
<h2><a id="%E6%A6%82%E8%A7%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概览</h2>
<p>当前有几种不同的框架来形式化安全多方计算协议, 例如独立模型(Stand-alone model)、UC框架<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup>和SUC框架等等. 然而, 尽管从一个模型到另一个模型有细微差异, 但这些方法的共同点是通过模拟(Simulation)来定义安全. 这种想法在零知识证明领域已经很普遍, 例如, 它的目的是正确定义“不学习除\(X\)以外的信息”的概念. 为了提供一个关于这种技术的高层次概念, 考虑一个给定的安全多方计算协议是安全的, 这个想法与确保腐化了参与方子集的敌手不会从诚实方那里学习到任何关于输入的信息有关, 除了从计算本身输出所泄漏的信息之外.</p>
<p>将敌手不学习某些数据的想法形式化在密码学中很常见, 因为它已经出现在诸如加密方案等结构中, 这些结构是用基于游戏的安全证明(Game-based Security)形式化的. 简而言之, 基于游戏的安全考虑了这样的场景: 敌手与系统交互, 试图区分某些打算隐藏的数据, 而安全证明的形式化要求没有敌手能以高概率在这个“游戏”中获胜. 然而, MPC设定中的主要挑战是, 敌手确实获得了一些打算隐藏的数据, 即计算的输出. 此外, 另一个主要的复杂性在于安全多方计算是一个分布式应用, 涉及各方之间按照某种特定的模式通信. 敌手可以看到在协议执行过程中与腐化方交互的所有信息, 当敌手是主动的时候, 它甚至有能力修改腐化方的行为. 这些复杂的问题给广泛用于密码学的简单的基于游戏的安全证明定义的使用带来了障碍.</p>
<p>解决上述复杂问题的关键是考虑一个理想世界(Ideal world), 它能捕捉到所需的交互属性, 并以某种方式要求实际协议执行的现实世界(Real world)与理想世界不可区分. 通常情况下, 理想世界包含各方将他们的输入发送给可信第三方, 后者计算函数并返回结果, 而且仅返回结果给各方. 现在, 为了说明这两个世界是不可区分的, 一个自然的做法是说明敌手不能区分现实世界和理想世界. 然而, 这种方式是注定会失败的, 因为从敌手的视角来看, 这两个世界可以很平凡地区分开来: 在现实世界中, 信息在所有参与方中相互传递, 有多个通信轮次, 且没有可信方, 而在理想世界中, 有一个可信第三方, 只是接收输入和发送输出. 这两个世界看起来完全不同, 所以敌手可以轻松区分这两个世界.</p>
<p>这就是模拟的概念的作用. 在现实世界中, 敌手腐化了某些参与方集合的子集, 与诚实方交互, 并在执行结束时得到一个结果. 在理想世界中, 敌手不会直接与可信方交互, 相反, 当诚实方与可信第三方交互时, 敌手与一些“虚拟”的诚实方交互, 这些虚拟诚实方与真实诚实方不同, 不能接触到对敌手隐藏的输入. 这些虚拟诚实方由一个模拟器(Simulator)协调, 该模拟器也控制着理想世界中的腐化方, 发送输入并接收来自可信方的输出. 如此一来, 模拟器就有效充当了一个接口, 是敌手能够与理想世界中的可信第三方进行交互, 同时拥有等同于现实世界中的交互.</p>
<p>为了证明一个给定的安全多方计算协议时安全的, 需要定义一个模拟器, 作为上述的接口, 其证明安全的方式是说明现实世界(敌手与持有真实输入的真实诚实方交互的世界)与理想世界(敌手与模拟器控制的虚拟诚实方交互的世界)是不可区分的. 需要注意的是, 为了“愚弄”敌手, 模拟器所依靠的唯一能力是对接收输入并只显示输出的可信第三方的访问. 因此, 从直觉上来说, 这意味着敌手在现实世界中的经验可以通过只接触可信第三方来“重现”(recreated), 从哲学的角度来看, 这体现了敌手与现实世界中的诚实方交互之后, 只学习计算的输出这一核心思想.</p>
<p>有了上面概述的直观方法, 我们现在开始提供基于模拟的安全证明如何工作的细节, 主要基于文献<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup>. 在本文中, 我们仅关注UC框架, 不考虑其他基于模拟的安全证明概念.</p>
<h2><a id="%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%BB%A3%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>交互式代理</h2>
<p>我们首先考虑参与安全多方计算协议形式化的所有不同实体机器安全性. 我们的出发点是交互式代理(Interactive agent)的概念, 在直观层面上, 它是一个接收和发送消息、持有内部状态并进行计算的计算设备. 例如, 安全多方计算协议中的各方都是交互式代理, 但在这些想法被形式化的框架中, 还有其他几个交互式代理出现. 交互式代理可以通过交互式图灵机的方式被形式化. 这只是传统的图灵机(或算法), 除了进行计算外, 还可以向某些通信端口发送和接收数据, 这些端口可被看成是计算机总线或信道.</p>
<p>现在我们描述出现在UC框架中的不同的交互式代理. 正如我们已经提到的, 第一个自然的交互代理是各个参与方, 它们是进行计算的实际设备, 但还有其他几个交互代理, 例如模拟器或“可信第三方”出现. 我们下面分别进行讨论.</p>
<ul>
<li>参与方(Parties)</li>
</ul>
<p>参与方\(P_1,P_2,\cdots,P_n\)构成了交互代理的第一个自然例子. 每个参与方\(P_i\)有一定的计算输入, 根据协议的指示进行, 执行本地计算, 并根据需要向其他各方发送/接收数据. 在执行结束时, 每一方\(P_i\)都会得到计算的结果.</p>
<ul>
<li>现实世界中的功能性(Functionalities in the real world)</li>
</ul>
<p>一个功能只是一个连接到参与方的交互代理. 它从那里接收信息, 执行本地计算, 维护内部状态, 并将消息发回给各方.</p>
<p>尽管只有一种“类型”的功能, 但这些功能被用于两种不同的背景. 第一种情况是协议的实际执行发生在现实世界中, 在一个安全多方计算协议的执行中, 各个参与方可以使用某些“外部”资源, 这些资源可以在计算中帮助他们. 举例来说, 各方可以依靠可信第三方, 尽管它可能不会为各方计算整个所需的函数, 但可以提供某些帮助, 如分发一些密钥, 或者发送某些证书. 这可以被形式化为各方在执行当前协议期间的对话功能. 此外, 至关重要的是如果以后开发出另一个模拟该功能行为的协议, 那么各方可以把这个结构作为一个子程序, 整个结构仍然是安全的, 而不需要可信第三方来提供上述例子中的密钥或证书服务.</p>
<p>此外, 到目前为止, 我们一直隐含地假设各方通过在两两之间通过设定特殊的端口进行相互通信. 然而, 既然我们已经引入了功能的概念, 就可以方便地将通信视为一种功能, 它从各方接收信息并向各方发送信息. 例如, 一个简单的点对点网络可被建模为一个功能, 其作用是: \(P_i\)发送一个类型为&quot;发送信息\(m\)给\(P_j\)&quot;的信息, 而该功能发送给\(P_j\)的信息为: “\(P_i\)发送信息\(m\)”. 虽然这种方法看起来是一种不必要的复杂化, 但它实际上发挥了重要的作用, 使各方之间的对话方式具有灵活性. 此外, 功能的一个重要的低层次细节是它们会向环境泄漏某些信息, 这可以用来模拟这样的一个事实: 在实际中, 敌手可能会看到某些元数据, 例如诚实方何时向另一个诚实方发送信息, 信息的大小等.</p>
<ul>
<li>理想世界中的功能性(Functionalities in the ideal world)</li>
</ul>
<p>使用功能的第二种情况是在理想世界中, 有一个可信第三方接收来自不同参与方的输入并返回计算的结果. 这正是一个功能, 正如上面所定义的, 它是一个交互式代理, 接收来自各方的输入, 执行某些内部计算并将结果发送给各方.</p>
<p>在简单的情况下, 一个功能接收一个给定函数的输入, 在内部评估这个函数, 并将结果返回给各方. 然而, 功能的概念允许我们对更复杂的交互进行建模. 例如, 在非反应式计算(non-reactive computation)中, 它使各方能够获得部分结果并在之后继续进行计算. 这可以由一个功能来捕获, 这个功能接收各方的输入, 存储一些内部状态, 发送部分结果, 并按照各方的指示继续进行.</p>
<ul>
<li>敌手(Adversary)</li>
</ul>
<p>我们用\(\mathcal A\)来表示敌手, 它被建模为另一个交互代理, 它有与每个腐化方通信的端口. 如果腐化是被动的, 这些端口被用来通知敌手关于腐化方的内部状态, 包括它们收到的信息. 另一方面, 如果腐化是主动的, 这些端口则被用来“完全控制”各腐化方.</p>
<ul>
<li>环境(Environment)</li>
</ul>
<p>这个实体在基于模拟的安全概念中起着至关重要的作用. 直观地说, 环境负责区分现实世界和理想世界. 正如前面提到的, 敌手不能区分理想世界和现实世界是不够的. 其主要原因是, 如果我们简单地要求敌手不能区分两个世界, 那么即使来自诚实方的输入受到保护, 也可能出现诚实方没有收到计算的正确输出的情况, 这也是一个重要的问题. 这是有可能发生的, 因为为了“愚弄”敌手, 模拟器只需要向敌手创造一个看起来类似的交互, 但它可能是现实世界中的诚实方最终计算出与现实世界中完全不同的结果, 而在理想世界中它们获得了正确的结果. 由于敌手看不到这些只属于诚实方的输出, 所以这两个世界仍将不可区分.</p>
<p>为了解决这个问题, 不可区分是通过考虑计算的输入和输出来定义的. 这是通过考虑另一个代理—环境, 通常用\(\mathcal Z\)表示, 它指示各方使用哪些输入, 并从每一方收到它们在所考虑的世界中获得的结果(在理想世界中对应于计算的正确结果, 而在现实世界中是各方在执行给定协议时计算的结果)来正式确定的. 在这种新的考虑下, 如果没有环境可以区分现实世界和理想世界, 那么就可以说一个协议是安全的. 需要注意的是, 这尤其意味着敌手不能区分这两个世界, 因为否则敌手可以告知环境当前正在执行哪个世界, 但是即使这两个执行对敌手来说是不可区分的, 环境仍然可以利用它提供给计算的输入和收到的输出来试图进行区分. 如果即使如此之后, 两个执行仍然无法区分, 则是因为不仅分布对敌手来说是相似的, 而且现实世界中的输出也遵循与理想世界中的输入相同的分布, 这恰恰对应于计算的正确结果.</p>
<p>在UC模型中, 环境和敌手本质上是“一体”的, 其模型是: 这两个代理有一个共享的端口, 使环境能够完全控制敌手, 这与敌手在主动腐化情况下能够完全控制诚实方的方式基本相同. 鉴于这两个实体, 也包括腐化方, 在本文中, 我们将环境、敌手和腐化方合并, 不明确地使用环境/敌手这个术语来指代所产生的交互代理. 这个实体负责: (1) 扮演腐化方的角色; (2) 向诚实参与方发送输入并接收来自诚实方的输出.</p>
<ul>
<li>模拟器(Simulator)</li>
</ul>
<p>正如前面所说的, 模拟器负责充当理想世界中敌手和所需功能之间的“接口”. 这是通过一个交互式代理来实现的, 它通过与现实世界中的腐化方相同的端口连接到理想世界中的敌手/环境, 同时也“代表”腐化方连接到考虑中的功能. 这样一来, 模拟器就可以向功能发送输入并接收输出, 这就构成了模拟器的主要工具, 以创造一个与现实世界的环境不可区分的场景.</p>
<h2><a id="%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>交互式系统</h2>
<p>一个交互式系统(Interactive Systems)是交互式代理的集合. 例如, 各参与方的集合就是一个交互式系统, 我们将其称为协议. 首先回顾一些重要概念.</p>
<ul>
<li>开放/封闭端口(Open/closed ports)</li>
</ul>
<p>通信端口是一个“信道”, 不同的交互式代理可以访问, 以便发送和接收信息. 例如, 每方都有与协议执行中使用的功能共享的端口, 这使得它们能够向/从它发送和接收信息. 一个交互式系统作为一个交互式代理的集合, 包含几个端口, 其中许多将涉及至少两个交互式代理, 如每一方和一个功能之间使用的端口. 然而, 在一个交互式系统中, 有些端口可能只涉及一个交互式代理, 例如, 环境向诚实方发送输入并接收输出, 另外他可以向腐化方发送指令并接收信息, 这意味着各方有与环境通信的端口. 鉴于此, 在像协议这样不包含环境的交互式系统中, 这些端口只涉及一个交互代理(换而言之, 这些端口是“开放的”). 协议中的其他开放端口是各方用来与不同的功能进行通信的端口.</p>
<p>至少涉及两个交互式代理的端口被称为封闭端口(closed ports), 而只涉及一个交互式代理的端口被称为开放端口(open ports).</p>
<ul>
<li>开放式/封闭式交互系统(Open/closed interactive systems)</li>
</ul>
<p>一个具有开放端口的交互式系统被称为开放式交互系统, 而一个只有封闭端口的交互系统被称为封闭式交互系统. 例如, 一个协议是一个开放式交互系统, 鉴于它有对应于环境和各方之间的交互以及参与方和现实世界中使用的不同功能之间的开放端口.</p>
<p>开放式交互系统原则上不能运行, 因为它们可能缺失了某些应写入开放端口的数据. 例如, 一个协议不能被运行, 因为它至少缺失了参与方可以用来通信的功能, 而且它也缺失了(由环境)提供给开放端口的所要使用的输入(另外, 环境也负责安排协议本身的执行). 另一方面, 如果我们考虑一个更大的交互式系统, 有协议(各参与方的集合)、要使用的不同功能和环境组成, 则我们可以得到一个封闭的交互式系统. 这个系统可以被运行, 因为环境现在可以向参与方提供输入, 执行协议, 并获得结果(事实上, 可以多次这样做).</p>
<ul>
<li>交互式系统的组成(Composition of interactive systems)</li>
</ul>
<p>给定两个交互式系统\(\mathcal I_1\)和\(\mathcal I_2\), 通过考虑参与这两个集合的所有交互代理的集合, 或者说\(\mathcal I_1\)和\(\mathcal I_2\)的集合的联合, 就有可能从这两个系统中得到一个更大的系统, 这表示为\(\mathcal I=\mathcal I_1\diamondsuit\mathcal I_2\). 例如, 我们上面考虑的由\(\mathcal Z\diamondsuit \Pi\diamondsuit (\mathcal F_1\diamondsuit \cdots\diamondsuit \mathcal F_\ell)\)给定的封闭式系统, 其中\(\Pi\)表示所考虑的协议, \(\mathcal F_1,\cdots,\mathcal F_\ell\)表示协议执行中使用的各种功能.</p>
<h3><a id="uc%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UC框架中的交互式系统</h3>
<p>我们已经讨论了一个重要的交互式系统, 即协议, 它只是参与方的集合. 现在我们考虑UC框架中的两个主要交互系统: 现实世界和理想世界. 回顾一下, 给定协议的实际执行发生在现实世界中, 而各方利用可信第三方以功能为模型安全地计算函数发生在理想世界中. 这些想法很容易通过交互式系统的概念形式化.</p>
<ul>
<li>
<p>现实世界(Real world): 直观地说, 现实世界是安全多方计算协议实际执行的地方. 我们通过下面的交互式系统来正式说明这一点. 令\(\Pi=\{P_1,\cdots,P_n\}\)是协议, \(\mathcal F_1,\cdots,\mathcal F_\ell\)表示协议执行时使用的各种功能. 现实世界是被定义为由\(\mathrm{Real}:=\Pi\diamondsuit (\mathcal F_1\diamondsuit \cdots\diamondsuit \mathcal F_\ell)\)给出的交互式系统. 注意, 这是一个开放式系统, 因为它需要环境提供输入并安排协议的执行.</p>
</li>
<li>
<p>理想世界(Ideal world): 在高层次上, 我们认为理想世界是各方将他们的输入发送到一个可信第三方, 然后接收输出. 这必须被细化为包含一个模拟器\(\mathcal S\), 作为敌手/环境和可信第三方之间的接口.</p>
<p>令\(\mathcal F\)是模拟要安全进行的预期计算的功能(即可信第三方), \(\mathcal S\)是一个模拟器. 理想世界被定义为有\(\mathrm{Ideal}:=\mathcal S\diamondsuit\mathcal F\)给出的交互式系统. 这也是一个开放的系统, 事实上它具有与交互式系统\(\mathrm{Real}\)相同的开放端口: 模拟器包含开放的端口供环境连接, 就像它与现实世界中的腐化方连接一样, 而功能\(\mathcal F\)具有开放的端口供环境向诚实方提供输入和接收输出.</p>
</li>
</ul>
<p>特别地, 交互式系统\(\mathcal Z\diamondsuit \mathrm{Real}\)和\(\mathcal Z\diamondsuit \mathrm{Ideal}\)都是封闭的.</p>
<h3><a id="%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数化的交互式系统</h3>
<p>一些交互式代理(进而, 交互式系统)可以包含几个可调整的外部参数. 例如, 一个协议通常允许在不同的代数结构上进行计算(例如, 大小不同的域), 或者一个功能可以根据它所接收的信息长度来进行参数化, 这只是一些例子. 这些都是外部参数, 意味着它们必须在考虑执行这些交互式代理之前被设定. 为了说明问题, 它们可以被认为是类似于编译程序语言中的编译时参数.</p>
<p>一个非常重要的外部参数是安全参数(Security parameter). 直观地说, 它是一个自然数, 随着它的增大, 协议变得“更安全”. 在所考虑的各种相互作用的代理所拥有的所有不同的外部参数中, 我们明确提出的是安全参数, 表示为\(\kappa\). 为了明确这一点, 我们有时可以写成\(\mathcal I(\kappa)\), 其中\(\mathcal I\)是以\(\kappa\)为参数的交互式系统/代理.</p>
<h2><a id="%E5%AE%89%E5%85%A8%E6%80%A7%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安全性定义</h2>
<p>在定义了我们框架中所涉及的不同的交互式代理之后, 我们现在把注意力转移到定义安全性上. 正如我们已经提到的, 这将通过要求没有环境可以区分现实和理想的执行来实现. 在本节中, 我们将更详细地定义“不可区分性”.</p>
<p>在安全多方计算协议的安全性定义中经常可看到三种安全性来刻画隐私保证: 完美安全性(Perfect security)、统计安全性(Statistical security)和计算安全性(Computational security). 它们都用于描述现实世界中的协议执行逼近于理想世界中的可信第三方的程度, 是对敌手能力的约束.</p>
<ul>
<li>
<p><strong>完美安全性</strong>: 在这种情况下, 现实和理想执行具有完全相同的分布. 因此, 从敌手的角度来看, 无法从协议执行中获得任何关于诚实参与方的输入. 这与敌手所拥有的计算资源无关, 即协议能抵抗无限计算能力的敌手.</p>
</li>
<li>
<p><strong>统计安全性</strong>: 这是一个稍弱的概念, 也被称为无条件安全. 在这里, 现实世界和理想世界的分布在统计学意义上是接近的, 即现实世界和理想世界的分布可能不同, 但非常接近. 更确切地说, 通过控制给定结构的某些参数, 有可能将这两个分布之间的差距减小到任意程度.</p>
</li>
<li>
<p><strong>计算安全性</strong>: 在实际应用中, 通常将安全性限制在只针对有效的敌手, 即计算资源有限的敌手. 这里的有效敌手指以多项式时间运行的算法. 在一个计算安全的协议中, 来自真实世界和理想世界的分布是不可区分的. 只要敌手计算能力不是无限的, 就足以满足实际应用.</p>
</li>
</ul>
<p>完美安全性和统计安全性统称为信息论安全性(Information-theoretic security). 满足信息论安全的协议比计算安全的协议更高效, 因为它们通常更简单, 而且不依赖于某些特定的计算困难问题的参数. 但是, 信息论安全性并非总是可以实现的.</p>
<p>为了正式定义以上安全性, 我们首先提出可忽略函数的定义.</p>
<p><strong>定义1</strong>(可忽略函数, Negligible functions): 一个函数\(\mu:\mathbb N\mapsto[0,\infty)\)是可忽略的, 如果对所有\(c\in\mathbb N\), 存在\(\kappa_c\in\mathbb N\), 使得对所有\(\kappa\geq\kappa_c\), 都有\(\mu(\kappa)\leq\kappa^{-c}\). 或者说, \(\mu\)是可忽略的, 如果对所有多项式\(p(X)\), 存在\(\kappa_{p(X)}\in\mathbb N\), 使得对所有\(\kappa\geq\kappa_{p(X)}\), 都有\(\mu(\kappa)\leq p(\kappa)\).</p>
<p>可忽略函数的一个例子是\(\mu(\kappa)=2^{-\kappa}\). 直观地说, 一个可忽略函数是其逆函数渐进增长速度比任何可能的多项式都快. 这些函数在整个密码学中被广泛用于表示非常小的量.</p>
<p>我们需要注意的第二个问题是, 我们包含了环境的额外语义概念. 这个交互式代理负责区分现实和理想执行, 它通过与这些世界中的任何一个进行交互并输出一个比特\(0\)或者\(1\), 代表环境认为它在与哪个世界进行交互. 正如我们将看到的, 这些比特和两个世界之间的分配是不相关的. 每当环境\(\mathcal Z\)与一个交互式系统\(\mathcal I\)进行交互, 并输出\(b\)时, 我们用\(b\leftarrow\mathcal Z\diamondsuit \mathcal I\)来表示. 请注意, 这是一个随机变量, 因为\(\mathcal Z\)所进行的整个计算是潜在随机的.</p>
<p>下面我们考虑协议\(\Pi\)被用于安全地计算一个功能\(\mathcal F\), 同时利用功能\(\mathcal F_1,\cdots,\mathcal F_\ell\). 以下的所有概念都是针对一个给定的敌手结构而设定的, 敌手结构决定了可能被腐化的集合.</p>
<h3><a id="%E5%AE%8C%E7%BE%8E%E5%AE%89%E5%85%A8%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>完美安全性</h3>
<p>首先, 我们定义完美安全的概念, 它反映了一个协议即使在无限计算资源的环境/敌手的情况下仍然不会被攻破.</p>
<p><strong>定义2</strong>(完美安全性, Perfect Security) 我们称协议\(\Pi\)在具有完美安全性的\((\mathcal F_1,\cdots,\mathcal F_\ell)\)-混合模型中安全地实例化了功能\(\mathcal F\), 如果存在一个模拟器\(\mathcal S\)使得对任意环境\(\mathcal Z\)和对所有\(\kappa\in\mathbb N\), 都有</p>
\[\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Real})(\kappa)]=\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Ideal})(\kappa)],
\]
<p>其中, \(\mathrm{Real}=\Pi\diamondsuit \mathcal F_1\diamondsuit \cdots\diamondsuit \mathcal F_\ell\), \(\mathrm{Ideal}=\mathcal S\diamondsuit \mathcal F\).</p>
<p>让我们详细分析一下上述定义, 首先, 完美安全的协议通常不依赖参数\(\kappa\), 所以我们可以把它从定义中删除(为了在下面的描述其他安全概念方面保持符号的某些“统一性”, 它被包括在内). 上面的安全定义指出, 必须存在一个模拟器\(\mathcal S\), 使\(\mathcal Z\)在与系统\(\mathrm{Real}\)交互时输出\(1\), 其概率与\(\mathcal Z\)在与系统\(\mathrm{Ideal}\)交互时输出\(1\)的概率完全相同. 这恰恰意味着\(\mathcal Z\)不能区分这两个世界, 因为如果它可以, 则它可选择只在现实世界输出\(1\), 而在理想世界输出\(0\), 如此\(\mathrm{Pr}[1\leftarrow\mathcal Z\diamondsuit \mathrm{Real}]=1\), 且\(\mathrm{Pr}[1\leftarrow\mathcal Z\diamondsuit \mathrm{Ideal}]=0\).</p>
<p>需要注意的是这里输出\(1\)没有什么特殊之处, 同样的定义也适用于输出\(0\), 因为\(\mathrm{Pr}[0\leftarrow\mathcal Z\diamondsuit \mathrm{Real}]=1-\mathrm{Pr}[1\leftarrow\mathcal Z\diamondsuit \mathrm{Real}]\), \(\mathrm{Pr}[0\leftarrow\mathcal Z\diamondsuit \mathrm{Ideal}]=1-\mathrm{Pr}[1\leftarrow\mathcal Z\diamondsuit \mathrm{Ideal}]\). 下面介绍的其他安全概念亦是如此.</p>
<p>通常定义\(\mathcal Z\)的统计优势(Statistical advantage)为$|\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Real})(\kappa)]-\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Ideal})(\kappa)]|$. 它本质上是衡量\(\mathcal Z\)在现实世界和理想世界之间的区分程度. 容易看出, 在完美安全设定下, 任何环境的优势都是0.</p>
<h3><a id="%E7%BB%9F%E8%AE%A1%E5%AE%89%E5%85%A8%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>统计安全性</h3>
<p>现在我们考虑一个更灵活的定义—统计安全性, 它允许细微的区分优势. 在这里, 我们必须稍微限制一下定义2中的环境, 它没有任何限制. 在这种情况下, 我们必须假设, 尽管\(\mathcal Z\)在计算上可能具有无限资源, 但它只会对\(\mathrm{Real}\)或者\(\mathrm{Ideal}\)进行多项式次数的“调用”. 否则, 统计安全性无法实现, 因为通过与两个世界中的一个世界进行超多项式次数的交互, 可以任意提高区分两个世界的概率.</p>
<p><strong>定义3</strong>(统计安全性, Statistical Security) 我们称协议\(\Pi\)在具有统计安全性的\((\mathcal F_1,\cdots,\mathcal F_\ell)\)-混合模型中安全地实例化了功能\(\mathcal F\), 如果存在一个可忽略的函数\(\mu(\kappa)\), 使得对任意环境\(\mathcal Z\), 有</p>
\[|\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Real})(\kappa)]-\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Ideal})(\kappa)]|\leq \mu(\kappa),
\]
<p>其中, \(\mathrm{Real}=\Pi\diamondsuit \mathcal F_1\diamondsuit \cdots\diamondsuit \mathcal F_\ell\), \(\mathrm{Ideal}=\mathcal S\diamondsuit \mathcal F\).</p>
<p>在这种情况下, \(\mathcal Z\)可能能够“稍微”区分这两个世界, 这反映在\(\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Real})(\kappa)]\)和\(\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Ideal})(\kappa)]\)可能不想等的情况下. 事实上, 可能的情况是, 对于\(\kappa\)的某些值, 环境可能会很好地区分这两个世界(例如, 对于\(\kappa\)的某些值可能发生\(\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Real})(\kappa)]=1\), \(\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Ideal})(\kappa)]=0\)). 然而, 统计安全性要求随着\(\kappa\)的增长, 这种区分优势以一个良好的速度缩小. 例如, 若\(\mu(\kappa)=2^{-\kappa}\), 则选择\(\kappa=1\)是不合适的, 因为这意味着环境区分两个世界的优势有\(1/2\), 但如果\(\kappa=40\), 则优势就减少到了\(2^{-40}\), 这更能被接受. 事实上, 在设计统计安全的协议时, \(2^{-40}\)是一个非常常见的目标值.</p>
<h3><a id="%E8%AE%A1%E7%AE%97%E5%AE%89%E5%85%A8%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算安全性</h3>
<p>最后, 我们考虑关于安全多方计算协议的“最弱”的安全概念. 在这种情况下, 环境有一个细微的区分优势, 但这只在环境是计算能力有限的情况下才成立, 也就是说, 它在多项式时间内运行. 就实际意义而言, 鉴于在实际的MPC部署中, 所有参与方都将使用有限的计算资源, 这个概念已经足够好了. 此外, 一些安全多方计算场景不允许使用前面的任何概念, 而需要计算安全.</p>
<p><strong>定义4</strong>(计算安全性, Computational Security) 我们称协议\(\Pi\)在具有计算安全性的\((\mathcal F_1,\cdots,\mathcal F_\ell)\)-混合模型中安全地实例化了功能\(\mathcal F\), 如果对任意有效的环境\(\mathcal Z\), 都存在一个可忽略函数\(\mu_\mathcal Z(\kappa)\), 使得</p>
\[|\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Real})(\kappa)]-\mathrm{Pr}[1\leftarrow(\mathcal Z\diamondsuit \mathrm{Ideal})(\kappa)]|\leq\mu_\mathcal Z(\kappa),
\]
<p>其中, \(\mathrm{Real}=\Pi\diamondsuit \mathcal F_1\diamondsuit \cdots\diamondsuit \mathcal F_\ell\), \(\mathrm{Ideal}=\mathcal S\diamondsuit \mathcal F\).</p>
<p>计算安全性定义中的有效环境从高层次上来说是相对于它的参数以多项式时间运行. 一般而言, 给定的环境, 任何交互式代理与其他代理交换信息, 可以对这些代理进行“调用”. 更多细节可参考文献[2].</p>
<p>计算安全与统计安全不同的是在试图区分现实世界和理想世界时, 并没有固定一个可忽略函数\(\mu(\kappa)\)来限定每个可能的环境\(\mathcal Z\)的优势. 这在一般情况下是不可能实现的, 因为可能有一系列的环境\(\mathcal Z_1,\mathcal Z_2,\cdots\), 每个\(\mathcal Z_c\)的运行时间为多项式的\(\kappa^c\), 所以对于一个固定的\(\kappa_0\), 这些环境的运行时间\(\kappa_0^1,\kappa_0^2,\cdots\)是无界的. 因此, 只要有足够的运行时间, 就有可能打破对\(\mu(\kappa_0)\)的优势的固定约束.</p>
<p>因此, 最好的希望是对于每个单一的环境\(\mathcal Z\), 其区分优势是以一个与该环境有关的可忽略的函数\(\mu_\mathcal Z(\kappa)\)为上界. 可以这样理解, 考虑对协议的最有效的已知攻击, 从中推导出一个环境\(\mathcal Z\), 确定相关的可忽略函数\(\mu_\mathcal Z(\kappa)\), 并选择\(\kappa\)使这个环境的优势低于某些特定的阈值(例如\(2^{-80}\)). 鉴于我们以上的观察, 可能会出现这样的情况, 即选择的\(\kappa\)不足以确保其他环境的低区分优势, 但至少它排除了目前已知的最佳环境.</p>
<p>在本文中, 即使我们考虑到只有计算安全可以实现的环境, 我们在实际的安全证明中只处理完美安全和统计安全. 这是因为, 对于不允许这种类型安全的环境, 我们考虑了一个离线/在线范式(offline-online paradigm), 在某些功能的帮助下, 可使计算具有完美安全和统计安全.</p>
<h2><a id="%E7%BB%84%E5%90%88%E5%AE%9A%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>组合定理</h2>
<p>考虑一个协议\(\Pi_\mathcal F\)在一些其他功能\(\mathcal R\)的帮助下(即在\(\mathcal R\)-混合模型下)安全地实例化了功能\(\mathcal F\). 在现实世界中, \(\mathcal R\)充当了某种可信第三方, 各方可以在它的协助下完成安全计算\(\mathcal F\)的任务. 然而, 在实践中这个\(\mathcal R\)必须以某种方式实例化. 例如, 如果\(\mathcal R\)是代表点对点的加密和认证信道, 则必须执行类似于TLS这样的协议来建立这些信道. 从形式上看, 这意味着可能在某个\(\mathcal T\)-混合模型中使用了一个实例化\(\mathcal R\)的新协议\(\Pi_\mathcal R\), 一个自然的问题是: 新协议可以实现什么类型的正式安全保证? 对于“新协议”, 我们指的是协议\(\Pi_\mathcal F\), 但通过协议\(\Pi_\mathcal R\)的执行来取代与功能\(\mathcal F_\mathcal R\)的交互, 而协议\(\Pi_\mathcal R\)则将\(\mathcal F_\mathcal R\)的功能实例化.</p>
<p>UC框架(通用可组合框架, Universal-composability framework)的核心结果准确地说是产生的组合协议继承了所涉及的两个协议\(\Pi_\mathcal F\)和\(\Pi_\mathcal R\)的属性. 特别地, 这个协议仍然是\(\mathcal F\)的实例化, 但它不是在\(\mathcal R\)-混合模型中进行, 而是在\(\mathcal T\)-混合模型中进行, 这是协议\(\Pi_\mathcal R\)所需要的功能. 通常情况下, \(\mathcal T\)比\(\mathcal R\)要简单得多, 这意味着在安全实例化\(\mathcal F\)方面已经取得了进展.</p>
<p>在详细讨论组合定理之前, 我们先讨论上述结果的高层次描述的某些影响. 首先, 组合定理使得高度复杂的协议模块化描述成为可能, 它将协议分解成若干个片段, 然后分别证明每个片段的安全性. 例如, 在一个庞大而复杂的协议\(\Pi\)中, 可能会出现某些片段或模式在协议执行的几个地方重复出现的情况. 这一部分可以作为一个协议\(\Pi'\)独立出来, 实例化某些功能\(\mathcal R\), 而协议\(\Pi\)有可能以一种更简单的方式来表达这个功能. 现在为了证明安全性, 我们不需要提供大的“单体”协议\(\Pi\)的证明, 而是可以证明比它简单的在\(\mathcal R\)-混合模型中实例化了所需功能的变体, 然后我们可以只关注证明协议\(\Pi'\)确实实例化了\(\mathcal R\). 为了说明问题, 可以把上述方法看作是把编程语言中的复杂函数分割成对其他函数进行调用的更简单结构. 这种方法可以实现清晰和模块化的证明和协议描述, 可以说这是使安全多方计算领域的研究如此丰富和富有成效的关键因素之一.</p>
<p>组合定理在实践中非常有用, 通常安全多方计算协议被部署在大型复杂的分布式系统中, 这些系统可能同时运行许多其他协议以实现其他任务. 例如, 必须协商密钥, 必须对随机值进行采样, 必须提供输入等等. 组合定理确保了即使几个协议同时执行, 只要其中每个协议都能被证明是安全的, 那么所产生的新协议组也是安全的. 这是一个重要的观察结果, 相比于其他形式化的模型, 例如不接受这种灵活的并发组合的独立模型来说, UC框架更具有优势.</p>
<ul>
<li>组合协议</li>
</ul>
<p>为了正确地阐述组合定理, 清楚明确地定义所涉及的不同交互式代理和系统是非常重要的.</p>
<p>考虑协议\(\Pi_\mathcal F=\{P_1,\cdots,P_n\}\)在\(\mathcal R\)-混合模型中实例化了一个功能\(\mathcal F\), 并考虑另一个有不同参与方\(\{Q_1,\cdots,Q_n\}\)的协议\(\Pi_\mathcal R\)在\(\mathcal T\)-混合模型中实例化了功能\(\mathcal R\). 将协议\(\Pi_\mathcal F\)和\(\Pi_\mathcal R\)组合起来成为交互式系统, 用\(\Pi_\mathcal F\diamondsuit \Pi_\mathcal R\)来表示.</p>
<p>为了使这一概念更有意义, 回顾一下各方\(Q_1,\cdots,Q_n\)有与环境\(\mathcal Z\)通信的端口, 而\(P_1,\cdots,P_n\)有与功能\(\mathcal R\)通信的端口. 这些端口是相同的: 从\(P_i\)发给\(\mathcal R\)的信息被来自环境的\(Q_i\)接收, 反之亦然. 这样一来, 交互式系统\(\{P_i,Q_i\}\)就像是单个参与方, 与环境(通过\(P_i\)的端口)和功能\(\mathcal T\)(通过\(Q_i\)的端口)进行交互. 有了这个新的解释, 我们看到两个“兼容”的组成又是一个协议, 其中新参与方可能是交互式系统, 其行为就像是一个交互式代理. 更多细节参考文献[2]的第4.2.7节.</p>
<ul>
<li>组合定理</li>
</ul>
<p><strong>定理</strong>(Composition Theorem): 令\(\Pi_\mathcal F\)是在\(\mathcal R\)-混合模型中实例化功能\(\mathcal F\)的协议, 具有完美/统计/计算安全性, 设\(\Pi_\mathcal R\)是在\(\mathcal T\)-混合模型中实例化功能\(\mathcal R\)的协议, 具有相同的安全性类型, 则组合协议\(\Pi_\mathcal F\diamondsuit \Pi_\mathcal R\)以同样的安全性类型在\(\mathcal T\)-混合模型中安全地实例化功能\(\mathcal F\).</p>
<p>完整的定理证明参考文献[2].</p>
<h2><a id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考文献</h2>
<section class="footnotes">
<ol>
<li id="fn1">
<p>R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In Proceedings 42nd IEEE Symposium on Foundations of Computer Science, pages 136–145. IEEE, 2001. <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2">
<p>R. Cramer, I. Damgard, and J. B. Nielsen. Secure multiparty computation and secret sharing - an information theoretic approach, 2012. <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trident: Efficient 4PC Framework for Privacy Preserving Machine Learning]]></title>
    <link href="https://weiviming.github.io/16524092173945.html"/>
    <updated>2022-05-13T10:33:37+08:00</updated>
    <id>https://weiviming.github.io/16524092173945.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>今天给大家带来的是发表于NDSS'20上的文章Trident: Efficient 4PC Framework for Privacy Preserving Machine Learning, 原文链接: <a href="https://arxiv.org/pdf/1912.02631.pdf">https://arxiv.org/pdf/1912.02631.pdf</a></p>
</blockquote>
<h2><a id="abstract" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Abstract</h2>
<p>本文提出环上遵循离线-在线范式的具有主动安全的四方隐私保护机器学习框架Trident, 可抵抗一个恶意敌手, 同时还实现了公平性(Fairness). 与三方的ABY3相比, 本文通过在离线阶段引入一个额外诚实方, 并尽可能少地使用昂贵的电路来提升效率, 例如截断技术不影响乘法的在线开销, 离线阶段不需要任何电路, 而在线阶段则只涉及三方计算; B2A转化在通信轮次上有7倍改进, 通信复杂度有18倍改进. 本文所提出的混合计算协议支持秘密份额在Arithmetic、Boolean、Garbled World上进行高效转换, 而且具有恒定的轮复杂度, 适合安全外包计算场景. 最后本文与ABY3在64比特环上就LAN和WAN设定进行了实验对比, 发现训练阶段快187倍, 推理阶段快158倍.</p>
<h2><a id="introduction" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h2>
<p>目前的MLaaS对于不同的终端用户有两种工作模式: 一是公司提供训练好的模型, 用户通过查询得到预测结果; 二是多个客户/公司使用他们的数据联合训练共同模型, 但不希望明文分享他们的数据. 但两种模式都需要用户做出一定的妥协, 对于前者用户会泄漏了查询结果, 对于后者公司在未经客户同意的情况下相互共享数据可能违反数据安全保护的相关法律法规, 此外由于竞争的缘故, 公司也不愿意泄漏自己的数据. 由此展现了隐私保护机器学习(PPML)的重要性.</p>
<p>MPC虽然已经被证明是实用的, 但在诚实大多数假设下且参与方数量较少时MPC更为流行. 目前最好的三方PPML框架在半诚实安全下是高效的, 但在恶意安全下效率很低, 其主要原因是底层算子(如点积、比较、截断等)在恶意安全模型下通信开销更高, 例如ABY3的点积协议的通信量与向量长度线性相关, 由于这些算子需要多次执行, 尤其是在训练阶段, 因此为这些算子构造更高效的协议对构造高效PPML框架是至关重要的.</p>
<p>尽管MPC效率得到了提升, 但最好的MPC协议并不能直接应用于PPML, 主要原因如下:</p>
<ol>
<li>不同的MPC技术在算术、布尔、Yao世界中的效率各不相同, 单一世界可能更适合某些类型的计算, 因而在混合世界中执行协议比在单一世界中执行更高效.</li>
<li>非线性算子的计算问题. 当进行多次定点乘法后, 定点数精度会造成溢出, 为此需要进行定点截断, 在2PC下可以使用SecureML中的本地截断, 但在3PC/4PC下存在ABY3中所描述的攻击, 此外ABY3的方法依赖于开销较大的Ripple Carry Adder来构造协议, 因此需要探索更有效的定点截断技术. 此外, 激活函数的计算问题也是影响MPC效率的一大原因.</li>
</ol>
<p>总的来说, 本文的主要贡献如下:</p>
<ol>
<li>高效4PC协议: 提出了一个环上具有主动安全的高效四方计算协议, 遵循离线-在线范式, 在线阶段每次乘法计算仅通信3个环元素且不需要第四方参与计算. 此外, 还在不影响乘法门复杂度的前提下实现了公平性.</li>
<li>快速混合世界计算: 本文提出的Trident框架可在算术、布尔、Garbled World之间相互转换, 协议构造侧重于在线阶段的高吞吐量, 主要通过额外的诚实的第四方来达到, 与ABY3相比更高效.</li>
<li>高效截断: 本文提出的截断协议可与本文的乘法协议结合使用, 在线阶段无需额外开销, 且不需要像ABY3一样借助RCA来构造, 效率更高.</li>
<li>安全比较: 本文提出的安全比较协议具有常数轮复杂度.</li>
<li>机器学习模块: 本文提出的激活函数安全计算协议具有常数轮复杂度.</li>
<li>实验: 在LAN和WAN下与ABY3在线性回归、逻辑回归、神经网络、卷积神经网络的训练和预测等几个方面进行了性能测试, 结果如下:</li>
</ol>
<img src="media/16524092173945/16524092992460.png" alt="image-20220511172947213" style="zoom:50%;" />
<h2><a id="preliminaries-and-definitions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Preliminaries and Definitions</h2>
<p>符号约定: 四方集合\(\mathcal P=\{P_0,P_1,P_2,P_3\}\), 同步网络, 通过点对点安全信道连接. 抗碰撞哈希函数\(\mathsf H\).</p>
<p>为减少通信开销生成共同随机性, 参与方通过预共享密钥设置建立PRF使用的预共享随机密钥来生成相关随机性.</p>
<h2><a id="4pc-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4PC Protocol</h2>
<h3><a id="sharing-semantics" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sharing Semantics</h3>
<p>设秘密为\(v\), 计算域为布尔环\(\mathbb Z_2\)和算术环\(\mathbb Z_{2^\ell}\). 本文涉及三种不同的Sharing:</p>
<ul>
<li>\([\cdot]\)-sharing: \(P_1,P_2,P_3\)三方下的加法秘密共享(ASS), \(P_i\)的份额为\([v]_{P_i}=v_i\), 满足\(v=v_1+v_2+v_3\).</li>
<li>\(\langle\cdot\rangle\)-sharing: \(P_1,P_2,P_3\)三方下的复制秘密共享(RSS), \(P_1\)的份额为\(\langle v\rangle_{P_1}=(v_2,v_3)\), \(P_2\)的份额为\(\langle v\rangle_{P_2}=(v_3,v_1)\), \(P_3\)的份额为\(\langle v\rangle_{P_3}=(v_1,v_2)\), 满足\(v=v_1+v_2+v_3\).</li>
<li>\([[\cdot]]\)-sharing: \(P_0,P_1,P_2,P_3\)四方下的秘密共享, 存在\(\lambda_v,m_v\in\mathbb Z_{2^\ell}\), 使得\(m_v=v+\lambda_v\), 其中\(\lambda_v\)通过\(\langle\cdot\rangle\)-sharing共享, \(P_1,P_2,P_3\)则有明文形式的\(m_v\). 最终\(P_0\)的份额为\([[v]]_{P_0}=(\lambda_{v,1},\lambda_{v,2},\lambda_{v,3})\), \(P_1\)的份额为\([[v]]_{P_1}=(m_v,\lambda_{v,2},\lambda_{v,3})\), \(P_2\)的份额为\([[v]]_{P_2}=(m_v,\lambda_{v,3},\lambda_{v,1})\), \(P_3\)的份额为\([[v]]_{P_3}=(m_v,\lambda_{v,1},\lambda_{v,2})\). 记\([[v]]=(m_v,\langle \lambda_v\rangle)\)为\(v\)的\([[\cdot]]\)份额.</li>
</ul>
<p>不同秘密共享下各参与方份额总结如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center">类型</th>
<th style="text-align: center">\(P_0\)</th>
<th style="text-align: center">\(P_1\)</th>
<th style="text-align: center">\(P_2\)</th>
<th style="text-align: center">\(P_3\)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">\([\cdot]\)-sharing</td>
<td style="text-align: center">—</td>
<td style="text-align: center">\(v_1\)</td>
<td style="text-align: center">\(v_2\)</td>
<td style="text-align: center">\(v_3\)</td>
</tr>
<tr>
<td style="text-align: center">\(\langle\cdot\rangle\)-sharing</td>
<td style="text-align: center">—</td>
<td style="text-align: center">\((v_2,v_3)\)</td>
<td style="text-align: center">\((v_3,v_1)\)</td>
<td style="text-align: center">\((v_1,v_2)\)</td>
</tr>
<tr>
<td style="text-align: center">\([[\cdot]]\)-sharing</td>
<td style="text-align: center">\((\lambda_{v,1},\lambda_{v,2},\lambda_{{v,3}})\)</td>
<td style="text-align: center">\((m_v,\lambda_{v,2},\lambda_{v,3})\)</td>
<td style="text-align: center">\((m_v,\lambda_{v,3},\lambda_{v,1})\)</td>
<td style="text-align: center">\((m_v,\lambda_{v,1},\lambda_{v,2})\)</td>
</tr>
</tbody>
</table>
<p>以上秘密共享方案都满足线性性, 因此计算线性算子不需要交互.</p>
<h3><a id="building-blocks" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building Blocks</h3>
<ul>
<li>秘密分发协议\(\Pi_\mathsf{Sh}(P_i,v)\): 允许\(P_i\)分发他拥有的秘密\(v\), 使得参与方得到\([[v]]\). 离线阶段不需要通信, 在线阶段需要1轮, \(3\ell\)比特均摊通信量. 具体协议过程如下:</li>
</ul>
<img src="media/16524092173945/16524092992486.png" alt="image-20220331170244609" style="zoom:50%;" />
<ul>
<li>秘密分发协议\(\Pi_\mathsf{aSh}(P_0,v)\): 特别地, \(P_0\)可在离线阶段分发他的秘密\(v\), 生成\(\langle v\rangle\). 需要1轮通信, \(2\ell\)比特均摊通信量. 具体协议过程如下:</li>
</ul>
<img src="media/16524092173945/16524092992517.png" alt="image-20220331170943882" style="zoom:50%;" />
<ul>
<li>秘密重构协议\(\Pi_\mathsf{Rec}(\mathcal P,[[v]])\): 给定\([[v]]\), \(\mathcal P\)中的参与方重构\(v\). 每个参与方从另一方接收所缺失的份额并从第三方接收该缺失份额的哈希值以验证一致性. 在线阶段需要1轮, \(4\ell\)比特均摊通信量. 具体协议过程如下:</li>
</ul>
<img src="media/16524092173945/16524092992546.png" alt="image-20220331171802084" style="zoom:50%;" />
<h3><a id="states-of-4pc-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>States of 4PC Protocol</h3>
<p>4PC协议可分为输入共享(Input Sharing)、求值(Evaluation)、输出重构(Output Reconstruction)三个阶段. 输入共享阶段主要是通过秘密分发协议\(\Pi_\mathsf{Sh}\)来执行, 输出重构阶段主要是通过秘密重构协议\(\Pi_\mathsf{Rec}\)来执行, 下面主要介绍求值阶段, 因为加法门可以本地计算, 因此这里仅介绍计算乘法门的协议\(\Pi_\mathsf{Mult}\), 即给定\([[x]], [[y]]\), 安全计算\([[z]]\), 其中\(z=xy\).</p>
<p>离线阶段的主要任务是让\(P_1,P_2,P_3\)生成\(\gamma_{xy}=\lambda_x\lambda_y\)的RSS份额\(\langle \gamma_{xy}\rangle\). 首先\(P_1,P_2,P_3\)本地计算\([\gamma_{xy}]\), 然后通过resharing交换份额得到\(\langle \gamma_{xy}\rangle\). 在交换\(\gamma_{xy}\)的份额之前, 为防止泄漏, 参与方需要在份额上加入Zero sharing的份额. 此外, \(P_0\)辅助其他参与方验证收到的份额的正确性. 在线阶段的目标是计算\(m_z\), 因为</p>
\[\begin{aligned}
  m_z&amp;=z+\lambda_z=xy+\lambda_z=(m_x-\lambda_x)(m_y-\lambda_y)+\lambda_z\\
  &amp;=m_xm_y-\lambda_xm_y-\lambda_ym_x+\lambda_x\lambda_y+\lambda_z,
\end{aligned}
\]
<p>\(P_1,P_2,P_3\)可以本地计算\(m_z'=m_z-m_xm_y\)的\([\cdot]\)份额, 然后交换份额重构\(m_z'\). 由于\([\cdot]\)-sharing的特性, 每个缺失的份额都可被两方计算, 因此各参与方通过让一方发送缺失的份额, 另一方发送与之对应的哈希值, 以可验证的方式重构出\(m_z\). 一个关键的优化点是, 每个乘法门交换哈希值可以推迟到输出重构阶段合并进行, 所有相对应的值并在一起再计算哈希值, 从而可将整体通信量减少为3个环元素. 完整的乘法计算协议如下, 离线阶段需要1轮, \(3\ell\)比特均摊通信量, 在线阶段需要1轮, \(3\ell\)比特均摊通信量.</p>
<img src="media/16524092173945/16524092992585.png" alt="image-20220331200635965" style="zoom:50%;" />
<h3><a id="achieving-fairness" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Achieving Fairness</h3>
<p>公平性要求所有参与方要么都得到输出, 要么都中止协议. 因此实现公平性需要确保所有参与方在输出重构阶段都是alive的, 同时还需要阻止敌手发起选择中止攻击(selective abort attack), 即敌手让某些诚实参与方中止协议. 若乘法门验证通过, \(P_1,P_2,P_3\)设定比特\(b=\mathtt{continue}\), 否则设定\(b=\mathtt{abort}\), 然后发送\(b\)给\(P_0\). 若\(P_0\)发现某个参与方发送了abort, 则向所有参与方发送abort, 从而确保所有参与方aliveness. 剩余的参与方然后交换他们来自\(P_0\)的回复(continue/abort), 根据其中的多数来决定继续还是中止. 因为仅有一个恶意方, 因此所有参与方将在同一状态下, 从而防止敌手发起选择中止攻击. 若参与方决定继续, 则他们交换缺失的份额. 基于至多只有一个恶意方的事实和秘密共享方案的构造, 收到次数最多的缺失份额将在诚实参与方中保持一致性. 完整的公平重构协议如下, 在线阶段需要4轮, \(8\ell\)比特均摊通信量.</p>
<img src="media/16524092173945/16524092992630.png" alt="Trident5" style="zoom:50%;" />
<h2><a id="mixed-protocol-framework" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mixed Protocol Framework</h2>
<p>混合协议框架主要考虑三个世界: Arithmetic world (A)、Boolean world (B)、Garbled world (G).</p>
<h3><a id="the-garbled-world" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Garbled World</h3>
<p>对于混淆世界, 将3PC的MRZ协议(CCS'15)扩展到4PC. 在4PC下, \(P_1,P_2,P_3\)作为混淆方, \(P_0\)作为求值方. 作为优化, \(P_0\)可以只分享他的输入给\(P_1,P_2\), 而不是所有方. 对于交叉检验, \(P_1\)发送混淆电路给\(P_0\), 同时\(P_2\)发送与之相对应的哈希值给\(P_0\). 同时方案整合了Free-XOR、half-gate、fixed-key AES garbling技术. 本文提供了单比特的协议, 可以通过并行\(\ell\)次来支持\(\ell\)比特的值.</p>
<ul>
<li>
<p>秘密共享语义: 对于比特\(v\), \([[v]]^\mathbf G\)被定义为\([[v]]_{P_i}^\mathbf G=K_v^0\in\{0,1\}^\kappa\), \(i\in\{1,2,3\}\), 和\([[v]]_{P_0}^\mathbf G=K_v^v=K_v^0\oplus vR\), 其中\(\kappa\)是计算安全参数, \(R\)是由\(P_1,P_2,P_3\)通过预分享随机性生成的最后一比特(最低位)为1的全局偏移量, 且\(R\)是所有\([[\cdot]]^\mathbf G\)-sharing中共有的. 容易证明, \(\mathsf{LSB}([[v]]_{P_i}^\mathbf G)\oplus\mathsf{LSB}([[v]]_{P_0}^\mathbf G)=v\). 简单起见, 当\(v\in\mathbb Z_{2^\ell}\)时, 用\([[v]]^\mathbf G\)表示\(v\)的每个比特的\([[\cdot]]^\mathbf G\)份额的集合.</p>
</li>
<li>
<p>输入共享: 输入共享协议\(\Pi_\mathsf{Sh}^\mathbf{G}(P_i,v)\)使得\(P_i\)生成\([[v]]^\mathbf{G}\). 在协议中, \(P_0\)需要确保得到正确的\(K_v^v\). 为此, 需要让混淆方向\(P_0\)承诺混淆电路的密钥, 然后\(P_0\)通过交叉验证所收到的承诺来验证正确性. 具体过程如下:</p>
</li>
</ul>
<img src="media/16524092173945/16524092992677.png" alt="image-20220401113704731" style="zoom:50%;" />
<p>若\(P_i=P_0\), 则\(P_0\)采样随机比特\(v_1\), 计算\(v_2=v\oplus v_1\), 分别发送\(v_1,v_2\)给\(P_1,P_2\). 然后参与方分别执行\(\Pi_\mathsf{Sh}^\mathbf G(P_1,v_1)\)和\(\Pi_\mathsf{Sh}^\mathbf G(P_2,v_2)\), 分别得到\([[v_1]]^\mathbf G\)和\([[v_2]]^\mathbf G\). 然后参与方通过free-XOR技术本地计算\([[v]]^\mathbf G=[[v_1]]^\mathbf G\oplus[[v_2]]^\mathbf G\). 此时承诺的密钥不需要置换, 因为\(P_0\)已知\(v_1\)和\(v_2\). 作为优化, \([[v_1]]^\mathbf G\)的计算可以转移到离线阶段.</p>
<ul>
<li>
<p>输出重构: 若\(P_i=P_0\), 则\(P_1,P_2\)发送他们份额的最后一比特给\(P_i\), 然后\(P_i\)验证所收到的值是否相同. 若\(P_i\)是其中一个混淆方, 则\(P_0\)发送它的份额为\(P_i\). 由于底层混淆电路的可靠性(authenticity), 腐化的\(P_0\)不能发送错误的份额给\(P_i\). 若面向\(P_i\in\{P_1,P_2,P_3\}\)有多个重构, 则\(P_0\)可以发送它份额的最后一比特连同所有相应份额的哈希值.</p>
</li>
<li>
<p>基本算子: 设\(u,v\in\{0,1\}\)通过\([[\cdot]]^\mathbf G\)-sharing秘密共享, \(P_1,P_2,P_3\)持有份额\((K_u^0\oplus uR,K_v^0\oplus vR)\). 令\(c\)表示输出.</p>
<ul>
<li>XOR: 参与方本地计算\([[c]]^\mathbf G=[[u]]^\mathbf G\oplus[[v]]^\mathbf G\);</li>
<li>AND: 离线阶段, \(P_1,P_2,P_3\)采样随机\(K_c^0\in\{0,1\}^\kappa\), 计算\(K_c^1=K_c^0\oplus R\), 然后构造AND门的混淆表. \(P_1\)发送混淆表给\(P_0\), 同时\(P_2\)发送表的哈希值给\(P_0\). 在线阶段, \(P_0\)对电路进行求值, 得到\([[c]]_{P_0}^\mathbf G=K_c^c\). 对\(i\in\{1,2,3\}\), \(P_i\)设定\([[c]]_{P_i}^\mathbf G=K_c^0\).</li>
</ul>
</li>
</ul>
<h3><a id="building-blocks" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building Blocks</h3>
<ul>
<li>可验证的算术/布尔份额: 协议\(\Pi_\mathsf{vSh}\)允许\(P_i,P_j\)以可验证的方式生成\([[v]]\). 简单来说, \(P_i\)执行\(\Pi_\mathsf{Sh}(P_i,v)\), 同时\(P_j\)发送\(\mathsf{H}(m_v)\)给\(P_1,P_2,P_3\)辅助验证. 具体过程如下图7, 离线阶段不需要交互, 在线阶段需1轮, 至多\(2\ell\)比特均摊通信量. 若\(P_1,P_2,P_3\)都已知\(v\), 则可令\(\lambda_{v,1}=\lambda_{v,2}=\lambda_{v,3}=0\)和\(m_v=v\), 从而让参与方不需要交互即可生成\([[v]]\).</li>
</ul>
<img src="media/16524092173945/16524092992727.png" alt="image-20220401154559068" style="zoom:50%;" />
<ul>
<li>可验证的Garbled Sharing: 协议\(\Pi_\mathsf{vSh}^\mathbf G(P_i,P_j,v)\)允许\(P_i,P_j\)以可验证的方式生成\([[v]]^\mathbf G\). 当\(P_i,P_j\)都是混淆方时, 其中一方可以发送密钥, 同时另一方发送相对应的哈希值以检测一致性. 若\(P_j=P_0\), 则\(P_1,P_2\)依序发送密钥的承诺给\(P_0\). 此外, \(P_i\)发送实际密钥的解承诺给\(P_0\). 具体协议过程如下图, 离线阶段不需要交互, 在线阶段需要1轮, 均摊通信量为\(\kappa\)比特.</li>
</ul>
<img src="media/16524092173945/16524092992779.png" alt="image-20220401163115929" style="zoom:50%;" />
<ul>
<li>点积计算协议\(\Pi_\mathsf{DotP}(\vec{\mathbf x},\vec{\mathbf y})\rightarrow z\): 给定长度为\(d\)的向量\(\vec{\mathbf x},\vec{\mathbf y}\), 计算\(z=\vec{\mathbf x}\odot\vec{\mathbf y}\). 协议的构造思路与乘法协议类似, 为了让通信开销独立于向量长度, 对于\(j\in\{1,\cdots,d\}\), 在线阶段不逐个重构\(x_j\cdot y_j\), 参与方本地将所有乘积结果累加在一起然后只通信一次, 从而减少\(d\)倍的通信开销. 具体协议过程如下, 离线阶段需要1轮, 均摊通信量为\(3\ell\)比特, 在线阶段需要1轮, 均摊通信量为\(3\ell\)比特.</li>
</ul>
<img src="media/16524092173945/16524092992841.png" alt="TRIDENT9" style="zoom:50%;" />
<h3><a id="sharing-conversions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sharing Conversions</h3>
<ul>
<li>Garbled to Boolean Sharing (<strong>G2B</strong>): 离线阶段, \(P_1,P_2\)首先使用预共享随机性生成随机值\(r\), 然后分别生成\([[r]]^\mathbf G,[[r]]^\mathbf B\). 此外, 他们还通信计算两比特XOR的混淆电路及其解码信息给\(P_0\). 在线阶段, \(P_0\)进行求值得到\(v\oplus r\), 并发送结果及其相应密钥的哈希值给\(P_3\). 混淆电路的可靠性保证了腐化的\(P_0\)不能发送错误的比特, 因为它无法猜中与之对应的密钥. 具体转换过程如下:</li>
</ul>
<img src="media/16524092173945/16524092992909.png" alt="image-20220401173812263" style="zoom:50%;" />
<ul>
<li>Garbled to Arithmetic Sharing (<strong>G2A</strong>): 与G2B类似, 主要的不同之处在于将混淆电路的XOR变为两个\(\ell\)比特数的加减法电路计算. 具体转换过程如下:</li>
</ul>
<img src="media/16524092173945/16524092992973.png" alt="image-20220401200952578" style="zoom:50%;" />
<ul>
<li>Boolean to Garbled Sharing (<strong>B2G</strong>): 由于在布尔世界中, 比特\(v=(m_v\oplus\lambda_{v,1})\oplus(\lambda_{v,2}\oplus\lambda_{v,3})\), 若参与方可得到\(x=(m_v\oplus\lambda_{v,1})\)和\(y=(\lambda_{v,2}\oplus\lambda_{v,3})\), 则可以通过free-XOR技术本地计算\(v\). 具体转换过程如下:</li>
</ul>
<img src="media/16524092173945/16524093000056.png" alt="image-20220401203633114" style="zoom:50%;" />
<ul>
<li>Arithmetic to Garbled Sharing (<strong>A2G</strong>): 类似于B2G, \(v=(m_v-\lambda_{v,1})-(\lambda_{v,2}+\lambda_{v,3})\), 参与方调用\(\Pi_\mathsf{vSh}^\mathbf G\)可验证地生成\(x=(m_v-\lambda_{v,1})\)和\(y=(\lambda_{v,2}+\lambda_{v,3})\)的混淆份额\([[x]]^\mathbf G,[[y]]^\mathbf G\). 在线阶段, 参与方对混淆减法电路进行求值得到\(v=x-y\)的份额. 具体转换过程如下:</li>
</ul>
<img src="media/16524092173945/16524092993034.png" alt="TRIDENT13" style="zoom:50%;" />
<ul>
<li>Arithmetic to Boolean Sharing (<strong>A2B</strong>): 类似于A2G, 主要的不同之处是参与方生成\(x=(m_v-\lambda_{v,1})\)和\(y=(\lambda_{v,2}+\lambda_{v,3})\)的布尔份额\([[x]]^\mathbf B,[[y]]^\mathbf B\), 并对比布尔减法电路进行求值计算\(v=x-y\)的布尔份额\([[v]]^\mathbf B\). 具体转换过程如下:</li>
</ul>
<img src="media/16524092173945/16524093002671.png" alt="image-20220401214226880" style="zoom:50%;" />
<ul>
<li>Bit to Arithmetic Sharing (<strong>Bit2A</strong>): 计算\([[b]]^\mathbf B\rightarrow[[b]]\). 设\(u,v\)分别表示在环\(\mathbb Z_{2^\ell}\)上的比特\(\lambda_{b},m_b\). 根据\(b=m_b\oplus\lambda_b=v+u-2vu\), \(P_0\)在离线阶段生成\(\langle u \rangle\). 为了确保份额的正确性, \(P_1,P_2,P_3\)检验是否满足等式\((\lambda_b\oplus r_b)'=u+r_b'-2ur_b'\), 其中\(a'\)表示比特\(a\)在环\(\mathbb Z_{2^\ell}\)上的对应值. 通过验证后, 参与方本地转换\(\langle u\rangle\)为\([[u]]\). 在在线阶段, 参与方计算\(u\)和\(v\)的秘密份额乘积\([[uv]]\), 然后本地计算\([[b]]=[[v]]+[[u]]-2[[uv]]\). 需要注意的是当执行\(\Pi_\mathsf{Sh}(P_1,P_2,P_3,v)\)时, \(\lambda_v=0\), 所以计算乘法时不需要\(\gamma_{uv}\)的份额. 具体转换过程如下:</li>
</ul>
<img src="media/16524092173945/16524092993092.png" alt="TRIDENT15" style="zoom:50%;" />
<ul>
<li>
<p>Boolean to Arithmetic Sharing (<strong>B2A</strong>): 利用事实\(v=\sum_{i=0}^{\ell-1}2^i\cdot v_i\), 其中\(v_i\)代表环\(\mathbb Z_{2^\ell}\)上的值\(v\)的第\(i\)比特. 可利用关系\(v=\sum_{i=0}^{\ell-1}2^i\cdot v_i=\sum_{i=0}^{\ell-1}2^i\cdot(m_{v_i}\oplus\lambda_{u_i})=\sum_{i=0}^{\ell-1}2^i\cdot (m_{v_i}'+\lambda_{u_i}'-2m'_{v_i}\cdot\lambda_{u_i}')\), 其中\(m_{v_i}',\lambda_{u_i}'\)分别表示环\(\mathbb Z_{2^\ell}\)上的比特\(m_{v_i}\)和\(\lambda_{u_i}\).</p>
<p>B2A的离线阶段与Bit2A类似, 具体转换过程如下:</p>
</li>
</ul>
<img src="media/16524092173945/16524092993157.png" alt="image-20220403092405398" style="zoom:50%;" />
<ul>
<li>
<p>Bit Injection (<strong>BitInj</strong>): 计算\([[b]]^\mathbf B[[v]]\rightarrow[[bv]]\). 在环\(\mathbb Z_{2^\ell}\)上, 令\(y_1=\lambda_b\), \(y_2=\lambda_b\lambda_v\). 类似地, 令\(x_0=m_bm_v\),\(x_1=m_b\),\(x_2=m_v-2m_vm_b\),\(x_3=2m_b-1\), 则\(b\cdot v=(m_b\oplus\lambda_b)(m_v-\lambda_v)=x_0-x_1y_1+x_2y_2+x_3y_3\).</p>
<p>在离线阶段, \(P_0\)生成\(\lambda_{b}'\)和\(\lambda_b\lambda_v\), 其中\(\lambda_{b}'\)表示环\(\mathbb Z_{2^\ell}\)上的比特. 检验\(\langle\lambda_b'\rangle\)的方法与\(\Pi_\mathsf{Bit2A}\)相同, 检验\(\langle\lambda_b\lambda _v\rangle\)的方法是计算\(\Pi_\mathsf{BitInj}\). 在线阶段, 参与方通过执行\(\Pi_\mathsf{vSh}\)本地计算\([b\cdot v]\), 最后参与方本地累加份额得到\([[b\cdot v]]\). 具体转换过程如下:</p>
</li>
</ul>
<img src="media/16524092173945/16524093003347.png" alt="TRIDENT17" style="zoom:50%;" />
<p>不同转换协议的通信轮次和通信量与ABY3之间的对比如下, 其中\(\mathsf{G1}\)表示2输入减法混淆电路, \(\mathsf{G2}=\mathsf{Gar}(2,\mathsf{Sub},\ell)\)表示2输入减法混淆电路及其解码信息, 类似地定义\(\mathsf{G3}=\mathsf{Gar}(3,\mathsf{Sub},\ell)\), \(\mathsf{G4}=\mathsf{Gar}(3,\mathsf{Adder},\ell)\).</p>
<img src="media/16524092173945/16524092993221.png" alt="image-20220403090623808" style="zoom:50%;" />
<h2><a id="privacy-preserving-machine-learning" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Privacy Preserving Machine Learning</h2>
<p>使用\(\mathbb Z_{2^\ell}\)上的有符号补码(signed two's compliment)来表示运算中涉及的十进制数, 其中最高位(MSB)是符号位, 最后\(d\)位表示小数部分.</p>
<h3><a id="sharing-truncation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sharing Truncation</h3>
<p>与ABY3的概率截断方法类似: 首先生成随机截断对\((r,r^t)\), 其中\(r^t\)是\(r\)的截断值, 则\(z\)的截断值\(z^t\)可以通过首先恢复\(z-r\)再截断为\((z-r)^t\), 最后加上\(r^t\)得到, 即\(z^t=(z-r)^t+r^t\). 不同之处在于本文没有使用任何布尔电路, 从而将离线阶段轮复杂度改进为常数轮. 首先参与方非交互地生成\(\langle r\rangle\), 使得\(P_0\)得到\(r\). 然后\(P_0\)生成\([[r^t]]\), \(P_1,P_2,P_3\)利用关系\(r=2^dr^t+r_d\)(带余除法)来验证\(P_0\)所生成的份额正确性, 其中\(r_d\)表示\(r\)的最后\(d\)比特. 具体份额截断协议如下:</p>
<img src="media/16524092173945/16524092993289.png" alt="TRIDENT18" style="zoom:50%;" />
<p>正确性: 协议\(\Pi_\mathsf{MultTr}\)的离线阶段, 若腐化\(P_0\)生成了错误的\([[r^t]]\)份额, 则\(P_1,P_2,P_3\)中止.</p>
<p>证明: 只需证明\(m_1+m_2=c\), 其中\(m_1=r_2-2^dr_2^t-r_{d,2}+c\), \(m_2=(r_1+r_3)-2^d(r_1^t+r_3^t)-(r_{d,1}+r_{d,3})\). 注意到\(r=2^dr^t+r_d\), 所以有</p>
\[\begin{aligned}
m_1+m_2&amp;=(r_2-2^dr_2^t-r_{d,2}+c)+((r_1+r_3)-2^d(r_1^t+r_3^t)-(r_{d,1}+r_{d,3}))\\
&amp;=(r_1+r_2+r_3)-2^d(r_1^t+r_2^t+r_3^t)-(r_{d,1}+r_{d,2}+r_{d+3})+c\\
&amp;=(r)-(2^dr^t+r_d)+c=0+c=c.
\end{aligned}
\]
<h3><a id="secure-comparison" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secure Comparison</h3>
<p>给定\(x,y\)的算术共享份额, 计算\(x&lt;_?y\)的布尔共享份额. 在定点表示形式下, 最简单的方式是计算最高位\(\mathsf{MSB}(x-y)\). 为此可以通过构造比特抽取协议\(\Pi_\mathsf{BitExt}\)来完成. 本文中的比特抽取协议与ABY3类似. \(P_0,P_3\)离线阶段生成\(y=\lambda_{v,1}+\lambda_{v,2}\)的布尔份额, \(P_1,P_2\)在在线阶段生成\(x=m_v-\lambda_{v,3}\)的布尔份额. 然后参与方使用ABY3的优化的Parallel Prefix Adder (PPA)进行求值计算得到最高位的布尔份额.</p>
<h3><a id="activation-functions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Activation Functions</h3>
<ul>
<li>ReLU: \(\mathsf{relu}(v)=\mathsf{max}(0,v)=(1\oplus b)v\), 其中比特\(b=1\Leftrightarrow v&lt;0\). 因此参与方首先调用\(\Pi_\mathsf{BitExt}\)得到\([[b]]^\mathbf B\), 本地计算\([[1\oplus b]]^\mathbf B\). 最后调用\(\Pi_\mathsf{BitInj}\)计算\([[1\oplus b]]^\mathbf B\cdot[[v]]\).</li>
<li>Sigmoid: 使用SecureML中的分段近似函数来计算Sigmoid函数. 此时\(\mathsf{sig}(v)=(1\oplus{b}_1)b_2(v+1/2)+(1\oplus{b}_2)\), 其中\(v+1/2&lt;0\Leftrightarrow b_1=1\), \(v-1/2&lt;0\Leftrightarrow b_2=1\). 类似于计算ReLU的方法进行求解, 但需要额外调用一次\(\Pi_\mathsf{BitExt}\), \(\Pi^\mathbf B_\mathsf{Mult}\)和\(\Pi_\mathsf{BitInj}\).</li>
<li>Softmax: 使用SecureML中提出的变体来近似: \(\mathsf{smx}(u_i)=\frac{\mathsf{relu}(u_i)}{\sum_{j=1}^{n_f}\mathsf{relu}(u_j)}\). 除法则通过A2G和除法混淆电路来计算.</li>
</ul>
<h3><a id="communication-cost" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Communication Cost</h3>
<p>以上机器学习相关的协议通信轮次和通信量与ABY3之间的对比如下:</p>
<img src="media/16524092173945/16524092993360.png" alt="image-20220403091656338" style="zoom:50%;" />
<h2><a id="implementation-and-benchmarking" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation and Benchmarking</h2>
<p>实验部分主要与ABY3的方案进行了比较, 实验内容为线性回归、逻辑回归、神经网络和卷积神经网络.</p>
<h3><a id="secure-training" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secure Training</h3>
<p>性能基准是LAN下计算每秒钟的迭代次数, WAN下计算每分钟的迭代次数.</p>
<ul>
<li>线性回归: LAN/WAN设定下与ABY3对比如下</li>
</ul>
<img src="media/16524092173945/16524092993436.png" alt="image-20220403095347025" style="zoom:50%;" />
<ul>
<li>逻辑回归: LAN/WAN设定下与ABY3的对比如下</li>
</ul>
<img src="media/16524092173945/16524092993517.png" alt="image-20220403095722855" style="zoom:50%;" />
<ul>
<li>神经网络: LAN/WAN设定下与ABY3的对比如下</li>
</ul>
<img src="media/16524092173945/16524092993598.png" alt="image-20220403100021867" style="zoom:50%;" />
<h3><a id="secure-prediction" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secure Prediction</h3>
<p>以在线阶段的时延(Latency)作为基准, 结果如下:</p>
<img src="media/16524092173945/16524092993679.png" alt="image-20220403101045997" style="zoom:50%;" />
<p>LAN下在线吞吐量(每秒钟预测次数)和WAN下在线吞吐量(每分钟预测次数)与ABY3在不同数据集下的对比如下:</p>
<img src="media/16524092173945/16524092993762.png" alt="image-20220403103318655" style="zoom:50%;" />
<img src="media/16524092173945/16524092993846.png" alt="image-20220403103403019" style="zoom:50%;" />
<h2><a id="conclusions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusions</h2>
<p>Trident是一个遵循离线-在线范式的四方机器学习框架, 可抵抗1个恶意敌手. 与ABY3相比, Trident在离线阶段引入一个额外的计算方\(P_0\), 在构造协议时尽可能少地应用昂贵的电路, 在线阶段则主要是三方计算. 所提出的方案支持不同世界的份额之间相互转化, 同时公平重构协议还实现了Fairness. 非线性算子的安全计算协议在线阶段通信轮次均为常数轮. 从实验结果综合来看, Trident与ABY3相比具有明显的优势.</p>
<h2><a id="references" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>References</h2>
<p>[1] P. Mohassel and P. Rindal, “ABY3: A Mixed Protocol Framework for Machine Learning,” in ACM CCS, 2018.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Secure Evaluation of Quantized Neural Networks]]></title>
    <link href="https://weiviming.github.io/16519051511907.html"/>
    <updated>2022-05-07T14:32:31+08:00</updated>
    <id>https://weiviming.github.io/16519051511907.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>今天给大家带来的是发表于PoPETs'20上的文章Secure Evaluation of Quantized Neural Networks, 作者是来自丹麦Aarhus大学的Anders Dalskov, Daniel Escudero, Marcel Keller. 原文链接: <a href="https://arxiv.org/pdf/1910.12435.pdf">这里</a>.</p>
</blockquote>
<h2><a id="introduction" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h2>
<p>目前在实践中进行安全推理的研究大多聚焦于提升性能, 但这是远远不够的. 从机器学习的角度来说, 大多数现有的安全推理方案依赖于专门的激活函数(如CryptoNets)或专门的训练过程(如XONN), 此外, 浮点数到定点数的转化、对激活函数的近似步骤, 所有这些都会影响模型的准确率, 从而影响模型的表达能力. 这成为开发机器学习方案时不得不考虑的一个问题. 从MPC的角度来说, 所使用的MPC对于被评估的网络来说应该是“Oblivious”的, 因为这将允许用户自由地选取适合他们的威胁模型, 而不需要考虑网络的结构或者专门的硬件. 本文研究了通用MPC框架是如何用来评估CNN的. 这篇文章提出并回答了以下两个问题:</p>
<ol>
<li>主流的机器学习框架在多大程度上支持“MPC友好”模型而不需要定制转换协议? 换而言之, 是否可以使用标准框架设计一个模型通过安全协议高效地评估它, 而不改动模型本身呢?</li>
<li>现有的MPC框架在多大程度上对模型支持“开箱即用”? 换而言之, 能否使用通用MPC框架安全地评估机器学习模型?</li>
</ol>
<p>文章对上述两个问题给出了肯定的回答, 并指出Tensorflow, PyTorch和MXNet支持的量化技术可以安全评估模型, 这种评估可通过通用MPC框架来执行. 实验部分从MPC的几个维度进行了广泛的基准测试, 并指出现有的机器学习框架和现有的MPC协议之间的鸿沟可能比先前已有工作中的隐含建议的小的多.</p>
<h2><a id="quantization" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quantization</h2>
<p>文章采用的量化技术是来自于Jacob等人的方案<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup>,  虽然不是当前最佳技术, 但它在Tensorflow中有相关实现(TFLite), 便于进行安全评估和对比. 此外, 该方案便于MPC实现, 因为它简化了CNN的激活函数和算术运算, 尽管Jacob方案的初衷只是减小模型的规模, 但当MPC实现时, 由于模运算的存在, 并不能达到减小网络规模的效果. 更多量化技术的综述可以参考Guo的文章<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup>.</p>
<h3><a id="quantization-and-de-quantization" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quantization and De-Quantization</h3>
<p>Jacob方案有两个变种, 一是8-bit整数, 二是16-bit整数. 本文中主要关注8-bit整数.</p>
<p>令\(m\in\mathbb R, z\in[0,2^8)_\mathbb{Z}\). 考虑函数\(\mathsf{dequant}_{m,z}:[0,2^8)_\mathbb Z\rightarrow\mathbb R\), \(\mathsf{dequant}_{m,z}(x)=m\cdot(x-z)\). 该函数将离散区间\([0,2^8)_\mathbb Z\)映射到连续区间\(I=[-m\cdot z,m\cdot(2^8-1-z))\). \(\mathsf{quant}_{m,z}\)为该函数的逆函数. 定义\(\alpha\in I\)的量化为\(\mathsf{quant}_{m,z}(\alpha')\), 这里的\(\alpha'\)是与\(\alpha\)最近的数, 使得\(\alpha'\)是\(\mathsf{dequant}_{m,z}\)的像, 由于是连续空间映射到离散空间, 因此由于舍入的原因, 连续区间的多个值可能映射到离散空间中相同的值. 如下图.</p>
<img src="media/16519051511907/16519726485606.png" alt="image-20211213154326413" style="zoom:50%;" />
<p>常数\(m,z\)称为量化参数, 其中\(m\)称为缩放因子(scale), \(z\)称为零点(zero point). 每个单独的张量\(\mathbf{\alpha}\)都有一对与之相关联的\(m,z\). 这些参数是根据训练时记录给定张量的条目范围, 使得区间\([-m\cdot z,m\cdot(2^8-1-z))\)足够大来容纳这些值来确定的.</p>
<h3><a id="dot-products" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dot Products</h3>
<p>下面介绍量化方案下的点积计算方案.</p>
<p>令\(\alpha=(\alpha_1,\cdots,\alpha_N), \beta=(\beta_1,\cdots,\beta_N)\)分别是量化参数为\((m_1,z_1), (m_2,z_2)\)的两个向量. 令\(\gamma=\sum_{i=1}^N\alpha_i\cdot\beta_i\), 量化参数为\((m_3,z_3)\).   令\(c=\mathsf{quant}_{m_3,z_3}(\gamma), a_i=\mathsf{quant}_{m_1,z_1}(\alpha_i), b_i=\mathsf{quant}_{m_2,z_2}(\beta_i)\), 则可通过仅用整数算术和定点乘法从\(a_i,b_i\)计算\(c\):</p>
<p>因为\(\gamma\approx m_3(c-z_3), \alpha_i\approx m_1(a_i-z_1), \beta_i\approx m_2(b_i-z_2)\), 因此有</p>
\[m_3\cdot(c-z_3)\approx\gamma=\sum_{i=1}^N\alpha_i\cdot\beta_i\approx\sum_{i=1}^N m_1\cdot(a_i-z_i)\cdot m_2\cdot(b_i-z_3).
\]
<p>于是, 我们可以得到\(c\)的近似为</p>
\[c=z_3+\frac{m_1\cdot m_2}{m_3}\cdot\sum_{i=1}^N(a_i-z_1)\cdot(b_i-z_2).
\]
<p>其中, 求和\(s=\sum_{i=1}^N(a_i-z_1)(b_i-z_2)\)都是只有整数的算术运算, 但因为\(m=\frac{m_1m_2}{m_3}\)是实数, 因此\(m\cdot s\)不能通过只有整数的算术计算得出. TFLite中的处理方式是将\(m\)转化为定点数然后计算定点数乘法并舍入到与之最近的整数, 具体来说, 首先将\(m\)规范化(Normalized)为\(m=2^{-n}m''\), 且将\(m''\)近似为\(m''\approx2^{-31}m'\), 其中\(m''\in[0.5,1)\), \(m'\)是个32bit的整数. 因为\(m''\geq1/2\), 所以至少有30bit的相对精度. 于是, 我们便可以计算\(m\cdot s\)(最多64bit), 然后乘上\(2^{-n-31}\)以四舍五入到最近的整数, 最后加上\(z_3\)即可. 总结一下,</p>
\[c=z_3+\lceil2^{-n-31}m's\rfloor.
\]
<p>若\(\gamma\)计算正确, 则\(c\)一定在区间\([0,2^8)_\mathbb{Z}\)内, 但由于舍入误差的缘故, 实际情况可能并非如此. 因此, 前面步骤所得到的结果被限制(clamped)在区间\([0,2^8)_\mathbb{Z}\)内.</p>
<p>CNN中需要计算偏置项(bias), 本文中bias的量化参数取\(m=\frac{m_1m_2}{m_3}, z=0\), 便可以将其并入点积计算中.</p>
<h3><a id="other-layers" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Other Layers</h3>
<p>本文不考虑其他激活函数. 对于ReLU, ReLU6, Maxpool层, 都是比较运算, 可以通过假设它们具有共同的量化参数, 从而在量化值上相对容易地实现, 因为若\(\alpha=m(a-z), \beta=m(b-z)\), 则\(\alpha\leq\beta\)当且仅当\(a\leq b\).</p>
<p>ReLU6这样的限制激活函数, 可以通过适当选取量化参数, 从而融入到点积计算中, 限制乘积在区间\([0,2^8)_\mathbb{Z}\)内同时兼顾ReLU6的运算. 简而言之, 若\(z=0, m=6/255\), 则可以保证对于任意的\(q\in\{0,\cdots,2^8-1\}\), 有\(m(q-z)\in[0,6]\).</p>
<p>Jacob的量化方案已经将量化神经网络的大多数运算变成了加法和乘法, 而这便于MPC协议的设计.</p>
<h2><a id="quantized-cnns-in-mpc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quantized CNNs in MPC</h2>
<h3><a id="system-and-threat-model" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>System and Threat Model</h3>
<p>基本场景: 服务器代理模式/客户-服务器模式(Client-server, CS), 模型拥有方和客户分别秘密共享模型和数据并外包到两个/三个服务器中, 由服务器通过给定输入执行安全多方计算协议运行安全推理任务, 并将分类结果发给所需参与方. 这里的服务器数量取决于共谋假设, 并允许至多一个服务器被腐化, 即两个服务器对应于不诚实大多数, 三个服务器对应于诚实大多数.</p>
<img src="media/16519051511907/16519726485620.png" alt="image-20211213191450434" style="zoom:50%;" />
<p>CS模型的另一个优点是高度兼容反应式计算(reactive computation), 这里预测的输出需要用于后续计算, 这种情况下, 由于服务器获得了输出的份额, 因此可以直接将此结果传输到另一个MPC计算任务中. 此外还可以考虑点对点模式, 但需要额外的一轮输入来保证输入的一致性.</p>
<p>本文中使用的通用MPC协议可以根据三个不同的维度进行分类:</p>
<ol>
<li>腐化门限: 不诚实大多数(2PC) vs 诚实大多数(3PC);</li>
<li>腐化类型: 被动敌手 vs 主动敌手;</li>
<li>底层代数结构: \(\mathbb F_p\) vs \(\mathbb Z_{2^k}\).</li>
</ol>
<p>实际应用时, 根据上述维度的不同, 采用的协议如表1所示.</p>
<img src="media/16519051511907/16519726485632.png" alt="image-20211215205632112" style="zoom:50%;" />
<ul>
<li>
<p><strong>不诚实大多数</strong>: 不诚实大多数协议通常基于加法秘密共享和使用验证标签(authentication tags)来实现主动安全.</p>
<ul>
<li>\(\mathsf{SPDZ2k}\): 二次幂环\(\mathbb Z_{2^k}\)上的第一个不诚实大多数设定下的主动安全协议, 可视为\(\mathsf{MASCOT}\)的扩展版本, 最早由Cramer等人在CRYPTO'18上提出<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup>, 由Damgård等人<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup>首先实现. 乘法计算依赖于预处理基于OT来生成Beaver triples, 验证方案同SPDZ, 但是是在\(\mathbb{Z}_{2^{k+s}}\)上进行验证. 为了一个检验Beaver triple的正确性, 通常需要&quot;献祭&quot;(Sacrifice)另一个Beaver triple.</li>
<li>\(\mathsf{OTSemi2k}, \mathsf{OTSemiPrime}\): 分别是\(\mathsf{SPDZ2k}\)和\(\mathsf{MASCOT}\)的精简版本, 没有验证标签和&quot;献祭&quot;步骤. 基于OT来生成Beaver triples.</li>
<li>\(\mathsf{LowGear}\): Keller等人提出的素数域上主动安全协议, 基于LWE的半同态加密方案<sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup>.</li>
</ul>
</li>
<li>
<p><strong>诚实大多数</strong>: 诚实大多数协议通常基于Shamir秘密共享(适用于任意数量参与方的情况)和复制秘密共享(Replicated Secret Sharing, 适用于参与方数量较少的情况)来进行设计. 本文的场景下, 计算方数量较少, 使用复制秘密共享即可.</p>
<ul>
<li>\(\mathsf{Replicated2k}, \mathsf{ReplicatedPrime}\): 当前最高效的被动安全乘法协议是由Araki等人在CCS'16年提出的方案<sup class="footnote-ref"><a href="#fn6" id="fnref6">6</a></sup>, 仅需通信3个元素.</li>
<li>\(\mathsf{PsReplicatedPrime}\): Lindell和Nof将\(\mathsf{ReplicatedPrime}\)扩展到主动安全的协议<sup class="footnote-ref"><a href="#fn7" id="fnref7">7</a></sup>, 通过预处理可能不正确的三元组用于在线阶段, 并在协议执行结束后通过&quot;献祭&quot;技术检查它们的正确性来实现主动安全.</li>
<li>\(\mathsf{PsReplicated2k}\): 由Eerkison等人提出的协议<sup class="footnote-ref"><a href="#fn8" id="fnref8">8</a></sup>, 是上面Lindell等人方案在二次幂环\(\mathbb Z_{2^k}\)上的扩展版本.</li>
</ul>
</li>
</ul>
<h3><a id="secure-comparison" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secure Comparison</h3>
<p>安全计算\(\langle b\rangle\leftarrow\langle x\rangle&lt;_?\langle y\rangle\), 其中比特\(b=(x&lt;y)\). 对于不同的代数结构, \(\mathbb F_p\)可参考文献<sup class="footnote-ref"><a href="#fn9" id="fnref9">9</a></sup>; \(\mathbb Z_{2^k}\)可参考文献<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup>. 对于复制秘密共享, ABY3提供了更高效的方案.</p>
<h3><a id="truncation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Truncation</h3>
<p>对于公开参数\(m\), 需要安全计算\(\langle y\rangle\leftarrow\langle x\rangle\), 这里的\(y=\lfloor\frac{x}{2^m}\rfloor\). 可通过概率截断(probabilistic truncation)协议. 在概率截断协议中, 计算\(\langle z\rangle\), 其中\(z=\lfloor\frac{x}{2^m}\rfloor+u\), 这里\(u\in\{0,1\}\)是小误差, 取值取决于\(\lfloor\frac{x}{2^m}\rceil\), 即\(u=1\)的概率为\(\frac{x}{2^m}\)的小数部分\((x\bmod2^m)/2^m\). 例如\(x=7,m=2\), 则概率截断将以\((7\bmod2^2)/2^2=0.75\)的概率输出\(u=1, z=\lfloor\frac{7}{4}\rfloor+1=2\), 以0.25的概率输出\(u=0, z=\lfloor\frac{7}{4}\rfloor=1\).</p>
<p>本文提出了一种环\(\mathbb Z_{2^k}\)上的概率截断方案, 份额只需比秘密大1bit, 同时常数轮通信的, 结果的误差最多为1,偏向于最接近\(x/2^m\)的整数. 假设有一个生成随机份额比特的方法, 生成\(\langle b\rangle\), 满足\(b\in\{0,1\}\)是均匀随机且敌手未知的. 在不诚实大多数设定下可以参考文献<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup>的方法生成. 一般地,  可以让\(P_i\)生成1比特\(\langle b_i\rangle\), 然后参与方将这些比特XOR在一起得到一个随机1比特. 当然为了确保\(P_i\)生成的\(\langle b_i\rangle\)确实是1比特的, 可以验证\(\langle b_i\rangle\cdot(1-\langle b_i\rangle)\)是否为零. 具体的概率截断如下, 注意图中第二步应为\(c'\leftarrow (c\bmod2^{k-1})/2^m\), 第四步中应为输出\(c'-\sum_{i=m}^{k-2}\langle r_i\rangle\cdot2^{i-m}+\langle b\rangle\cdot2^{k-m-1}\).</p>
<img src="media/16519051511907/16519726485643.png" alt="image-20211214213428298" style="zoom:50%;" />
<p>如果考虑环\(\mathbb Z_{2^k}\)上三方复制秘密共享、半诚实安全设定, 可以让将上述对称的三方协议转化为两方协议, 由第三方生成供其他两方使用的相关随机性, 如任意长度的随机数, 这样不再需要逐比特生成随机数.</p>
<img src="media/16519051511907/16519726485658.png" alt="image-20211214220908605" style="zoom:50%;" />
<p>由于量化方案与传统定点算术不同, 量化方案中的参数是针对网络的特定层自适应选取的, 这些参数是模型的敏感信息, 因此有必要探索当\(m\)是秘密时的截断方案. 假设\(M\)是\(m\)的公开上界, 首先对\(M-m\)比特分解, 根据\(M-m=\sum_{i}2^i\cdot b_i\), 我们得到\(b_i\)的份额\(\langle b_i\rangle\), 并计算\(\langle 2^{M-m}\rangle=\prod_i(1+\langle b_i\rangle\cdot(2^{2^i}-1))\). 特别地, 在CS模型下, \(m\)为模型拥有方Client所知, 可以简单地认为Client分发了\(\langle 2^{M-m}\rangle\), 不需要进行比特分解. 接着, 计算\(\langle 2^{M-m}\rangle\cdot\langle x\rangle\), 并将其结果用上述截断公开值的方案截断\(M\)位即可. 如下图, 得到的\(y=\lfloor \frac{2^{M-m}x}{2^M}\rfloor=\lfloor\frac{x}{2^m}\rfloor\). 注意, 这个方案需要确保\(2^{M-m}\cdot x\)不会溢出, 即必须保证$(M-m)+\log_2(|x|)&lt;|Modulus|$成立, 这里的$|Modulus|$表示模数比特长度.</p>
<img src="media/16519051511907/16519726485677.png" alt="image-20211215111748939" style="zoom:50%;" />
<h3><a id="putting-it-all-together" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Putting it all Together</h3>
<p>假设模型拥有者拥有量化CNN的所有参数信息, 并通过秘密共享方案分发网络每一层的量化权重、偏置项给服务器(注意虽然明文只有8bits, 但份额有64bits), 与每个张量相关联的零点也被分享给各参与方.</p>
<p>下面来计算公式(2). 计算方(服务器)有零点\(z_1,z_2,z_3\)的份额, 量化输入\(a_i,b_i\), 整数缩放因子\(m'\)和幂\(2^{L-\ell}\), 这里的\(\ell=n+31, 2^{-n-31}\cdot m'\approx m=(m_1\cdot m_2)/m_3\), 且\(L\)是\(\ell\)的上界. 为了计算公式(2), 计算方首先计算点积\(\langle s\rangle=\sum_{i=1}^N(\langle a_i\rangle-\langle z_1\rangle)\cdot(\langle b_i\rangle-\langle z_2\rangle)\), 然后通过乘法协议计算\(\langle m\cdot s\rangle=\langle m\rangle\cdot\langle s\rangle\), 并通过\(\mathsf{TruncPriv}\)协议从\(\langle 2^{L-\ell}\rangle\)和\(\langle m\cdot s\rangle\)计算\(\lfloor 2^{-n-31}\cdot(m\cdot s)\rceil\)的份额, 然后计算\(\lfloor 2^{-m}\cdot x\rceil=\lfloor2^{-m}\cdot x+0.5\rfloor=\lfloor 2^{-m}\cdot (x+2^{m-1})\rfloor\)进行舍入计算, 最后本地加上\(\langle z_3\rangle\), 限制\(\langle x\rangle\)到区间\([0,2^8)\), 这可根据安全比较, 将\(\langle x\rangle\)与边界0和255进行比较, 结合不经意选取来达到: 若\(s\in\{0,1\}\), 则对任意的\(a_0,a_1\), 则\(a_s=s\cdot(a_1-a_0)+a_0\).</p>
<p>平均池(Average pooling)计算中涉及的除法可以通过Goldschmidt's算法来计算, 安全计算协议可以参考Catrina和Saxena的这篇文献<sup class="footnote-ref"><a href="#fn10" id="fnref10">10</a></sup>. 最大池(Max pooling)要求计算的max函数可通过安全比较协议来实现.</p>
<p>在获得输出向量的份额后, 为了避免在计算SoftMax等激活函数之前向秘密拥有方/数据拥有方揭示向量本身, 本文中采用的方案是计算输出数组的arg max, 并返回最有可能的标签的索引来替代\(e^x\), 因为幂运算是个单调递增函数. 例如, 在SecureML中, 将SoftMax函数中的幂替换为ReLU, 即用\(\mathsf{ReLU}(x)\)替代\(e^x\). 此外, 还存在更多MPC友好的解决方案, 例如在spherical Softmax中将\(e^x\)替换为\(x^2\).</p>
<h2><a id="implementation-and-benchmarking" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation and Benchmarking</h2>
<p>本文的实验部分评估的是MobileNets类型架构的神经网络, 它包含28层, 1000个输出类, 在ImageNet数据集上进行训练, 在TensorFlow存储库上可用的预训练模型和准确率进行评估.</p>
<p>安全推理方面, 使用MP-SPDZ框架进行实现, 计算域分别为128bits的素数域和72bits的二次幂环, 因为需要额外的空间确保秘密截断是正确的. 实验代码已经发布在MP-SPDZ框架中, 脚本和图像见<a href="https://github.com/anderspkd/SecureQ8">这里</a>.</p>
<p>CNN核心运算是卷积, 效率提升主要来源于点积和乘法总数, 两者定量实验结果表2. 点积的通信开销取决于项的数量.</p>
<img src="media/16519051511907/16519726485697.png" alt="image-20211216084243307" style="zoom:50%;" />
<p>表3展示了16个预训练的V1 MobileNet模型分别从腐化门限(诚实大多数 VS 不诚实大多数)、腐化模型(被动 VS 主动)、代数结构(\(\mathbb{F}_p\) VS \(\mathbb Z_{2^k}\))、截断类型(Probabilistic truncation VS Nearest rounding)4个不同维度的运行时间的评估结果.</p>
<img src="media/16519051511907/16519726485721.png" alt="image-20211216091145286" style="zoom:50%;" />
<p>图3和图4分别是诚实大多数协议和不诚实大多数协议的实验结果.</p>
<img src="media/16519051511907/16519726485755.png" alt="output" style="zoom:50%;" />
<p>表4展示了在最简网络下, 对于三方以上的协议, 扩展到最多五方的实验结果. 腐化方的数量在诚实大多数中被设定为1、1、2, 在不诚实大多数中被设定为2、3、4.</p>
<img src="media/16519051511907/16519726485791.png" alt="image-20211216101748572" style="zoom:50%;" />
<p>本文提出的特殊截断协议不对秘密进行任何限制, 但CrypTFlow中要求秘密的前\(s\)比特为零, 这里的\(s\)是统计安全参数. 表5展示的是相同网络设置下, 不同截断方案的实验结果. 表6展示了使用特殊截断实现和不使用特殊截断实现的CrypTFlow的ImageNet测试结果, 注意这里的结果取自不同框架下的最优线程, MP-SPDZ为32线程, CrypTFlow为8线程.</p>
<img src="media/16519051511907/16519726485830.png" alt="output" style="zoom:50%;" />
<p>LAN网络下通信量(GB)测试结果如下:</p>
<img src="media/16519051511907/16519726485870.png" alt="image-20211216205806783" style="zoom:50%;" />
<p>总的来说, 实验部分的关键结论如下:</p>
<ol>
<li>由于不诚实大多数协议需要昂贵的预处理, 因此相同条件下从诚实大多数转移到不诚实大多数的开销差距高达200倍以上.</li>
<li>不同腐化模型之间的转移相对便宜, 不管腐化门限如何, 从被动安全到主动安全只增加了3-30倍的推理时间.</li>
<li>对于不同的代数结构来说, 基于环的大多数协议在被动安全设定下优于基于有限域的协议, 而在主动安全设定下则相反.</li>
<li>使用概率截断方案可以加快推理速度, 但这种效率提高以可能存在的模型精度下降为代价, 对于更深的模型会更加明显.</li>
</ol>
<h2><a id="conclusions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusions</h2>
<p>本文验证了使用现有MPC协议在不修改机器学习模型的前提下, 安全评估大型、现实的神经网络是可行的. 本文中评估的神经网络是未经修改的, 可通过标准Tensorflow或任何支持量化类型的框架(如PyTorch和MXNet)进行训练. 对于用户而言, 通用MPC足以对网络进行评估, 用户可以从更广泛的威胁模型中自由选择; 此外, 即使模型设计者对安全框架一无所知, Tensorflow输出的模型也可以在不经修改的情况下进行评估. 如果想在预测精度和效率方面进行权衡, 那么专用协议可能是更好的选择, 例如文章中提出的概率截断协议等.</p>
<h2><a id="references" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>References</h2>
<section class="footnotes">
<ol>
<li id="fn1">
<p>Benoit Jacob, Skirmantas Kligys, Bo Chen, Menglong Zhu, Matthew Tang, Andrew G. Howard, Hartwig Adam, and Dmitry Kalenichenko. Quantization and training of neural networks for efficient integer-arithmetic-only inference. CoRR, abs/1712.05877, 2017. <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2">
<p>Yunhui Guo. A survey on methods and theories of quantized neural networks. arXiv preprint arXiv:1808.04752, 2018. <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3">
<p>Ronald Cramer, Ivan Damgård, Daniel Escudero, Peter Scholl, and Chaoping Xing. SPD Z2k : Efficient MPCmod 2k for dishonest majority. In Hovav Shacham and Alexandra Boldyreva, editors, Advances in Cryptology – CRYPTO 2018, Part II, volume 10992 of Lecture Notes in Computer Science, pages 769–798, Santa Barbara, CA, USA, August 19–23, 2018. Springer, Heidelberg, Germany. <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4">
<p>I. Damgård, D. Escudero, T. Frederiksen, M. Keller,P. Scholl, and N. Volgushev. New primitives for actively secure mpc over rings with applications to private machine learning. In 2019 2019 IEEE Symposium on Security and Privacy (SP), pages 1325–1343, Los Alamitos, CA, USA, may 2019. IEEE Computer Society. <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
<li id="fn5">
<p>Marcel Keller, Valerio Pastro, and Dragos Rotaru. Over- drive: Making SPDZ great again. In Jesper Buus Nielsen and Vincent Rijmen, editors, Advances in Cryptology – EUROCRYPT 2018, Part III, volume 10822 of Lecture Notes in Computer Science, pages 158–189, Tel Aviv, Israel, April 29 – May 3, 2018. Springer, Heidelberg, Germany. <a href="#fnref5" class="footnote-backref">↩</a></p>
</li>
<li id="fn6">
<p>Toshinori Araki, Jun Furukawa, Yehuda Lindell, Ariel Nof, and Kazuma Ohara. High-throughput semi-honest secure three-party computation with an honest majority. In Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, An- drew C. Myers, and Shai Halevi, editors, ACM CCS 2016: 23rd Conference on Computer and Communications Security, pages 805–817, Vienna, Austria, October 24–28, 2016. ACM Press. <a href="#fnref6" class="footnote-backref">↩</a></p>
</li>
<li id="fn7">
<p>Yehuda Lindell and Ariel Nof. A framework for constructing fast MPC over arithmetic circuits with malicious adversaries and an honest-majority. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017: 24th Conference on Computer and Communications Security, pages 259–276, Dallas, TX, USA, October 31 – November 2, 2017. ACM Press. <a href="#fnref7" class="footnote-backref">↩</a></p>
</li>
<li id="fn8">
<p>Hendrik Eerikson, Marcel Keller, Claudio Orlandi, Pille Pullonen, Joonas Puura, and Mark Simkin. Use your brain! Arithmetic 3PC for any modulus with active security. In 1st Conference on Information-Theoretic Cryptography (ITC 2020). Schloss Dagstuhl-Leibniz-Zentrum für Informatik, 2020. <a href="#fnref8" class="footnote-backref">↩</a></p>
</li>
<li id="fn9">
<p>Octavian Catrina and Sebastiaan de Hoogh. Improved primitives for secure multiparty integer computation. In Juan A. Garay and Roberto De Prisco, editors, SCN 10: 7th Interna- tional Conference on Security in Communication Networks, volume 6280 of Lecture Notes in Computer Science, pages 182–199, Amalfi, Italy, September 13–15, 2010. Springer, Heidelberg, Germany. <a href="#fnref9" class="footnote-backref">↩</a></p>
</li>
<li id="fn10">
<p>Octavian Catrina and Amitabh Saxena. Secure computation with fixed-point numbers. In Radu Sion, editor, FC 2010: 14th International Conference on Financial Cryptography and Data Security, volume 6052 of Lecture Notes in Com- puter Science, pages 35–50, Tenerife, Canary Islands, Spain, January 25–28, 2010. Springer, Heidelberg, Germany. <a href="#fnref10" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BLAZE: Blazing Fast Privacy-preserving Machine Learning]]></title>
    <link href="https://weiviming.github.io/16477900515975.html"/>
    <updated>2022-03-20T23:27:31+08:00</updated>
    <id>https://weiviming.github.io/16477900515975.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>今天给大家带来的是Arpita Patra等人发表于NDSS'20上的文章《BLAZE: Blazing Fast Privacy-preserving Machine Learning》, 论文链接: <a href="https://arxiv.org/pdf/2005.09042.pdf">https://arxiv.org/pdf/2005.09042.pdf</a>.</p>
</blockquote>
<h2><a id="%E6%91%98%E8%A6%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>摘要</h2>
<p>本文提出的BLAZE是安全外包三服务器服务环境下可抵抗一个恶意敌手的环\(\mathbb Z_{2^\ell}\)上的PPML框架, 实现了公平性(当敌手获得输出时, 所有诚实参与方也能获得相同的输出). 利用独立于输入的预处理阶段, BLAZE基于输入的在线阶段非常高效, 主要原因在于:</p>
<ul>
<li>提出的3PC诚实大多数假设下在线阶段通信量与向量长度无关的恶意点积计算协议;</li>
<li>不需要像ABY3一样借助Ripple Carry Adders(RCA)来构造协议.</li>
</ul>
<img src="media/16477900515975/16528738368563.png" alt="image-20220319170717589" style="zoom:40%;" />
<h2><a id="%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础知识</h2>
<h3><a id="%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AC%A6%E5%8F%B7%E7%BA%A6%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安全模型与符号约定</h3>
<p>三服务器代理模式, 静态敌手至多腐化一个服务器. 为减少通信开销, 服务器之间通过一次性密钥设置生成预共享密钥, 通过伪随机生成函数(PRF)来生成关联随机性. 抗碰撞的Hash函数记为\(\mathsf H()\), 承诺记作\(\mathsf{Com}()\). 计算域为\(\mathbb Z_{2^\ell}=\mathbb Z_{2^{64}}, \mathbb Z_{2^1}\), 分别代表算术环和布尔环.</p>
<h3><a id="%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB%E8%AF%AD%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>秘密共享语义</h3>
<ul>
<li>\([\cdot]\)秘密共享: 秘密\(v\)在\(P_1\)和\(P_2\)两方下的加法秘密共享, \(P_1\)有\([v]_1\), \(P_2\)有\([v]_2\), 使得\(v=[v]_1+[v]_2\).</li>
<li>\(\langle\cdot\rangle\)秘密共享: 秘密\(v\)在三方下的秘密共享, (1)存在\([\lambda_v]_1,[\lambda_v]_2\in\mathbb Z_{2^\ell}\), 使得\(\lambda_v=[\lambda_v]_1+[\lambda_v]_2\), (2)\(P_0\)的份额为\(([\lambda_v]_1,[\lambda_v]_2)\), \(P_1\)的份额为\(([\lambda_v]_1,v+\lambda_v)\), \(P_2\)的份额为\(([\lambda_v]_2,v+\lambda_v)\).</li>
<li>\([[\cdot]]\)秘密共享: 秘密\(v\)在三方下的秘密共享, (1)\(v\)在\(\langle\cdot\rangle\)秘密共享, 即\(P_0\)有\(([\alpha_v]_1,[\alpha_v]_2)\), \(P_1\)有\(([\alpha_v]_1,\beta_v)\), \(P_2\)有\(([\alpha_v]_2,\beta_v)\), 其中\(\beta_v=v+\alpha_v\), \(\alpha_v=[\alpha_v]_1+[\alpha_v]_2\), (2) 存在\(\gamma_v\in\mathbb Z_{2^\ell}\), 使得\(P_1,P_2\)有\(\gamma_v\), 同时\(P_0\)有\(\beta_v+\gamma_v\).</li>
</ul>
<p>以上三种秘密共享可以总结为</p>
<img src="media/16477900515975/16528738411288.png" alt="image-20220319195925412" style="zoom:50%;" />
<p>由于三种秘密共享方案都是线性的, 因此加法和标量积的计算不需要交互. 此外, 容易看出任意两方通过交换对方所缺失的份额都可以重构出原始秘密\(v\).</p>
<h2><a id="%E5%9F%BA%E6%9C%AC%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本协议构造</h2>
<h3><a id="%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>秘密共享协议</h3>
<p>秘密共享协议\(\Pi_\mathsf{sh}(P_i,v)\): 允许\(P_i\)生成\(v\)的\([[\cdot]]\)份额. 总体思路是预处理阶段参与方使用预共享密钥生成部分份额, 然后在线阶段参与方发送没有的份额发送给其他两方参与方以满足秘密共享语义, 通过交换接收到的份额的hash值来判断两方收到的秘密份额是否一致, 若一致, 则参与方接受该份额, 否则直接中止协议(abort), 具体协议过程如下:</p>
<img src="media/16477900515975/16528738368607.png" alt="image-20220319200924679" style="zoom:50%;" />
<h3><a id="%E8%81%94%E5%90%88%E5%85%B1%E4%BA%AB%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>联合共享协议</h3>
<p>联合共享协议\(\Pi_\mathsf{jsh}(P_i,P_j,v)\): 允许两个参与方\(P_i,P_j\)联合生成他们的共同秘密\(v\)的\([[\cdot]]\)份额\([[v]]\). 总体思路是\(P_i\)执行秘密共享协议\(\Pi_\mathsf{sh}(P_i,v)\)生成\([[v]]\), \(P_j\)负责验证\(P_i\)生成的份额的正确性, 即发送份额的hash值给接收方进行验证一致性. 根据两方的不同可以分为三种情况, 具体协议过程如下:</p>
<img src="media/16477900515975/16528738368644.png" alt="image-20220319204146055" style="zoom:50%;" />
<p>若预处理阶段\(P_i\)和\(P_j\)都知道\(v\), 则可以不需要交互生成\([[v]]\), 具体方法是将相应份额设定为下表形式, 由于联合共享中的两方都知道秘密, 而其中至少一方是诚实的, 因此这样做是安全的.</p>
<img src="media/16477900515975/16528738365192.png" alt="image-20220319205207743" style="zoom:50%;" />
<h3><a id="%E7%A7%98%E5%AF%86%E9%87%8D%E6%9E%84%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>秘密重构协议</h3>
<p>秘密重构协议\(\Pi_\mathsf{rec}(\mathcal P,[[v]])\): 允许\(\mathcal P\)中的参与方从\([[v]]\)中重构秘密\(v\). 一方发送所缺失的份额给另一方, 第三方发送份额的hash值进行验证一致性, 若验证通过则可以重构秘密\(v\). 具体协议过程如下图4所示.</p>
<p>在外包场景中, 当要向用户\(P\)重构\(v\)时, \(P_0\)发送\(([[\alpha_v]]^\mathbf A, \mathsf{H}([[\alpha_v]]^\mathbf B))\), \(P_1\)发送\((\beta_v, \mathsf{H}([[\alpha_v]]^\mathbf A))\), \(P_2\)发送\(([[\alpha_v]]^\mathbf B, \mathsf{H}(\beta_v))\), \(P\)验证相应的hash值是否匹配, 若匹配则接受, 否则中止.</p>
<img src="media/16477900515975/16528738386599.png" alt="image-20220319210736130" style="zoom:50%;" />
<p>公平重构协议\(\Pi_\mathsf{frec}(\mathcal P,[[v]])\): 确保参与方\(\mathcal P\)公平地重构秘密\(v\), 这意味着当腐化方获得\(v\)时保证诚实参与方也能得到相同的\(v\). 具体实现原理与ASTRA相同, 都是通过承诺来完成, 协议过程如下:</p>
<img src="media/16477900515975/16528738377399.png" alt="frecp" style="zoom:50%;" />
<h3><a id="%E7%A7%98%E5%AF%86%E4%B9%98%E6%B3%95%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>秘密乘法协议</h3>
<p>秘密乘法协议\(\Pi_\mathsf{mult}(\mathcal P,[[x]],[[y]])\): 允许\(\mathcal P\)计算\(z=xy\)的秘密份额\([[z]]\).</p>
<p>为此, 先介绍半诚实安全模型下的秘密乘法协议: 在预处理阶段, \(P_0, P_1\)随机选取\([\alpha_z]_1\), \(P_0,P_2\)随机选取\([\alpha_z]_2\), \(P_1,P_2\)随机选取\(\gamma_z\). 然后\(P_0\)本地计算\(\Gamma_{xy}=\alpha_x\alpha_y\)并生成它在\(P_1,P_2\)之间的\([\cdot]\)份额. 因为</p>
\[\begin{aligned}
\beta_z&amp;=z+\alpha_z=xy+\alpha_z=(\beta_x-\alpha_x)(\beta_y-\alpha_y)+\alpha_z\\
&amp;=\beta_x\beta_y-\beta_x\alpha_y-\beta_y\alpha_x+\Gamma_{xy}+\alpha_z,
\end{aligned}\tag{1}
\]
<p>成立, 因此在在线阶段对于\(j\in\{1,2\}\), \(P_j\)可以本地计算\([\beta_z]_j=(j-1)\beta_x\beta_y-\beta_x[\alpha_y]_j-\beta_y[\alpha_x]_j+[\Gamma_{xy}]_j+[\alpha_z]_j\), 相互交换份额重构\(\beta_z\), 最后\(P_1\)计算并发送\(\beta_z+\gamma_z\)给\(P_0\), 完成半诚实安全下的秘密乘法计算. 正确性由公式\((1)\)保证.</p>
<p>但在恶意安全模型下, 上述秘密乘法协议存在如下三个问题:</p>
<ol>
<li>当\(P_0\)是腐化方时, 预处理阶段\(P_0\)生成\(\Gamma_{xy}\)的\([\cdot]\)份额可能是错误的, 即\(\Gamma_{xy}\neq\alpha_x\alpha_y\);</li>
<li>当\(P_1\)或\(P_2\)是腐化方时, 在线阶段发送给另一方的\(\beta_z\)的份额\([\beta_z]_j\)可能是错误的, 从而导致重构的\(\beta_z\)是错误的;</li>
<li>当\(P_1\)是腐化方时, 在线阶段发送给\(P_0\)的值\(\beta_z+\gamma_z\)是错误的.</li>
</ol>
<p>问题1和问题2可以规约到验证Beaver triple的正确性问题. 对于问题3, 为了验证\(P_1\)发送的\(\beta_z+\gamma_z\)的正确性, 只需\(P_2\)计算它的hash值并发送给\(P_1\)进行验证一致性, 若不然则中止.</p>
<p>下面解决问题2, \(P_0\)通过\(\beta_x^*=\beta_x+\gamma_x\)和\(\beta_y^*=\beta_y+\gamma_y\), 可计算\(\beta_z^*=-\beta_x^*\alpha_y-\beta_y^*\alpha_x+2\Gamma_{xy}+\alpha_z\). 令\(\chi=\gamma_x\alpha_y+\gamma_y\alpha_x-\Gamma_{xy}+\psi\), 则\(\beta_z^*\)可以写成如下形式:</p>
\[\begin{aligned}
\beta_z^*&amp;=-\beta_x^*\alpha_y-\beta_y^*\alpha_x+2\Gamma_{xy}+\alpha_z\\
&amp;=-(\beta_x+\gamma_x)\alpha_y-(\beta_y+\gamma_y)\alpha_x+2\Gamma_{xy}+\alpha_z\\
&amp;=(-\beta_x\alpha_y-\beta_y\alpha_x+\Gamma_{xy}+\alpha_z)-(\gamma_x\alpha_y+\gamma_y\alpha_x-\Gamma_{xy})\\
&amp;=(\beta_z-\beta_x\beta_y)-(\gamma_x\alpha_y+\gamma_y\alpha_x-\Gamma_{xy}+\psi)+\psi\\
&amp;=(\beta_z-\beta_x\beta_y+\psi)-\chi.
\end{aligned}
\]
<p>设\(P_1,P_2\)共同选取随机数\(\psi\in\mathbb{Z}_{2^\ell}\). 若\(P_0\)已知\(\chi\), 则可以发送\(\beta_z^*+\chi\)给\(P_1,P_2\). 然后\(P_1,P_2\)通过使用\(\beta_x,\beta_y\)和\(\chi\), 可以计算\(\beta_z-\beta_x\beta_y+\psi\overset{?}{=}\beta_z^*+\chi\)来验证\(\beta_z\)的正确性. 于是, 关键在于如何让\(P_0\)得到\(\chi\).</p>
<p>对\(j\in\{1,2\}\), 设\([\psi]_j\)是\(P_1,P_2\)使用预共享密钥本地生成的随机数, \(P_j\)可以本地计算\([\chi]_j=\gamma_x[\alpha_y]_j+\gamma_y[\alpha_x]_j-[\Gamma_{xy}]_j+[\psi]_j\). \(P_j\)可发送各自的\([\chi]_j\)给\(P_0\), 从而\(P_0\)可以重构出\(\chi=[\chi]_1+[\chi]_2\). 为了验证\(P_0\)正确地计算了\(\chi\), 可以利用如下关系:</p>
<p>设\(d=\gamma_x-\alpha_x\), \(e=\gamma_y-\alpha_y\), \(f=(\gamma_x\gamma_y+\psi)-\chi\), 若满足\(f=de\)当且仅当\(P_0\)正确计算了\(\chi\). 这是因为</p>
\[\begin{aligned}
de&amp;=(\gamma_x-\alpha_x)(\gamma_y-\alpha_y)=\gamma_x\gamma_y-\gamma_x\alpha_y-\gamma_y\alpha_x+\Gamma_{xy}\\
&amp;=(\gamma_x\gamma_y+\psi)-(\gamma_x\alpha_y+\gamma_y\alpha_x-\Gamma_{xy}+\psi)\\
&amp;=(\gamma_x\gamma_y+\psi)-\chi=f
\end{aligned}
\]
<p>如此, \(\chi\)的正确性规约到验证\((d,e,f)\)是否是一个Beaver triple. 这种方案还可以解决问题1, 因为当\(P_0\)是腐化方时, 实际上生成的是\(\Gamma_{xy}+\Delta\)的份额, 如此\(de=f+\Delta\neq f\).</p>
<p>BLAZE中的乘法协议的预处理阶段使用了[1]中提出的\(\langle\cdot\rangle\)共享的恶意安全乘法协议\(\Pi_\mathsf{mulZK}\), 具体过程协议如下:</p>
<img src="media/16477900515975/16528738373829.png" alt="image-20220320143006197" style="zoom:50%;" />
<p>给定\([[x]],[[y]]\), 服务器按如下方法本地计算\(\langle d\rangle,\langle e\rangle\): 在执行协议\(\Pi_\mathsf{mulZK}(\mathcal P,d,e)\)时, \(P_0\)得到\(([\lambda_f]_1,[\lambda_f]_2)\), \(P_1\)得到\(([\lambda_f]_1,f+\lambda_f)\), \(P_2\)得到\(([\lambda_f]_2,f+\lambda_f)\). 然后服务器将\([\chi]\)映射为\([\lambda_f]\), 将\(\gamma_x\gamma_y+\chi\)映射为\(f+\lambda_f\), 并按如下提取所需值为:</p>
\[[\chi]_1=[\lambda_f]_1 ,\quad [\chi]_2=[\lambda_f]_2\qquad\rightarrow\qquad \chi=[\lambda_f]_1+[\lambda_f]_2
\]
\[\gamma_x\gamma_y+\psi=f+\lambda_f\qquad \rightarrow \qquad \psi=f+\lambda_f-\gamma_x\gamma_y
\]
\[[\gamma_{xy}]_j=\gamma_x[\alpha_y]_j+\gamma_y[\alpha_x]_j+[\psi]_j-[\chi]_j,\quad j\in\{1,2\}.
\]
<p>其中, \([\psi]\)由\(P_1,P_2\)通过共同选取随机数\(r\in\mathbb{Z}_{2^\ell}\), 并设定\([\psi]_1=r, [\psi]_2=\psi-r\), 不需要交互即可生成. 则\(P_1,P_2\)有\([\Gamma_{xy}]=[\alpha_x\alpha_y]\). 这因为</p>
\[\begin{aligned}
\Gamma_{xy}&amp;=\gamma_x\alpha_y+\gamma_y\alpha_x+\psi-\chi\\
&amp;=(d+\lambda_d)\lambda_e+(e+\lambda_e)\lambda_d+(f+\lambda_f-\gamma_x\gamma_y)-\lambda_f\\
&amp;=(d+\lambda_d)(e+\lambda_e)-de+\lambda_d\lambda_e+(f-\lambda_x\lambda_y)\\
&amp;=\gamma_x\gamma_y-f+\lambda_d\lambda_e+(f-\gamma_x\gamma_y)=\lambda_d\lambda_e=\alpha_x\alpha_y.
\end{aligned}
\]
<p>由于只规约到单个乘法三元组的验证问题, 因此与ASTRA相比, BLAZE将预处理阶段的通信开销从ASTRA的21个环元素降低到3个环元素, 进一步提升了性能. 秘密乘法协议过程如下:</p>
<img src="media/16477900515975/16528738372292.png" alt="Mult" style="zoom:50%;" />
<h3><a id="%E6%AF%94%E7%89%B9%E6%8A%BD%E5%8F%96%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>比特抽取协议</h3>
<p>比特抽取协议\(\Pi_\mathsf{bitext}(\mathcal P,[[v]])\): 给定算术份额\([[v]]\), 允许\(\mathcal P\)中的参与方计算\(v\)的最高有效位(符号位)的布尔共享份额\([[\cdot]]^\mathbf B\). 本文中通过混淆电路来构造常数轮的比特抽取协议.</p>
<p>设\(GC=(u_1,u_2,u_3,u_4,u_5)\)代表输入为\(u_1,u_2,u_3\in\mathbb Z_{2^\ell},u_4,u_5\in\{0,1\}\), 输出为\(y=\mathsf{msb}(u_1-u_2-u_3)\oplus u_4\oplus u_5\)的混淆电路. 令\(u_1=\beta_v,u_2=[\alpha_v]_1,u_3=[\alpha_v]_2\), 使得\(u_1-u_2-u_3=v\). 令\(u_4=r_1,u_5=r_2\), 其中\(r_1\)代表\(P_0\)和\(P_1\)共同选取的随机比特, \(r_2\)代表\(P_0\)和\(P_2\)共同选取的随机比特. 具体协议过程如下:</p>
<img src="media/16477900515975/16528738372258.png" alt="image-20220320145143810" style="zoom:50%;" />
<h3><a id="%E6%AF%94%E7%89%B9%E8%BD%AC%E6%8D%A2%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>比特转换协议</h3>
<p>比特转换协议Bit2A\(\Pi_\mathsf{bit2A}(\mathcal P,[[b]]^\mathbf B)\): 给定单个比特\(b\)的布尔份额\([[\cdot]]^\mathbf B\), 允许\(\mathcal P\)中的参与方得到\(b\)的算术共享份额\([[b]]^\mathbf A\). 记比特\(b\)在\(\mathbb Z_{2^\ell}\)上的值为\((b)^\mathbf A\). 设计思想是基于等式</p>
\[(b)^\mathbf A=(\beta_b\oplus\alpha_b)^\mathbf A=(\beta_b)^\mathbf A+(\alpha_b)^\mathbf A-2(\beta_b)^\mathbf A(\alpha_b)^\mathbf A.
\]
<p>协议的具体过程如下:</p>
<img src="media/16477900515975/16528738380452.png" alt="image-20220320155246874" style="zoom:50%;" />
<h3><a id="%E7%82%B9%E7%A7%AF%E8%AE%A1%E7%AE%97%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>点积计算协议</h3>
<p>点积计算协议\(\Pi_\mathsf{dotp}(\mathcal P,\{[[x_i]],[[y_i]]\}_{i\in[n]})\): 给定长度为\(n\)的向量份额\([[\vec{x}]]\)和\([[\vec y]]\), 计算\(z=\vec{x}\odot\vec{y}\)的\([[\cdot]]\)份额.</p>
<p>通常做法是调用\(n\)次乘法协议\(\Pi_\mathsf{mult}\), 第\(i\)次计算\(z_i=x_i\cdot y_i\)的份额, 最后本地累加即可, 如此通信量将与向量长度\(n\)线性相关.</p>
<p>本文对点积优化的关键在于不再分开重构每个\(\beta_z^*\)来计算\(\beta_z\), \(P_1,P_2\)本地计算\([\beta_z]=[\beta_{z_1}]+\cdots+[\beta_{z_n}]\)并重构\(\beta_z\); 此外, 对每个\(z_i\), \(P_0\)可以把所有的\(\beta_{z_i}^*\)合并为单个\(\beta_z^*\), 从而发送单个\(\beta_z^*\)给\(P_1,P_2\)进行验证. 具体来说, \(P_0\)计算\(\beta_z^*=\sum_{i=1}^n\beta_z^*\)并发送它的Hash值给\(P_1\)和\(P_2\), 然后\(P_1\)和\(P_2\)可以交叉检验它与\(\beta_z-\sum_{i=1}^n(\beta_{x_i}\cdot\beta_{y_i}-\psi_i)\)的Hash值的一致性. 具体协议过程如下:</p>
<img src="media/16477900515975/16528738384630.png" alt="image-20220320171631561" style="zoom:50%;" />
<h3><a id="%E5%AE%9A%E7%82%B9%E6%88%AA%E6%96%AD%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定点截断协议</h3>
<p>当进行秘密乘法后精度将翻倍, 为防止多次乘法后造成溢出需要对每次乘法后的秘密份额进行截断. 设定点数精度为\(d\), 本文中的截断协议设计思路同ABY3, 但主要的不同在于预处理阶段随机截断对\((r,r^d)\)的生成方法不依赖于RCA: \(P_0,P_1\)随机选取\(R_1\in\mathbb Z_{2^\ell}\), \(P_0,P_2\)随机选取\(R_2\in\mathbb Z_{2^\ell}\), 然后\(P_0\)本地计算\(r=R_1+R_2\)并截断得到\(r^d\). 注意到\(r=2^dr^d+r_d\), 其中\(r_d\)表示\(r\)的后\(d\)个比特组成的环元素, 其他位置为零. 然后, \(P_0\)执行\(\Pi_\mathsf{sh}\)生成\([[r^d]]\). 为了验证\(P_0\)分享的份额的正确性, \(P_1,P_2\)计算\(a=(r-2^dr^d-r_d)\)的\([\cdot]\)份额, 给定\(([r],[[r^d]])\), 验证\(a=0\)是否成立. 具体协议过程如下:</p>
<img src="media/16477900515975/16528738379420.png" alt="image-20220320191700465" style="zoom:50%;" />
<p>正确性: 只需说明\(u=v\), 其中\(u=[r]_1-2^d[r^d]_1-[r_d]_1\), \(v=2^d[r^d]_2+[r_d]_2-[r]_2\). 因为</p>
\[\begin{aligned}
r&amp;=2^dr^d+r_d\\
[r]_1+[r]_2&amp;=2^d([r^d]_{1}+[r^d]_2)+([r_d]_1+[r_d]_2)\\
[r]_1-2^d[r^d]_1-[r_d]_1&amp;=2^d[r^d]_2+[r_d]_2-[r]_2\\
u&amp;=v.
\end{aligned}
\]
<h3><a id="%E7%82%B9%E7%A7%AF%E6%88%AA%E6%96%AD%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>点积截断协议</h3>
<p>点积截断协议\(\Pi_\mathsf{dotpt}(\mathcal P,\{[[x_i]],[[y_i]]\}_{i\in[n]})\): 给定长度为\(n\)的向量份额\([[\vec{x}]]\)和\([[\vec y]]\), 计算\(z=\vec{x}\odot\vec{y}\)截断后\(z^d\)的\([[\cdot]]\)份额.</p>
<p>预处理阶段同\(\Pi_\mathsf{dotp}\), 参与方执行\(\Pi_\mathsf{trgen}\)生成截断对\((r,r^d)\). 在线阶段, \(P_1,P_2\)本地计算\((z-r)\)的\([\cdot]\)份额, 然后\(P_1,P_2\)本地截断\((z-r)\)得到\((z-r)^d\)并通过\(\Pi_\mathsf{jsh}\)协议生成\([[\cdot]]\)份额. 最后, 参与方本地计算\([[z]]=[[(z-r)^d]]+[[r^d]]\)并进行一致性验证. 这里为了确保计算的正确性, 与上述点积计算协议不同, \(P_0\)计算的部分被改为\((z-r)^*\)而不是\(\beta_z^*\).</p>
<p>具体协议过程如下:</p>
<img src="media/16477900515975/16528738403047.png" alt="BLAZEdotpt" style="zoom:50%;" />
<h3><a id="%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安全比较协议</h3>
<p>给定\([[x]],[[y]]\), 安全比较协议计算\((x&lt;y)\)的真值, 即需要抽取\(v=x-y\)的符号位. 为此, 首先本地计算\([[v]]=[[x]]-[[y]]\), 然后使用\(\Pi_\mathsf{bitext}([[v]])\)抽取符号位的布尔份额. 如果需要算术份额, 则再调用\(\Pi_\mathsf{bit2A}\)进行比特转换即可.</p>
<h3><a id="%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>激活函数协议</h3>
<ol>
<li>ReLU激活函数计算协议\(\Pi_\mathsf{relu}(\mathcal P, [[v]])\): 即计算\(\mathsf{relu}(v)=\mathsf{max}(0,v)=\bar{b}\cdot v\), 其中\(b=1\)当且仅当\(v&lt;0\), \(\bar{b}\)是\(b\)的补. 首先参与方执行\(\Pi_\mathsf{bitext}([[v]])\), 得到\([[b]]^\mathbf B\), 然后参与方通过设定\(\beta_{\bar b}=1\oplus\beta_b\), 本地计算\([[\bar b]]^\mathbf B\). 接着执行\(\Pi_\mathsf{bit2A}([[b]]^\mathbf B)\)生成\([[\bar b]]\). 最后, 通过\(\Pi_\mathsf{mult}\)计算\([[\bar bv]]\).</li>
<li>Sigmoid激活函数计算协议\(\Pi_\mathsf{sig}(\mathcal P,[[v]])\): 同SecureML分段函数近似法, 将Sigmoid函数表示为\(\mathsf{sig}(v)=\bar{b}_1b_2(v+1/2)+\bar{b}_2\), 其中, 当\(v+1/2&lt;0\)时, \(b_1=1\); 当\(v-1/2&lt;0\)时, \(b_2=1\). 具体协议过程与\(\Pi_\mathsf{relu}\)协议类似.</li>
</ol>
<h2><a id="%E5%AE%9E%E9%AA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实验</h2>
<p>本文主要以预处理阶段和在线阶段的吞吐量(throughput)为不同方案的对比基准. 下面仅提供部分实验截图.</p>
<p>不同带宽下的ABY3与BLAZE点积协议吞吐量对比:</p>
<img src="media/16477900515975/16528738382491.png" alt="image-20220320213734911" style="zoom:50%;" />
<p>线性回归与逻辑回归推理部分的吞吐量对比:</p>
<img src="media/16477900515975/16528738384545.png" alt="image-20220320213954206" style="zoom:50%;" />
<img src="media/16477900515975/16528738387735.png" alt="image-20220320214039017" style="zoom:50%;" />
<img src="media/16477900515975/16528738387637.png" alt="image-20220320214414667" style="zoom:50%;" />
<img src="media/16477900515975/16528738389665.png" alt="image-20220320214456070" style="zoom:50%;" />
<img src="media/16477900515975/16528738387813.png" alt="image-20220320222840218" style="zoom:50%;" />
<p>与ASTRA对比:</p>
<img src="media/16477900515975/16528738390711.png" alt="image-20220320222929474" style="zoom:50%;" />
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>BLAZE框架是环\(\mathbb Z_{2^\ell}\)上至多容忍一个恶意敌手的3PC隐私保护机器学习框架, 是对ASTRA框架的进一步提升, 且与ASTRA一样实现了公平性, 核心思想在于当发现恶意行为时参与方直接中止协议. 与ABY3相比, BLAZE摆脱了对RCA的依赖, 此外, 所设计恶意点积协议在线阶段通信开销与向量长度无关, 但离线阶段仍有关, 有待进一步优化. 与ASTRA相比, BLAZE极大降低了预处理阶段乘法协议的通信开销(21个环元素 VS 3个环元素). 实验发现, BLAZE在不同机器学习任务下的吞吐量都远高于ABY3的方案.</p>
<h2><a id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考文献</h2>
<p>[1] D. Boneh, E. Boyle, H. Corrigan-Gibbs, N. Gilboa, and Y. Ishai, “Zero-knowledge proofs on secret-shared data via fully linear pcps,” in CRYPTO, 2019, pp. 67–97.</p>
<p>[2] P. Mohassel and P. Rindal, “ABY3: A mixed protocol framework for machine learning,” in ACM CCS, 2018, pp. 35–52.</p>
<p>[3] H. Chaudhari, A. Choudhury, A. Patra, and A. Suresh, “ASTRA: High-throughput 3PC over Rings with Application to Secure Prediction,” in ACM CCSW, 2019, pp. 81–92.</p>
<p>[4] P. Mohassel and Y. Zhang, “SecureML: A system for scalable privacy-preserving machine learning,” in IEEE S&amp;P, 2017, pp. 19–38.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cheetah: Lean and Fast Secure Two-Party Deep Neural Network Inference]]></title>
    <link href="https://weiviming.github.io/16460285618722.html"/>
    <updated>2022-02-28T14:09:21+08:00</updated>
    <id>https://weiviming.github.io/16460285618722.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>今天给大家带来的是来自于<em>USENIX Security'22</em>的一篇文章Cheetah: Lean and Fast Secure Two-Party Deep Neural Network Inference, 作者是来自阿里安全双子座实验室的洪澄博士团队, 文章链接如下: <a href="https://eprint.iacr.org/2022/207">https://eprint.iacr.org/2022/207</a>.</p>
</blockquote>
<h2><a id="%E6%91%98%E8%A6%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>摘要</h2>
<p>2PC-NN安全推理与实际应用之间仍存在较大性能差距, 因此只适用于小数据集或简单模型. 本文通过仔细设计DNN, 基于格的同态加密、VOLE类型的不经意传输和秘密共享, 提出了一个2PC-NN推理系统Cheetah, 比CCS'20的CrypTFlow2技术开销小的多, 计算效率更快, 通信效率更高. 主要贡献有两点:</p>
<ul>
<li>基于格的同态加密的协议可在不进行任何昂贵同态rotation操作的情况下评估线性层;</li>
<li>提出了非线性函数的几个精简且通信高效的原语.</li>
</ul>
<p>本文的方案在ResNet50神经网络下在WAN进行端到端安全推理需要不到2.5分钟和2.3G通信量, 分别优于CrypTFlow2约5.6倍和12.9倍.</p>
<p>具体代码已在Github开源: <a href="https://github.com/Alibaba-Gemini-Lab/OpenCheetah">https://github.com/Alibaba-Gemini-Lab/OpenCheetah</a>.</p>
<h2><a id="%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>技术概览</h2>
<p>现有的大多基于HE的方案构造2PC-NN协议存在两大痛点: 一是为使用同态SIMD均摊同态运算操作, 只能在\(\mathbb Z_p\)上工作, 需要额外借助CRT才能支持\(\mathbb Z_{2^\ell}\), 造成额外的同态计算开销, 降低了效率; 二是NN推理的计算中的卷积和矩阵计算涉及大量的同态rotation操作, 是主要的性能瓶颈. Cheetah提出的方案不需要使用SIMD和rotation, 从而避免了这两个问题.</p>
<p>2PC-NN的非线性计算, 如比较、截断等一直是影响安全推理速度的一大原因. 例如CrypTFlow2中的截断协议通信开销超过50%. VOLE类型OT协议的出现可以更新现有OT扩展, 用于非线性函数的两方安全评估, 但直接应用VOLE类型OT协议并不能达到最佳性能. 本文中优化了以下两点:</p>
<ul>
<li>CrypTFlow2中的截断协议被设计为消除两个概率误差: 溢出误差\(e_0\)和尾部误差\(e_1\), 其中\(\mathrm{Pr}(|e_0|=1)=0.5, \mathrm{Pr}(0&lt;|e_1|&lt;2^{\ell})&lt;\varepsilon\). 其中\(e_0\)对安全推理的结果影响极大, 但\(e_1\)造成的影响几乎可以忽略. 基于此, 可以在不考虑\(e_1\)的情况下, 设计更高效的截断协议来消除\(e_0\).</li>
<li>通过使用VOLE类型OT协议, 在已知最高有效位的前提下, Cheetah实现了更高效的截断协议.</li>
</ul>
<p>Cheetah与最先进的2PC协议复杂度比较如表1.</p>
<img src="media/16460285618722/16528725986320.png" alt="image-20220224205920181" style="zoom:50%;" />
<h2><a id="%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>预备知识</h2>
<h3><a id="%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>威胁模型</h3>
<p>Cheetah是半诚实两方计算设定下构造的. 两方分别为Alice(作为Server)和Bob(作为Client). 在安全推理中, Alice持有DNN, Bob持有神经网络的输入, 如图像. 协议允许Bob获得神经网络架构信息和推理输出, 而Alice根据应用场景的不同要么没有输出, 要么得到安全推理结果.</p>
<h3><a id="%E7%AC%A6%E5%8F%B7%E7%BA%A6%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>符号约定</h3>
<p>\([[n]]\)表示集合\(\{0,1,\cdots,n-1\}\). 多项式表示为\(\hat{a}\), 其第\(j\)个系数表示为\(\hat{a}[j]\). 多维张量表示为\(\mathbf T\).</p>
<p>多项式算术(Polynomial Arithmetic): 设\(N\)是二次幂数, \(q&gt;0\), 给定整系数多项式\(\hat{a},\hat{b}\in\mathbb A_{N,q}=\mathbb Z_{q}[X]/(X^N+1)\), 在\(\mathbb A_{N,q}\)上的乘积\(\hat{d}=\hat{a}\cdot\hat{b}\)定义如下:</p>
\[\hat{d}[i]=\sum_{0\leq j\leq i}\hat{a}[j]\hat{b}[i-j]-\sum_{i&lt;j&lt;N}\hat{a}[j]\hat{b}[N+j-i]\bmod q.\tag{1}
\]
<p>这基于事实\(X^N\equiv -1\bmod X^N+1\).</p>
<h3><a id="%E5%9F%BA%E4%BA%8E%E6%A0%BC%E7%9A%84%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基于格的同态加密</h3>
<p>Cheetah使用了两种基于格的方案, 即基于LWE和基于RLWE的同态加密方案. 两种方案共享参数: \(\mathsf{HE.pp}=\{N,\sigma,q,p\}\): \(q,p\in\mathbb Z, q\gg p&gt;0\), 明文模数\(p\)可不为素数. 以往的方案中通常设定\(p\)为满足\(p\equiv1\bmod2N\)的素数以使用SIMD技术均摊同态乘法的开销, 但是Cheetah不需要使用SIMD，因而不需要\(p\)是素数.</p>
<p>RLWE同态加密方案的私钥为\(\mathsf{sk}=\hat{s}\in\mathbb A_{N,q}\), 与之关联的公钥为\(\mathsf{pk}=(\hat{u}\cdot\hat{s}+\hat{e}_0,\hat{u}_0)\), 其中\(\hat{u}_0\in\mathbb A_{N,q}\)是均匀随机的, \(\hat{e}_0\in\mathbb A_{N,q}\)的系数采样自\(\chi_\sigma\)服从标准差为\(\sigma\)的离散高斯分布. 设明文为多项式\(\hat{m}\in\mathbb A_{N,q}\), 则</p>
<ul>
<li>加密: \((\hat{b},\hat{a})=\mathsf{RLWE}_\mathsf{pk}^{N,q,p}(\hat{m})=(\lfloor\frac{q}{p}\hat{m}\rceil+\hat{e},0)-\hat{u}\cdot\mathsf{pk}\in\mathbb A_{N,p}^2\), 其中\(\hat{e}\in\mathbb A_{N,q}\)的系数采样自\(\chi_\sigma\), \(\hat{u}\in\mathbb A_{N,q}\)的系数均匀随机选取自\(\{0,\pm1\}\);</li>
<li>解密: \(\mathsf{RLWE}_\mathsf{sk}^{-1}(\hat{b},\hat{a})=\lfloor\frac{p}{q}(\hat{b}+\hat{a}\cdot\hat{s})\rceil\equiv\hat{m}\bmod p\).</li>
</ul>
<p>LWE同态加密方案的密钥为向量\(\mathbf s\in\mathbb{Z}_q^N\), 设明文为\(m\in\mathbb Z_{p}\), 则</p>
<ul>
<li>加密: \((b,\mathbf a)=\mathsf{LWE}_\mathbf s^{N,q,p}(m)\in\mathbb Z_{p}^{N+1}\);</li>
<li>解密: \(\mathsf{LWE}_\mathbf{s}^{-1}(b,\mathbf a)=\lfloor\frac{p}{q}(b+\mathbf a^\top\mathbf s)\rceil\equiv m\bmod p\).</li>
</ul>
<p>为统一记号, 对所有\(j\in[[N]]\), 令LWE的密钥为\(\mathbf s[j]=\hat{s}[j]\)以统一LWE和RLWE密文. 下文中记LWE的加密为\(\mathsf{LWE}_\mathsf{sk}^{n,q,p}(\hat{m})\).</p>
<p>RLWE方案支持同态加减法、常量积运算以及抽取(extract). 抽取是指, 给定RLWE密文\((\hat{b},\hat{a})=\mathsf{RLWE}_\mathsf{pk}^{N,q,p}(\hat{m})\), 可以抽取\(\hat{m}\)的第\(k\)个系数为LWE密钥\(\mathsf{sk}\)下\(\hat{m}[k]\)的合法密文\((b,\mathbf a)=\mathsf{Extract}((\hat{b},\hat{a}),k)\).</p>
<h3><a id="%E6%89%A9%E5%B1%95simd%E7%9A%84packing%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展: SIMD的Packing操作</h3>
<p>SIMD指的是把一系列数通过中国剩余定理(CRT)打包(pack)到多项式中, 使一次多项式乘法计算可以完成多次明文乘法. 它的计算域必须为素数域\(\mathbb Z_p\). 下面举例说明SIMD中的Packing操作.</p>
<ul>
<li>如何将需要计算的数据编码为多项式?
<ul>
<li>
<p>\(x^n+1\)可以表示为\(n\)个多项式的积: \(x^n+1=(x+a_1)(x+a_2)\cdots(x+a_n)\bmod p\)</p>
<ul>
<li>例: 设\(p=17\), 多项式阶数\(n=2\), 则\(x^2+1=x^2-17x+52\bmod17=(x-4)(x-13)\bmod 17\).</li>
</ul>
</li>
<li>
<p>\(f(x)\bmod(x^n+1)\)可以表示为\(n\)个整数: \(x_i=f(x)\bmod(x+a_i)\), 即\(f(x)\bmod(x^n+1)\)“pack”了\(x_i\).</p>
<ul>
<li>例: \(x\bmod(x^2+1)\)可以表示为\(x\bmod(x-4)\)和\(x\bmod(x-13)\), 即\(x\bmod(x^2+1)\)“pack”了\(4\)和\(13\).</li>
</ul>
</li>
</ul>
</li>
<li>给定\(n\)个整数, 可以通过CRT找到对应的\(f(x)\)来编码它们
<ul>
<li>例: \(2x-7\)“pack”了\(1\)和\(2\), 因为\(2x-7\bmod(x-4)=1, 2x-7\bmod(x-13)=2\).</li>
</ul>
</li>
<li>Packing在模\(p\)上依然保持同态性:
<ul>
<li>加法: \(x+(2x-7)\)“pack”了\(5\)和\(15\), 因为\(3x-7\bmod(x-4)=5\), \(3x-7\bmod(x-13)=15\bmod17\).</li>
<li>乘法: \(x\cdot(2x-7)\)“pack”了\(4\)和\(9\), 因为\(2x^2-7x\bmod(x^2+1)=-7x-2\), \(-7x-2\bmod(x-4)=4\), \(-7x-2\bmod(x-13)=9\bmod 17\).</li>
</ul>
</li>
<li>SIMD: 一次多项式运算完成了\(n\)次整数运算.</li>
</ul>
<blockquote>
<p>Cheetah中没有使用SIMD, 因此不需要\(p\)为素数. (感谢洪澄老师对SIMD扩展部分的补充)</p>
</blockquote>
<h3><a id="%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不经意传输</h3>
<p>Cheetah的协议非线性计算依赖于Boyle等人于CCS'19提出的VOLE类型OT协议——Silent OT extension<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup>, 它通过低通信量、与输入无关的设定以及纯本地计算两个阶段生成大量Random OT correlation, 而Ferret<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup>和Silver<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup>是Silent OT extension的两个更高效的变种.</p>
<h2><a id="%E7%BA%BF%E6%80%A7%E5%B1%82%E7%9A%842pc%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线性层的2PC协议</h2>
<p>全联接层(FC)、卷积层(CONV)、批标准化层(BN)都可以写成一系列内积的形式. Cheetah的线性协议不需要使用SIMD和同态rotation, 其关键在于观察到对多项式乘法公式(1), 若适当地排列多项式系数, 则可以将其视为一系列内积运算. 为此, Cheetah中针对不同层的功能\(\mathcal F\), 通过构造一对自然映射\((\pi_\mathcal F^i,\pi_\mathcal F^w)\)分别用于排列\(\mathcal F\)的输入和权重的多项式系数, 对于任意\(p&gt;1\), 这两个映射是良定义的(well-defined), 这使协议直接接受来自二次幂环\(\mathbb Z_{2^\ell}\)的秘密份额输入. 相比之下, 以往的工作仅支持接受来自有限域\(\mathbb Z_p\)的秘密份额输入, 为支持接受来自二次幂环\(\mathbb Z_{2^\ell}\)的秘密份额输入, 需要借助中国剩余定理将明文模数扩展到大约\((2\ell+1+40)\)比特来实现40比特的统计安全性, 导致计算量和通信量增加\(O((2\ell+1+40)/\ell)\)的倍数.</p>
<h3><a id="%E5%85%A8%E8%81%94%E6%8E%A5%E5%B1%82fc%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全联接层(FC层)</h3>
<p>FC层输入为向量\(\mathbf v\in\mathbb F^{n_i}\), 参数为权重矩阵\(\mathbf W\in\mathbb F^{n_o\times n_i}\)和偏置向量\(\mathbf b\in\mathbb F^{n_0}\), 输出为向量\(\mathbf u=\mathbf{Wv}+\mathbf b\in\mathbb F^{n_o}\), 这里的\(\mathbb F=\mathbb Z_p\). 因此, FC的核心在于计算矩阵向量乘积\(\mathbf u=\mathbf{Wv}\), 这可以分解为向量内积运算, 从而可以使用多项式算术来计算. 直观上看, 两个阶为\(N\)的多项式相乘, 所得结果多项式的\(N-1\)阶的系数是两系数向量反序作内积.</p>
<p>设\(n_on_i\leq N\), 定义两个映射: \(\pi_\mathrm{fc}^w:\mathbb Z_p^{n_o\times n_i}\mapsto\mathbb A_{N,p}\)和\(\pi_\mathrm{fc}^i: \mathbb Z_p^{n_i}\mapsto\mathbb A_{N,p}\):</p>
\[\hat{v}=\pi_\mathrm{fc}^i(\mathbf v), \text{其中}~\hat{v}[j]=\mathbf v[j],\\
\hat{w}=\pi_\mathrm{fc}^w(\mathbf W), \text{其中}~\hat{w}[i\cdot n_i+n_i-1-j]=\mathbf W[i,j]. \tag{4}
\]
<p>其中, \(i\in[[n_o]],j\in[[n_i]]\), 且\(\hat{v},\hat{w}\)的所有其他系数均设为0. 则多项式的乘积\(\hat{u}=\hat{w}\cdot\hat{v}\in\mathbb A_{N,p}\)的某些系数直接给出了\(\mathbf{Wv}\equiv\mathbf u\bmod p\).</p>
<p><strong>性质1</strong>: 给定两个多项式\(\hat{v}=\pi_\mathrm{fc}^{i}(\mathbf v),\hat{w}=\pi_\mathrm{fc}^w(\mathbf W)\in\mathbb A_{N,p}\), 通过环\(\mathbb A_{N,p}\)上的乘积\(\hat{u}=\hat{v}\cdot\hat{w}\)可以对\(\mathbf{Wv}\equiv\mathbf u\bmod p\)进行求解, 即对于所有\(i\in[[n_o]]\), \(\mathbf u[i]=\hat{u}[i\cdot n_i+n_i-1]\).</p>
<p>证明: 对于每个\(i\in[[n_o]]\), 记\(\tilde{n}_i=i\cdot n_i+n_i-1\). 根据公式(1)的定义以及当\(j\geq n_i\)时, \(v[j]=0\), 我们有</p>
\[\hat{u}[\tilde{n}_i]=\sum_{0\leq j&lt;n_i}\hat{v}[j]\hat{w}[n_i-j]=\sum_{0\leq j&lt;n_i}\mathbf v[j]\mathbf{W}[i,j]=\mathbf{u}[i].
\]
<p>根据性质1, \(\hat{u}\)的系数除了\(\hat{u}[\tilde{n}_i]\)外, 会泄漏\(\mathbf{Wv}\)的额外信息, 为此, Alice还使用抽取函数\(\mathsf{Extract}(\cdot)\)从\(\hat{u}\)中抽取所需的系数. 文章举例如图3.</p>
<blockquote>
<p>SIMD中把一系列数通过CRT打包(pack)到多项式中, 使一次多项式乘法计算可以完成多次明文乘法, 而Cheetah中则直接把这些数写在多项式系数上, 虽然这样做会导致不能通过一次多项式乘法完成多次明文乘法(多项式相乘后系数会变乱), 但刚好能做卷积, 如图3. (感谢洪澄老师的说明)</p>
</blockquote>
<img src="media/16460285618722/16528725986353.png" alt="image-20220224202332806" style="zoom:33%;" />
<p>若\(n_on_i&gt;N\), 则将权重矩阵切分为\(\bar{n}_o\times\bar{n}_i\)子矩阵, 使得\(\bar{n}_o\bar{n}_i\leq N\), 这里\(\bar{n}_o\)和\(\bar{n}_i\)是只要满足约束, 可自由选取的公开参数. 若\(n_i\nmid\bar{n}_i\)或\(n_o\nmid\bar{n}_o\), 则通过Zero padding用0补足, 从而将\(n_o\times n_i\)矩阵乘法转化为更小的\(\bar{n}_o\times\bar{n}_i\)矩阵乘法. 具体协议如图2.</p>
<img src="media/16460285618722/16528725986393.png" alt="image-20220224205031777" style="zoom:50%;" />
<p>复杂度分析: Bob加密并发送了\(n_i'\)个RLWE密文给Alice. Alice计算了\(n_o'n_i'=O(n_on_i/N)\)个同态乘法和加法. Alice发送\(n_o\)个LWE密文给Bob解密. 可通过优化压缩通信量为\(O((n_o+n_o'N)\log_2q)\)比特.</p>
<h3><a id="%E5%8D%B7%E7%A7%AF%E5%B1%82conv%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>卷积层(CONV层)</h3>
<p>\(\mathbb F\)上的二维步幅卷积\(\mathsf{Conv2D}(\mathbf T,\mathbf K;s)\)作用在一个步幅为\(s&gt;0\)、核为四维张量\(\mathbf K\in\mathbb F^{M\times C\times h\times h}\)的三维张量\(\mathbf T\in\mathbb F^{C\times H\times W}\)上, 生成三维张量\(\mathbf T'\in\mathbb F^{M\times H'\times W'}\), 其中\(H'=\lfloor(H-h+s)/s\rfloor, W'=\lfloor(W-h+s)/s\rfloor\), \(M\)表示卷积中使用的核数, \(h\)表示核的尺寸. 从数学的观点来看, 二维步幅卷积可以看作对输出张量\(\mathbf T'\)的每个位置\((c',i',j')\)计算权重和:</p>
\[\mathbf{T}^{\prime}\left[c^{\prime}, i^{\prime}, j^{\prime}\right]=\sum_{c \in[[C]] \atop l, l^{\prime} \in[[h]]} \mathbf{T}\left[c, i^{\prime} s+l, j^{\prime} s+l^{\prime}\right] \mathbf{K}\left[c^{\prime}, c, l, l^{\prime}\right]. \tag{2}
\]
<p>首先考虑最简单的情况\(H=W=h, M=1\), 此时输入张量的形状与卷积核相同, 则公式(2)的计算变为逐行逐通道连接\(\mathbf T\)和\(\mathbf K\)的两个向量的内积. 通常情况下, 可以将二维卷积计算看作一系列\(h^2\)个值的内积运算.</p>
<p>设\(MCHW\leq N\), 定义映射\(\pi_\mathrm{conv}^i:\mathbb Z_p^{C\times H\times W}\mapsto\mathbb A_{N,p}\)和\(\pi_\mathrm{conv}^w:\mathbb Z_p^{M\times C\times h\times h}\mapsto\mathbb A_{N,p}\):</p>
\[\hat{t}=\pi_\mathrm{conv}^i(\mathbf T)~\mathrm{使得}~\hat{t}[cHW+iW+j]=\mathbf T[c,i,j] \\
\hat{k}=\pi_\mathrm{conv}^w(\mathbf K)~\mathrm{使得}~\hat{k}[O-c'CHW-cHW-lW-l']=\mathbf K[c',c,l,l'],\tag{5}
\]
<p>其中\(O=HW(MC-1)+W(h-1)+h-1\), 且\(\hat{t}\)和\(\hat{k}\)的所有其他系数设为0. 则多项式的乘积\(\hat{t}\cdot\hat{k}\in\mathbb A_{N,p}\)的某些系数直接给出了二维卷积的结果. 类似于FC, Alice需要使用抽取函数保护可能的泄漏. 具体协议见图4.</p>
<img src="media/16460285618722/16528725986448.png" alt="image-20220225093248907" style="zoom:50%;" />
<p><strong>性质2</strong>: 给定两个多项式\(\hat{t}=\pi_\mathrm{conv}^i(\mathbf T), \hat{k}=\pi_\mathrm{conv}^w(\mathbf K)\in\mathbb A_{N,p}\), 卷积公式(2)可以通过环\(\mathbb A_{N,p}\)上的多项式乘积\(\hat{t}'=\hat{t}\cdot\hat{k}\)来求解, 即对\(\mathbf T'\)的所有位置\((c',i',j')\), \(\mathbf T'[c',i',j']=\hat{t}'[O-c'CHW+i'sW+j's]\), 其中\(O=HW(MC-1)+W(h-1)+h-1\).</p>
<p>现在考虑大张量情况下的一般情形, 主要做法与FC类似, 仍是需要将大的输入张量和核切分为更小的子块使之适合\(\mathbb A_{N,p}\)上的多项式运算, 并对边缘块不足的部分通过Zero padding用零补足.</p>
<p>首先将切分窗口\((M,C,H,W)\)轴坐标分别定义为可自由选择的\(M_w,C_w,H_w,W_w\), 但需满足约束条件: \(0&lt;M_w\leq M\), \(0&lt;C_w\leq C\), \(h\leq H_w\leq H\), \(h\leq W_w\leq W\), \(M_wC_wH_wW_w\leq N\). 本文中为了最小化Bob发送的密文数量, 选取\(H_w,W_w\)使得乘积\(\lceil\frac{C}{\lfloor N/(H_wW_w)\rfloor}\rceil\cdot\lceil\frac{H-h+1}{H_w-h+1}\rceil\cdot\lceil\frac{W-h+1}{W_w+h-1}\rceil\)最小化, 此时\(C_w=\min(C,\lfloor N/(H_wW_w)\rfloor)\), \(M_w=\min(M,\lfloor N/(C_wH_wW_w)\rfloor)\).</p>
<p>由于沿\(M\)轴上的卷积独立于每个子核, 因而可以将\(M\)轴切分为\(d_M=\lceil\frac{M}{M_w}\rceil\)个组, 每个组包含\(M_w\)个子核. 类似地, 沿\(C\)轴上的卷积需要额外的加法, 而同态运算支持加法, 因此我们也可以安全无重叠地沿着\(C\)轴进行切分.</p>
<p>当\(h&gt;1\)时, 需要额外关注\(H\)轴和\(W\)轴的切分, 以确保步幅窗口不会切分到两个邻近的分区中. 本文中分别将\(H\)轴切分为\(d_H=\lceil\frac{H-h+1}{H_w-h+1}\rceil\)块, 将\(W\)轴切分为\(d_W=\lceil\frac{W-h+1}{W_w-h+1}\rceil\)块. 对于子块\(\alpha\in[[d_H]],\beta\in[[d_W]]\), 包含了\(\mathbf T\)从第\(\alpha(H_w-h+1)\)行开始的\(H_w\)的连续行, 从第\(\beta(W_w-h+1)\)列开始的\(W_w\)的连续列. 举例如图5所示, 当\(h&gt;1\)时, 相邻块存在重叠, 虚线部分是Zero padding.</p>
<img src="media/16460285618722/16528725986498.png" alt="image-20220225112619578" style="zoom:50%;" />
<p>整个卷积层的安全协议完整版如下图11.</p>
<img src="media/16460285618722/16528725986552.png" alt="image-20220225141352247" style="zoom:50%;" />
<p>复杂度分析: Bob发送了\(O(CHW/N)\)个RLWE密文给Alice, 大约\(O(2CHW\log_2q)\)比特. Alice计算了\(O(MCHW/N)\)个同态加法和乘法, 并发送\(O(\frac{M}{M_w}H'W')\)个LWE密文给Bob解密. 整个协议的计算复杂度与核大小\(h\)无关.</p>
<h3><a id="%E6%89%B9%E6%A0%87%E5%87%86%E5%8C%96%E5%B1%82bn%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>批标准化层(BN层)</h3>
<p>在DNN中, BN层\(\mathsf{BN}(\mathbf{T};\alpha,\beta)\)取三维张量\(\mathbf T\in\mathbb F^{C\times H\times W}\)为输入, 参数\(\mu\in\mathbb F^C\)是缩放向量, \(\theta\in\mathbb F^C\)是移位向量, 输出相同形状的三维张量\(\mathbf{T}'\). 对于所有的\(c\in[[C]],i\in[[H]],j\in[[W]]\),</p>
\[\mathbf T'[c,i,j]=\mu[c]\mathbf T[c,i,j]+\theta[c].\tag{3}
\]
<p>若将\(\mathbf T\)看作大小为\(HW\)的向量, 可以将公式(3)看成标量-向量乘法和向量加法的形式.</p>
<p>于是我们可以通过映射张量的每个通道到多项式以使用标量多项式乘法计算BN, 这会使安全BN协议通信\(O(C\lceil HW/N\rceil)\)个密文. 为此, 可以通过“堆砌”多通道为单个多项式来降低通信成本.</p>
<p>设\(C^2HW\leq N\), 定义映射: \(\pi_\mathrm{bn}^i:\mathbb Z_p^{C\times H\times W}\mapsto\mathbb A_{N,p}\)和\(\pi_\mathrm{bn}^w:\mathbb Z_p^{C}\mapsto\mathbb A_{N,p}\):</p>
\[\hat{t}=\pi_\mathrm{bn}^i(\mathbf T)~\text{使得}~\hat{t}[cCHW+iH+j]=\mathbf T[c,i,j]\\
\hat{a}=\pi_\mathrm{bn}^w(\alpha)~\text{使得}~\hat{a}[cHW]=\alpha[c],
\]
<p>其中\(c\in[[c]]\), \(i\in[[H]]\), \(j\in[[W]]\), \(\hat{t}\)和\(\hat{a}\)的所有其他系数均设为0. 如此, 多项式乘积\(\hat{t}'=\hat{t}\cdot\hat{a}\)的某些系数给出了公式(3)的乘法部分结果, 即对所有\((c,i,j)\)位置, 有</p>
\[\hat{t}'[cCHW+cHW+iH+j]=\mathbf T[c,i,j]\alpha[c].
\]
<p>当\(C^2HW&gt;N\), 类似于上面的方法, 将\(\mathbf T\)切分成形状为\(C_w\times H_w\times W_w\)的子块, 使得\(C_w^2H_wW_w\leq N\). 由于每个通道在BN计算中都是独立进行的, 因此可以将两个映射直接应用于\(\mathbf T\)的子块. 整个协议如下图6:</p>
<img src="media/16460285618722/16528725986608.png" alt="image-20220225172349412" style="zoom:50%;" />
<p>复杂度分析: Bob加密并发送\(O(CHW/N)\)个RLWE密文给Alice. Alice进行\(O(CHW/N)\)次同态运算. 最后, Alice发送\(O(CHW)\)个LWE密文给Bob解密.</p>
<h2><a id="%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0%E7%9A%842pc%E4%BC%98%E5%8C%96%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>非线性函数的2PC优化协议</h2>
<p>CrypTFlow2中对非线性计算协议大量应用了IKNP类型OT扩展协议, Cheetah中则使用VOLE类型OT扩展协议来简化和优化CrypTFlow2的非线性计算协议.</p>
<p>本文主要使用\(\binom{2}{1}-\mathtt{OT}_\ell\), \(\binom{2}{1}-\mathtt{COT}_\ell\)和\(\binom{n}{1}-\mathtt{OT}_\ell\). 由于使用的是VOLE类型OT扩展协议, 因此其调用\(\binom{2}{1}-\mathtt{ROT}_\lambda\)的均摊通信开销几乎为零. 它与CryptTFlow2的对比如下表2, 当\(n\)和消息长度\(\ell\)很小时, 本文的方案有明显优势, 对所有神经网络安全推理中的协议均如此(通常\(n\leq16,\ell\leq 2\)).</p>
<img src="media/16460285618722/16528725986660.png" alt="image-20220225202618987" style="zoom:50%;" />
<h3><a id="%E7%99%BE%E4%B8%87%E5%AF%8C%E7%BF%81%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>百万富翁协议</h3>
<p>百万富翁协议即比较协议, 几乎是所有非线性层的核心组件, 如ReLU、截断和池化. Cheetah中的比较协议与CrypTFlow2的主要不同之处在于底层的\(\mathcal F_\mathrm{AND}\)使用VOLE类型OT扩展协议实现而不是IKNP类型OT扩展协议.</p>
<p>设\(x,y\in\{0,1\}^\ell\), \(\mathcal F_\mathrm{AND}\)是取\(x\)和\(y\)的布尔份额为输入并输出\(x\wedge y\)的布尔份额的功能函数, 协议如图12.</p>
<img src="media/16460285618722/16528725986735.png" alt="image-20220225220955682" style="zoom:50%;" />
<p>首先回顾CrypTFlow2中的比较协议,</p>
<ol>
<li>每方将各自的\(\ell\)比特输入分解为\(m\)比特小块. 设\(x_j\)和\(y_j\)分别代表\(P_0\)和\(P_1\)的第\(j\)小块. 两方调用两次\(\binom{2^m}{1}-\mathtt{OT}_1\)分别计算\(\mathtt{lt}_j=\mathbf 1\{x_j&lt;y_j\}\)和\(\mathtt{eq}_j=\mathbf 1\{x_j=y_j\}\).</li>
<li>两方使用\(\mathcal F_\mathrm{AND}\)组合前面的输出, 根据\(\mathbf 1\{x&lt;y\}=\mathbf 1\{x_1&lt;y_1\}\oplus(\mathbf 1\{x_1=y_1\}\wedge\mathbf 1\{x_0&lt;y_0\})\)对深度为\(\log(\ell/m)\)的二叉树进行求值, 其中\(x=x_1||x_0,y=y_1||y_0\).</li>
</ol>
<p>关于CrypTFlow2中的比较协议更详细的解读可以参考知乎中科院大神@酸菜鱼 的<a href="https://zhuanlan.zhihu.com/p/468777277">这篇解读文章</a>.</p>
<p>CrypTFlow2中对步骤2提出了多种优化方案以分析\(\mathcal F_\mathrm{AND}\)在IKNP类型OT扩展协议的效率, 例如使用\(\binom{16}{1}-\mathtt{OT}_2\)生成两个Beaver三元组和\(\binom{8}{1}-\mathtt{OT}_2\)生成关联元组. 然而在Cheetah中, 则使用更高效的\(\binom{2}{1}-\mathtt{ROT}_1\)生成Beaver三元组. 尽管如此, CrypTFlow2在步骤1中分成\(m\)比特块求值的方案极大地减少了直接对逐比特生成的深度为\(\log\ell\)的二叉树进行求值的原始方案所使用AND门数量, 表3对三种方案的通信复杂度进行了比较.</p>
<img src="media/16460285618722/16528725986812.png" alt="image-20220227120140958" style="zoom:40%;" />
<p>下文中, 设\((\langle m\rangle_2^A,\langle m\rangle_2^B)=\mathsf{Mill}^\ell(x,y)\)代表百万富翁协议, 其中Alice输入为\(x\), Bob输入为\(y\), 得到\(\langle m\rangle_2^A\oplus\langle m\rangle_2^B=\mathbf 1\{x&gt;y\}\)的布尔分享份额.</p>
<h3><a id="%E8%BF%91%E4%BC%BC%E6%88%AA%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>近似截断</h3>
<p>在定点数计算中, 截断是乘法计算后的必要步骤.</p>
<h4><a id="%E4%B8%80%E6%AF%94%E7%89%B9%E8%BF%91%E4%BC%BC%E6%88%AA%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一比特近似截断</h4>
<p>DELPHI<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup>、ABY3、SecureML中使用的本地截断的误差来源有两个: 一是当秘密份额之和溢出时造成极大的误差; 二是以1/2的概率造成最后一比特误差. CrypTFlow2中以繁重、faithful截断协议来约束这两种情况. 但本文通过实验发现, 在实际应用中, 当\(\ell\leq 64\)时, 前者造成极大误差这个概率是不可忽略的, 而最后一比特造成的误差实际上不会影响机器学习预测模型的质量<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup>. 由于这个原因, 可以移除最后一比特误差的约束来构造更简洁轻量的截断协议, 从而显著降低通信和计算开销.</p>
<p><strong>性质3</strong>: 给定无符号\(\ell\)比特整数\(x\)和它的算术分享份额\(x_0\)和\(x_1\), 定义\(w=\mathbf 1\{x_0+x_1&gt;2^\ell-1\}\). 设\(c\)是一比特整数0或1, 有\((x_0\gg f)+(x_1\gg f)-w\cdot 2^\ell=(x\gg f)-c\).</p>
<p>性质3中的\(w\)取值与\(x_0+x_1&gt;_?2^\ell-1\)相关, 是导致本地截断出现大误差的原因. 设\(\mathcal F_\mathrm{B2A}^{2^f}\)表示将\(x\in\{0,1\}\)的布尔共享份额转化为在\(\mathbb Z_{2^f}\)上的\(x\)的算术共享份额, 可通过VOLE类型OT协议实例化的\(\binom{2}{1}-\mathtt{COT}_f\)来构造具体协议(与CrypTFlow2的B2A协议相同, 只是OT类型不同, 如下图13). 如此可构造一比特近似截断协议如下图8.</p>
<p><img src="media/16460285618722/16528725986291.png" alt="Cheetah138" /></p>
<h4><a id="%E5%B7%B2%E7%9F%A5%E7%AC%A6%E5%8F%B7%E4%BD%8D%E7%9A%84%E8%BF%91%E4%BC%BC%E6%88%AA%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>已知符号位的近似截断</h4>
<p>当输入的符号位/最高位(MSB)已知时, 可以构造更高效的2PC截断协议. 设已知输入为正, 即其最高位为0, 则\(w\)的计算可以只调用一次\(\binom{2}{1}-\mathtt{OT}_1\)完成, 而不需要借助百万富翁协议, 此时\(w=\mathtt{msb}(\langle x\rangle^A)\vee\mathtt{msb}(\langle x\rangle^B)\), 如此可构造图9的协议. 类似地, 当最高位为1时, \(w=\mathtt{msb}(\langle x\rangle^A)\wedge\mathtt{msb}(\langle x\rangle^B)\).</p>
<img src="media/16460285618722/16528725986887.png" alt="image-20220227202321566" style="zoom:40%;" />
<p>通信复杂度分析: 比起CrypTFlow2, Cheetah通信开销更小, 如下表所示.</p>
<img src="media/16460285618722/16528725986956.png" alt="image-20220227203333646" style="zoom:40%;" />
<h2><a id="%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化</h2>
<h3><a id="%E8%AE%A1%E7%AE%97%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算优化</h3>
<p>通常BN层放在CONV层或FC层后面. BN融合技术可以将BN操作并入CONV层中, 成为新CONV层, 相比先CONV后BN, 可大大减少计算量. 由于Alice已知BN层和CONV层的权重, 因此可以通过BN融合(fusion)技术来减少\(\mathsf{HomBN}\)的计算. 此外, 通过使用BN融合技术, 还可以节省一个深度的定点数乘法从而减少截断的计算.</p>
<h3><a id="%E9%80%9A%E4%BF%A1%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通信优化</h3>
<p>文章还给出了减少Alice通信开销的两个优化方法, 主要是减少Alice发送的HE密文数量.</p>
<ol>
<li>若某些LWE密文抽取自相同的RLWE密文, 则这些LWE密文具有相同的向量\(\mathbf a\), 因而Alice可以只发送一次该向量.</li>
<li>来自于对LWE解密算法的观察. 假设Alice需要发送LWE密文\((b,\mathbf a)\in\mathbb Z_q^{N+1}\)给Bob解密, 则Alice只需发送\(b\)和\(\mathbf a\)中元素的某些高位比特给Bob, 并忽略剩下低位到最后的部分, 因为这部分对解密来说是无用的. 具体来说, Alice可以忽略\(b\)的后\(\ell_b=\lfloor\log_2(q/p)\rfloor-1\)比特和\(\mathbf a\)中元素的后\(\ell_a=\lfloor\log_2(q/6.6\sqrt{N}p)\rfloor\)比特. 可以证明Bob对这样的密文解密失败的几率可忽略不计. 如此Alice可以节省16%~25%的通信开销.</li>
</ol>
<h2><a id="%E5%AE%9E%E9%AA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实验</h2>
<p>本文的协议可以使用任意VOLE类型的OT扩展协议实现, 本文代码使用的是Ferret的方案<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup>. 涉及的开源库有: SEAL, HEXL acceleration, EMP-toolkit. 具体代码已在Github开源: <a href="https://github.com/Alibaba-Gemini-Lab/OpenCheetah">https://github.com/Alibaba-Gemini-Lab/OpenCheetah</a>.</p>
<p>实验环境: 阿里云ecs.c7.2xlarge, 2.70GHz处理器, 16GB RAM.</p>
<p>实验部分主要与CrypTFlow2的\(SCI_\mathsf{HE}\)开源库进行对比. 实验数据中的通信量是指Alice和Bob的所有信息发送量, 时间是指不同网络设置(LAN/WAN)下的端到端时间, 但两者都不包括一次性设定(如密钥生成和Base-OT)的通信量和时间.</p>
<p><strong>线性协议对比</strong>: 计算快约1.3~20倍, 通信开销低1.5~2倍.</p>
<img src="media/16460285618722/16528725987019.png" alt="image-20220228102647861" style="zoom:33%;" />
<p><strong>非线性函数对比</strong>: 单线程下, 本文的所有非线性协议通信开销低10倍以上.</p>
<img src="media/16460285618722/16528725987083.png" alt="image-20220228104153836" style="zoom:33%;" />
<p><strong>与DELPHI<sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup>对比</strong>: Cheetah计算快1个量级, 通信低2个量级.</p>
<img src="media/16460285618722/16528725987143.png" alt="image-20220228112416461" style="zoom:33%;" />
<p><strong>与CrypTFlow2对比</strong>: 即使在WAN环境下, Cheetah求解SqueezeNet, ResNet50, DenseNet121耗时不到3分钟. 端到端时间方面, Cheetah比\(SCI_\mathsf{HE}\)快2~5倍.</p>
<p><strong>与SecureQ8<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup>对比</strong>: 文章还引入了3PC推理框架SecureQ8进行了对比, LAN下SecureQ8比Cheetah快3~4倍, 但WAN下由于通信较少, Cheetah比SecureQ8快2~3倍.</p>
<img src="media/16460285618722/16528725987200.png" alt="image-20220228112818099" style="zoom:33%;" />
<p>文章还对近似截断协议的有效性进行了实验, 结果发现对于所有实验图片, Cheetah输出标签向量几乎与\(SCI_\mathsf{HE}\)相同, 定点数计算的预测准确度也与相应的浮点数计算的预测准确度相匹配, 因此对2PC-NN来说, Cheetah是有效的.</p>
<img src="media/16460285618722/16528725987255.png" alt="image-20220228124532463" style="zoom:33%;" />
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>Cheetah提供了一个高度优化的2PC-NN推理架构, WAN设定下, 在不到2.5分钟的时间内对ResNet50模型进行安全推理, 消耗2.3GB的通信量, 非常高效, 适合大规模神经网络训练推理, 是目前最好的2PC-NN工作之一.</p>
<p>总体而言, 本文的亮点有以下几点:</p>
<ul>
<li>卷积和矩阵向量乘法中涉及的同态rotation操作是基于格的HE方案的性能瓶颈之一, 本文通过构造映射巧妙地消除了同态rotation运算, 也避免了使用SIMD, 加快了同态运算的效率;</li>
<li>基于HE的协议可以直接接受\(\mathbb Z_{2^\ell}\)的秘密份额, 而不局限于\(\mathbb Z_p\), 避免了额外的计算和通信开销;</li>
<li>本文使用了基于VOLE类型的OT扩展协议来构造高效、精简的非线性计算协议, 如截断、比较协议等, 极大降低了安全推理的计算和通信开销.</li>
</ul>
<h2><a id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考文献</h2>
<section class="footnotes">
<ol>
<li id="fn1">
<p>Elette Boyle,Geoffroy Couteau,Niv Gilboa,Yuval Ishai, Lisa Kohl, Peter Rindal, and Peter Scholl. Efficient two-round OT extension and silent non-interactive secure computation. In CCS, pages 291–308, 2019. <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2">
<p>Kang Yang, Chenkai Weng, Xiao Lan, Jiang Zhang, and Xiao Wang. Ferret: Fast extension for correlated OT with small communication. In CCS, pages 1607–1626, 2020. <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3">
<p>Geoffroy Couteau, Peter Rindal, and Srinivasan Raghuraman. Silver: Silent VOLE and oblivious transfer from hardness of decoding structured LDPC codes. In CRYPTO, pages 502–534, 2021. <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4">
<p>Anders P. K. Dalskov, Daniel Escudero, and Marcel Keller. Secure evaluation of quantized neural networks. Proc. Priv. Enhancing Technol., 2020(4):355–375, 2020. <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
<li id="fn5">
<p>Pratyush Mishra, Ryan Lehmkuhl, Akshayaram Srini- vasan, Wenting Zheng, and Raluca Ada Popa. DELPHI: A cryptographic inference service for neural networks. In USENIX, pages 2505–2522, 2020. <a href="#fnref5" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SWIFT: Super-fast and Robust Privacy-Preserving Machine Learning]]></title>
    <link href="https://weiviming.github.io/16449265418549.html"/>
    <updated>2022-02-15T20:02:21+08:00</updated>
    <id>https://weiviming.github.io/16449265418549.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>2022年元旦初更<em>USENIX Security'21</em>上的一篇文章SWIFT: Super-fast and Robust Privacy-Preserving Machine Learning, 原文链接如下: <a href="https://arxiv.org/abs/2005.10296">https://arxiv.org/abs/2005.10296</a>.</p>
</blockquote>
<h2><a id="abstract" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Abstract</h2>
<p>SWIFT是一个环\(\mathbb Z_{2^{64}},\mathbb Z_2\)上基于秘密共享的高效、恶意安全的3PC/4PC隐私保护机器学习框架, 在诚实大多数设定中(至多只有一个恶意服务器)实现了输出可达性(GOD), 非常适用于安全外包计算(SOC)范式, 能让用户积极参与计算而不需担心拒绝服务. SWIFT与BLAZE一样快, 但后者只实现了公平性. 当SWIFT从三方扩展到四方时, 与4PC具备公平性的Trident一样快, 且比4PC具备鲁棒的FLASH框架快2倍. 在WAN环境中计算域为\(\mathbb Z_{2^{64}}\)的情况下, 文章对流行的ML算法和DNN进行了基准测试, 证明了SWIFT的实用性. 对于DNN, 实验结果证明本文的方案提升了安全性保障, 不会为3PC带来额外开销, 同时还为4PC提升了2倍性能.</p>
<h2><a id="introduction" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h2>
<p>只实现中止安全性的MPC协议不能满足安全外包计算的要求, 因为用户可能无法获得输出, 导致用户的参与度降低, 因此实现输出可达性/鲁棒性的MPC协议对安全外包计算来说是至关重要的. 为了提高效率, 许多PPML方案采用了offline-online范式来设计MPC协议. 此外, 为了进一步提升效率, 充分利用CPU架构的特性, 多数MPC方案的计算域都建立在二次幂环上, 如\(\mathbb Z_{2^{32}}, \mathbb Z_{2^{64}}\)等.</p>
<p>总的来说, 本文的主要贡献如下:</p>
<ol>
<li>鲁棒的3PC/4PC框架: SWIFT的3PC框架的亮点之一是鲁棒的点积协议的(均摊)通信成本与向量大小无关. 对于不同的组件, SWIFT与只实现公平性(Fairness)的BLAZE在通信量、通信轮次等方面的比较见表1.</li>
<li>SWIFT的PPML模块可用于LR, SVM, BNN的训练和推理.</li>
<li>SWIFT实现GOD的关键在于本文引入的联合消息传递(Joint Message Passing, JMP)原语, 它允许两个服务器将其共有的消息中继(relay)给第三个服务器验证消息的一致性, 要么中继成功, 要么识别出诚实计算的服务器, 然后诚实服务器作为可信第三方(TTP)来完成明文计算.</li>
<li>为重构协议引入了一个超快的在线阶段, 通信轮次比BLAZE提升了4倍.</li>
</ol>
<p><img src="media/16449265418549/16528739158544.png" alt="image-20211229093519029" /></p>
<p>此外, 文章还指出了Fantastic Four中存在的一些问题. Fantatstic Four首次提出了隐私鲁棒性(Private Robustness), 作者认为它是GOD的一种变体, 其目的是防止诚实计算方获得用户的隐私输入, 从而在将来变成恶意方时滥用用户隐私输入信息. 但本文指出, 尽管在隐私鲁棒性设定下诚实方不会从协议中学习到用户输入, 但不能阻止敌手向诚实方泄漏他的视图. 在这种情况下, 若诚实方未来变成恶意方, 它可以结合敌手的视图来获得用户的输入. 此外, Fantastic Four中隐私鲁棒性的概念不满足FaF安全性(Friends-and-Foes Security[5]), 在FaF安全性中, 除了传统的腐化方视图需要模拟外, 还要求模拟诚实方的视图, 但Fantastic Four中没有对协议进行相关分析. 最后, Fantastic Four在排除潜在的腐化方时, 需要重新进行计算, 这将导致通信量增加, 降低了效率.</p>
<ol>
<li>不能阻止敌手在诚实方变成恶意方之后泄漏敌手的视图从而获取用户输入;</li>
<li>隐私鲁棒性概念不满足FaF安全性, 后者要求除模拟腐化方视图外, 还需模拟诚实方的视图;</li>
<li>排除潜在腐化方之后需要重新进行计算, 通信成本增大, 效率降低.</li>
</ol>
<h2><a id="preliminaries" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Preliminaries</h2>
<p>服务器代理模式, 静态恶意敌手至多腐化一个计算服务器, 仅在3PC的情况下存在一个广播信道. 服务器之间通过一次性密钥设定生成用于PRF的预分享随机密钥, 用于生成相关随机性.</p>
<p>计算域: 布尔域\(\mathbb Z_2\), 算术环为\(\mathbb Z_{2^{64}}\), 数据长度为\(\ell=64\)bits, 精度\(x=13\)bits, 整数部分长度为\(\ell-x-1=40\)bits.</p>
<p>符号说明: \(\mathsf x_i\)为向量\(\vec{\mathbf x}\)的第\(i\)个元素. 对于长为\(\ell\)的数\(v\), \(v[i]\)表示第\(i\)个位置的比特. 对于比特\(b\in\{0,1\}\), 记\(b^\mathsf R\)为它在二次幂环\(\mathbb Z_{2^\ell}\)上的等价取值, 即\(\mathsf{LSB}(b^\mathsf R)=1\), 其余比特位置为0. 参与方集合记为\(\mathcal P\).</p>
<h2><a id="robust-3pc-and-ppml" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Robust 3PC and PPML</h2>
<h3><a id="secret-sharing-semantics" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secret Sharing Semantics</h3>
<p>文章中使用了如下三种分享语义:</p>
<ul>
<li>\([\cdot]\)-sharing: 两方下的加法秘密共享, 秘密\(v=[v]_1+[v]_2\), \(P_s\)持有\([v]_s\), \(s\in\{1,2\}\).</li>
<li>\(\langle\cdot\rangle\)-sharing: 三方下的复制秘密共享, 秘密\(v=v_0+v_1+v_2\), \(P_s\)拥有\((v_s,v_{(s+1)\%3}), s\in\{0,1,2\}\).</li>
<li>\([[\cdot]]\)-sharing: 三方下的复制秘密共享, 设秘密为\(v\), \(P_1,P_2\)分别持有\(\alpha_v\in\mathbb Z_{2^\ell}\)的\([\cdot]\)份额, 存在\(\beta_v,\gamma_v\in\mathbb Z_{2^\ell}\), \(\beta_v=v+\alpha_v\), \(P_0\)持有\(([\alpha_v]_1,[\alpha_v]_2,\beta_v+\gamma_v)\), \(P_s\)持有\(([\alpha_v]_s,\beta_v,\gamma_v)\), 其中\(s\in\{1,2\}\). 在这个分享语义中, 任意一方无法重构\(v\), 但任意两方可以.</li>
</ul>
<p>以上三种秘密共享方案都满足线性性, 因此, 它们的加法和常量积的计算是非交互的.</p>
<h3><a id="joint-message-passing-primitive" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Joint Message Passing primitive</h3>
<p>引入的联合消息传递(Joint Message Passing, JMP)原语允许两个服务器将其共有的消息中继(relay)给第三个服务器验证消息的一致性, 要么中继验证成功, 要么识别出诚实计算的服务器, 然后, 将诚实服务器作为可信第三方(TTP)来完成相关计算(明文计算). 在均摊意义下, JMP对于一个\(\ell\)个元素的消息, 只产生\(\ell\)个元素的通信.</p>
<p>对于\(s\in\{i,j,k\}\), \(P_s\)将\(b_s=0\), 作为不一致标志比特. 当\(P_k\)收到不一致的消息对\((v,\mathsf{H}(v^*))\)时, 设定\(b_k=1\), 并将\(b_k\)发送给\(P_i,P_j\), 由这两方通过交换不一致标志比特相互进行交叉检验, 若从\(P_k\)收到的或者从其他发送方接收到的比特为1, 则这两方将自己的不一致标志比特设定为1. 当服务器的不一致标志比特为1时, 服务器会广播值的Hash结果. \(P_k\)的值来自它从\(P_i\)接收到的值. 接下来按照具体协议来选出合适的服务器当做TTP, 三方下JMP的理想功能如图1, 协议如图2. 容易验证协议是正确的. 下文中为简便起见, 称\(P_i,P_j\) jmp-send \(v\) 给\(P_k\), 是指调用\(\Pi_{\mathsf{jmp}}(P_i,P_j,P_k,v)\).</p>
<p>为均摊通信开销, 实际应用协议时, JMP的发送阶段随协议调用而执行, 而验证阶段在协议的所有结束后进行, 通过组合验证的方式可让验证只需执行一次. 当验证不通过时则通过TTP的帮助来完成相关计算. JMP的通信1轮, 均摊通信量为\(\ell\)比特.</p>
<p><img src="media/16449265418549/16528739158576.png" alt="SWIFT12" /></p>
<h3><a id="3pc-protocols" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3PC Protocols</h3>
<h4><a id="sharing-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sharing Protocol</h4>
<p>Sharing Protocol \(\Pi_{\mathsf{sh}}\): 允许\(P_i\)生成秘密\(v\)的\([[\cdot]]\)份额. 该协议预处理阶段不需交互, 在线阶段需要2轮通信, 均摊通信量为\(2\ell\)比特.</p>
<h4><a id="joint-sharing-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Joint Sharing Protocol</h4>
<p>Joint Sharing Protocol \(\Pi_{\mathsf{jsh}}\): 允许\(P_i,P_j\)联合生成它们的共同秘密\(v\)的\([[\cdot]]\)份额. 该协议预处理阶段不许交互, 在线阶段需要1轮通信, 均摊通信量为\(\ell\)比特.</p>
<p><img src="media/16449265418549/16528739158636.png" alt="SWIFT34" /></p>
<p>特别地, 当\(P_i,P_j\)知道预处理阶段的\(v\)时, \(\Pi_\mathsf{jsh}\)可以不需要交互: \(\mathcal P\)随机采样\(r\in\mathbb Z_{2^\ell}\), 然后本地按照表2约定他们各自的份额.</p>
<img src="media/16449265418549/16528739182396.png" alt="image-20211230145332669" style="zoom: 33%;" />
<h4><a id="multiplication-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiplication Protocol</h4>
<p>Multiplication Protocol \(\Pi_\mathsf{mult}\): 给定\([[x]],[[y]]\), 允许\(\mathcal P\)计算得到\(z=xy\)的份额\([[z]]\).</p>
<p>首先给出半诚实安全下的乘法协议(与BLAZE相同): 在预处理阶段, \(P_0,P_1\)随机选取\([\alpha_z]_1\), \(P_0,P_2\)随机选取\([\alpha_z]_2\), \(P_1,P_2\)随机选取\(\gamma_z\). \(P_0\)本地计算\(\Gamma_{xy}=\alpha_x\alpha_y\), 并为\(P_1,P_2\)生成相同的\([\cdot]\)份额. 对于\(j\in{1,2}\), 在线阶段\(P_j\)本地计算\([\beta_z]_j=(j-1)\beta_x\beta_y-\beta_x[\alpha_y]_j-\beta_y[\alpha_x]_j+[\Gamma_{xy}]_j+[\alpha_{z}]_j\), 并互相交换重构\(\beta_z\). 然后\(P_1\)发送\(\beta_z+\gamma_z\)给\(P_0\), 完成半诚实安全的协议. 协议的正确性在于如下等式</p>
\[\begin{aligned}
xy=z=\beta_z-\alpha_z\Rightarrow\beta_z&amp;=z+\alpha_z=xy+\alpha_z=(\beta_x-\alpha_x)(\beta_y-\alpha_y)+\alpha_z\\
&amp;=\beta_x\beta_y-\beta_x\alpha_y-\beta_y\alpha_x+\Gamma_{xy}+\alpha_z.
\end{aligned}
\]
<p>与BLAZE类似, 在恶意安全下, 需要考虑如下几个问题:</p>
<p><strong>问题1</strong>. 当\(P_0\)被腐化时, 所计算的\(\Gamma_{xy}\neq\alpha_x\alpha_y\);</p>
<p><strong>问题2</strong>. 当\(P_1\)或\(P_2\)被腐化时, 可能发送错误的\([\beta_z]\)份额给另一方, 导致重构的\(\beta_z\)是错误的;</p>
<p><strong>问题3</strong>. 当\(P_1\)被腐化时, 在线阶段发送给\(P_0\)的\(\beta_z+\gamma_z\)可能是不正确的.</p>
<p>BLAZE中的恶意安全的乘法方案仅是中止安全的(Security with abort), 在SWIFT中处理方式与BLAZE不同.</p>
<p>对于问题3, SWIFT框架在计算\(\beta_z\)后, 通过\(P_1,P_2\) jmp-send \(\beta_z+\gamma_z\)给\(P_0\)来解决.</p>
<p>对于问题2, 我们首先介绍BLAZE中的处理方式. 在BLAZE中, 让\(P_0\)基于\(\beta_x,\beta_y\)计算\(\beta_z\)进行验证. 令\(\chi=\gamma_x\alpha_y+\gamma_y\alpha_x-\Gamma_{xy}\), \(P_0\)通过\(\beta_x+\gamma_x,\beta_y+\gamma_y,\alpha_x,\alpha_y,\alpha_z,\Gamma_{xy}\)可以计算如下等式:</p>
\[\begin{aligned}
\beta_z^*&amp;=-(\beta_x+\gamma_x)\alpha_y-(\beta_y+\gamma_y)\alpha_x+2\Gamma_{xy}+\alpha_z\\
&amp;=(-\beta_x\alpha_y-\beta_y\alpha_x+\Gamma_{xy}+\alpha_z)-(\gamma_x\alpha_y+\gamma_y\alpha_x-\Gamma_{xy})\\
&amp;=(\beta_z-\beta_x\beta_y)-(\gamma_x\alpha_y+\gamma_y\alpha_x-\Gamma_{xy})\\
&amp;=(\beta_z-\beta_x\beta_y)-\chi.
\end{aligned}
\]
<p>若\(P_0\)可以得到\(\chi\), 则它可以发\(\beta_z^*+\chi\)给\(P_1\)和\(P_2\), 由\(P_1\)和\(P_2\)通过计算\(\beta_z-\beta_x\beta_y\overset{?}{=}\beta_z^*+\chi\)来验证\(\beta_z\)的正确性. 但当\(P_0\)是腐化方时, 让\(P_0\)得到\(\chi\)是不安全的. 为此, \(P_1,P_2\)通过关联随机性共同选取随机数\(\psi\)作为茫化因子, 然后令\(\chi=\gamma_x\alpha_y+\gamma_y\alpha_x-\Gamma_{xy}+\psi, \beta_z^*=(\beta_z-\beta_x\beta_y+\psi)-\chi\). 此时让\(P_0\)得到的是\(\chi+\psi\), 然后\(P_1,P_2\)计算\(\beta_z-\beta_x\beta_y+\psi\overset{?}{=}\beta_z^*+\chi\)验证\(\beta_z\)的正确性. 接下来, 如何确保\(P_0\)在诚实时计算了正确的\(\chi\)? BLAZE将该问题规约到一个Beaver triple. 注意到对于\(j\in\{1,2\}\), \(P_j\)可以本地计算\([\chi]_j=\gamma_x[\alpha_y]_j+\gamma_y[\alpha_x]_j-[\Gamma_{xy}]+[\psi]_j\), 其中\([\psi]_j\)由两方通过关联随机性生成. 为了验证\(P_0\)正确计算了正确的\(\chi\), 我们可以利用如下关系: 若\(d=\gamma_x-\alpha_x,e=\gamma_y-\alpha_y, f=(\gamma_x\gamma_y+\psi)-\chi\)满足\(f=de\), 当且仅当正确计算了\(\chi\). 这是因为</p>
\[\begin{aligned}
de&amp;=(\gamma_x-\alpha_x)(\gamma_y-\alpha_y)=\gamma_x\gamma_y-\gamma_x\alpha_y-\gamma_y\alpha_x+\Gamma_{xy}\\
&amp;=(\gamma_x\gamma_y+\psi)-(\gamma_x\alpha_y+\gamma_y\alpha_x-\Gamma_{xy}+\psi)\\
&amp;=(\gamma_x\gamma_y+\psi)-\chi=f.
\end{aligned}
\]
<p>于是, \(\chi\)的正确性规约到\((d,e,f)\)是否为Beaver triple.</p>
<p>对于问题1, 仍可通过规约到判断Beaver triple的方案来解决, 这是因为若\(P_0\)的份额为\(\Gamma_{xy}+\Delta\), 则\(de=f+\Delta\neq f\).</p>
<p>现在回到SWIFT的解决方案中. 首先, SWIFT不依赖于\(P_0\)验证信息\(\beta_z^*+\chi\), 如此当\(P_0\)被腐化时协议不会中止. 与直接让\(P_0\)得到\(\beta_z^*\)不同,  在SWIFT中让\(\{P_0,P_1\}\)得到\([\beta_z^*]_1\), \(\{P_0,P_2\}\)得到\([\beta_z^*]_2\), 然后通过jmp-send发送\([\beta_z^*]_i\)给第三方服务器计算\(\beta_z^*\).  由于每个参与方集合中至少存在一个诚实参与方, 因此可确保\(\beta_z^*\)是正确的, \(P_1,P_2\)直接用它来计算\(\beta_z=\beta_x\beta_y+\psi+\beta_z^*\).  SWIFT中定义</p>
\[\chi=\gamma_x\alpha_y+\gamma_y\alpha_x+\Gamma_{xy}-\psi,
\]
\[\begin{aligned}
\beta_z^*&amp;=-(\beta_x+\gamma_x)\alpha_y-(\beta_y+\gamma_y)\alpha_x+\alpha_z+\chi\\
&amp;=(-\beta_x\alpha_y-\beta_y\alpha_x+\Gamma_{xy}+\alpha_z)-\psi=\beta_z-\beta_x\beta_y-\psi.
\end{aligned}
\]
<p>显然, 给定\([\chi]_i\), \(P_0\)和\(P_i\)可以计算\([\beta_z^*]_i=-(\beta_x+\gamma_x)[\alpha_y]_i-(\beta_y+\gamma_y)[\alpha_x]_i+[\alpha_z]_i+[\chi]_i\). 但还需要解决如下两个问题:</p>
<p>(1) 如何让\(\{P_0,P_i\}\)得到\([\chi]_i\)?</p>
<p>(2) \(P_1,P_2\)如何从Beaver triple中提取\(\psi\)?</p>
<p>类似于BLAZE的方法, 若\(d=\gamma_x+\alpha_x,e=\gamma_y+\alpha_y,f=(\gamma_x\gamma_y+\psi)+\chi\), \((d,e,f)\)是Beaver triple当且仅当\(\chi\)和\(\Gamma_{xy}\)是正确的. 这是因为</p>
\[\begin{aligned}
de&amp;=(\gamma_x+\alpha_x)(\gamma_y+\alpha_y)=\gamma_x\gamma_y+\gamma_x\alpha_y+\gamma_y\alpha_x+\Gamma_{xy}\\
&amp;=(\gamma_x\gamma_y+\psi)+(\gamma_x\alpha_y+\gamma_y\alpha_x+\Gamma_{xy}-\psi)\\
&amp;=(\gamma_x\gamma_y+\psi)+\chi=f
\end{aligned}
\]
<p>在预处理阶段中通过使用乘法协议计算上述triple并从\(f\)的份额中提取的\(\psi,\chi\)必然是正确的. 具体而言, (a) 服务器本地得到\(d,e\)的\(\langle\cdot\rangle\)-份额, 如表3; (b) 服务器计算\(f(=de)\)的\(\langle\cdot\rangle\)-份额, 表示为\(f_0,f_1,f_2\), 通过使用高效鲁棒的三方乘法协议\(\Pi_\mathsf{mulPre}\)(图6); (c) 服务器本地提取所需的预处理数据:
\([\chi]_2\leftarrow f_0, [\chi]_1\leftarrow f_1, \gamma_x\gamma_y+\psi\leftarrow f_2.\) 将这部分转换为\(\langle\cdot\rangle\)份额的鲁棒乘法协议不需要任何通信, 因为(a)和(c)都是本地计算, 通信开销规约到单次执行乘法协议的开销.</p>
<img src="media/16449265418549/16528739165883.png" alt="image-20220101152057914" style="zoom: 33%;" />
<img src="media/16449265418549/16528739182295.png" alt="image-20220101152143461" style="zoom:50%;" />
<p>根据\(\langle\cdot\rangle\)-sharing, \(P_0,P_1\)得到\(f_1\), 进而得到\([\chi]_1\). 类似地, \(P_0,P_2\)得到\(f_2\), 进而得到\([\chi]_2\). 最后, \(P_1,P_2\)得到\(f_2\), 进而可以计算\(\psi=f_2-\gamma_x\gamma_y\).  这样两个问题都解决了.</p>
<p>完整的乘法协议见图5. 预处理阶段的均摊通信开销为1轮, \(3\ell\)比特, 在线阶段的均摊开销为\(3\ell\)比特.</p>
<img src="media/16449265418549/16528739184752.png" alt="image-20220101170416469" style="zoom:50%;" />
<h4><a id="reconstruction-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reconstruction Protocol</h4>
<p>Reconstruction Protocol \(\Pi_\mathsf{rec}\): 允许服务器鲁棒地从份额\([[v]]\)重构秘密\(v\). 重构协议主要使用了承诺. 通信轮次为1, 通信量为\(6\ell\)比特.</p>
<img src="media/16449265418549/16528739181369.png" alt="image-20220101175841125" style="zoom:50%;" />
<h4><a id="the-complete-3pc-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Complete 3PC Protocol</h4>
<p>使用以上子协议实现GOD的3PC协议如下. 总的来说, 如果某个参与方存在任何恶意行为, 协议都能通过jmp选出一个TTP, 所有参与方将输入发给TTP进行明文计算. SWIFT证明的是标准的real-ideal world-based Security, 因为FaF安全的鲁棒3PC协议已经被证明是不可能实现的.</p>
<img src="media/16449265418549/16528739184329.png" alt="image-20220101185340871" style="zoom:50%;" />
<h3><a id="building-blocks-for-ppml-using-3pc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building Blocks for PPML using 3PC</h3>
<h4><a id="input-sharing-and-output-reconstruction-in-soc-setting" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Input Sharing and Output Reconstruction in SOC Setting</h4>
<p>Input Sharing Protocol \(\Pi_\mathsf{sh}^\mathsf{SOC}\): 在SOC场景下允许用户三个服务器之间生成秘密输入\(v\)的\([[\cdot]]\)-sharing的份额.</p>
<p>Output Reconstruction Protocol \(\Pi_\mathsf{rec}^\mathsf{SOC}\): 在SOC场景下允许服务器向用户重构秘密\(v\).</p>
<p>在以上协议中, 若某处确定了TTP, 则服务器将通知用户TTP身份, 用户将明文形式的输入发送给TTP进行计算函数输出, 然后将结果返回给用户.</p>
<img src="media/16449265418549/16528739171012.png" alt="image-20220102112432092" style="zoom:50%;" />
<h4><a id="msb-extraction" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MSB Extraction</h4>
<p>MSB Extraction Protocol \(\Pi_\mathsf{bitext}\): 给定\(v\)的算术分享\([[v]]\), 协议允许服务器计算\(v\)的最高有效位的布尔分享. SWIFT使用了ABY3的优化的2-输入并行前缀加法器布尔电路[optimized 2-input Parallel Prefix Adder (PPA) boolean circuit]. PPA电路由\(2\ell-2\)个AND门和\(\log\ell\)的乘法深度.</p>
<p>令\(v_0=\beta_v,v_1=-[\alpha_v]_1, v_2=-[\alpha_v]_2\), 则\(v=v_0+v_1+v_2\). 服务器首先根据表4本地计算\(v_0,v_1,v_2\)的每个比特相应的布尔分享. ABY3中将\(v=v_0+v_1+v_2\)表示为\(v=2c+s\), 其中\(\mathsf{FA}(v_0[i],v_1[i],v_2[i])\rightarrow(c[i],s[i]), i\in\{0,1,\cdots,\ell-1\}\), 这里的\(\mathsf{FA}\)代表一个全加电路, \(s\)代表比特的和, \(c\)代表进位比特.  总之, 服务器并行运行\(\ell\)次\(\mathsf{FA}\)来计算\([[c]]^\mathsf B,[[s]]^\mathsf B\). \(\mathsf{FA}\)是独立运行的, 需要1轮通信, 使用优化后的FFA电路计算最终结果为\(\mathsf{msb}(2[[c]]^\mathsf B+[[s]]^\mathsf B)\).</p>
<p>\(\Pi_\mathsf{bitext}\)在预处理阶段需要的通信量为\(9\ell-6\)比特, 通信轮次为\(\log\ell+1\)轮, 在线阶段均摊通信量为\(9\ell-6\)比特.</p>
<img src="media/16449265418549/16528739166900.png" alt="image-20220102132426325" style="zoom:50%;" />
<h4><a id="bit-to-arithmetic-conversion" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bit to Arithmetic Conversion</h4>
<p>Bit to Arithmetic Conversion Protocol \(\Pi_\mathsf{bit2A}\): 给定比特\(b\)的布尔分享\([[b]]^\mathsf B\), 该协议允许服务器计算算术分享\([[b^\mathsf R]]\). 和BLAZE一样, 原理是先在预处理阶段生成\(\alpha_b^\mathsf R=([\alpha_b]_1\oplus[\alpha_b]_2)^\mathsf R=[\alpha_b]_1^\mathsf R+[\alpha_b]_2^\mathsf R-2[\alpha_b]_1^\mathsf R[\alpha_b]_2^\mathsf R\), 然后在线阶段计算\(b^\mathsf R=(\beta_b\oplus\alpha_b)^\mathsf R=\beta_b^\mathsf R+\alpha_b^\mathsf R-2\beta_b^\mathsf R\alpha_b^\mathsf R\). 具体协议如下图. 该协议预处理阶段的均摊通信量为\(9\ell\)比特, 在线阶段需要1轮, \(4\ell\)比特通信量.</p>
<img src="media/16449265418549/16528739173051.png" alt="image-20220102155339680" style="zoom: 33%;" />
<h4><a id="bit-injection" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bit Injection</h4>
<p>Bit Injection Protocol \(\Pi_\mathsf{BitInj}\): 给定比特\(b\)的二进制分享\([[b]]^\mathsf{B}\)和\(v\)的算术分享\([[v]]\), 该协议计算\([[bv]]\). 原理是先通过\(\Pi_\mathsf{Bit2A}\)将\([[b]]^\mathsf B\)转换为\([[b]]\), 然后再通过\(\Pi_\mathsf{mult}\)计算\([[bv]]=[[b]]\cdot[[v]]\). 预处理阶段均摊通信量为\(12\ell\)比特, 在线阶段需要2轮, 均摊通信量为\(7\ell\)比特.</p>
<h4><a id="dot-product" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dot Product</h4>
<p>Dot Product Protocol \(\Pi_\mathsf{dotp}\): 给定长度为\(n\)的向量\([[\vec{\mathbf{x}}]]\)和\([[\vec{\mathbf{y}}]]\), 协议允许服务器鲁棒地生成\(z=\vec{\mathbf{x}}\odot\vec{\mathbf{y}}\)的\([[\cdot]]\)-sharing份额\([[z]]\).  SWIFT中借鉴了BLAZE的方法, 使得协议在线阶段的通信量与向量长度\(n\)无关.</p>
<p>\(z=\vec{\mathbf{x}}\odot\vec{\mathbf{y}}\)是形式为\(z_i=x_iy_i,i\in[n]\)的\(n\)个并行乘法, 再将结果累加在一起. 令\(\beta_z^*=\sum_{i=1}^n\beta_{z_i}^*\), 则</p>
\[\beta_z^*=-\sum_{i=1}^n(\beta_{x_i}+\gamma_{x_i})\alpha_{y_i}-\sum_{i=1}^n(\beta_{y_i}+\gamma_{y_i})\alpha_{x_i}+\alpha_z+\chi,
\]
<p>其中\(\chi=\sum_{i=1}^n(\gamma_{x_i}\alpha_{y_i}+\gamma_{y_i}\alpha_{x_i}+\Gamma_{x_iy_i}-\psi_i)\).</p>
<p>点积协议的在线阶段处理方式与乘法协议类似. \(P_0, P_1\)本地计算\([\beta_z^*]_1\)并通过jmp-send发送给\(P_2\). 类似地, \(P_0,P_2\)本地计算\([\beta_z^*]_2\)并通过jmp-send发送给\(P_1\). 然后\(P_1\)和\(P_2\)重构\(\beta_z^*=[\beta_z^*]_1+[\beta_z^*]_2\)并计算\(\beta_z=\beta_z^*+\sum_{i=1}^n\beta_{x_i}\beta_{y_i}+\psi\). 最后, \(P_1,P_2\)通过jmp-send发送\(\beta_z+\gamma_z\)给\(P_0\).</p>
<p>下面介绍如何通过黑盒(black-box)方式在预处理阶段让服务器获得点积协议所需的\((\chi,\psi)\).</p>
<p>令\(\vec{\mathbf{d}}=[d_1,\cdots,d_n], \vec{\mathbf{e}}=[e_1,\cdots,e_n]\), 其中\(d_i=\gamma_{x_i}+\alpha_{x_i}, e_i=\gamma_{y_i}+\alpha_{y_i}, i\in[n]\), 如此</p>
\[\begin{aligned}
f&amp;=\vec{\mathbf{d}}\odot\vec{\mathbf{e}}=\sum_{i=1}^nd_ie_i=\sum_{i=1}^n(\gamma_{x_i}+\alpha_{x_i})(\gamma_{y_i}+\alpha_{y_i})\\
&amp;=\sum_{i=1}^n(\gamma_{x_i}\gamma_{y_i}+\psi_{i})+\sum_{i=1}^n\chi_i=\sum_{i=1}^n(\gamma_{x_i}\gamma_{y_i}+\psi_{i})+\chi\\
&amp;=\sum_{i=1}^n(\gamma_{x_i}\gamma_{y_i}+\psi_{i})+[\chi]_1+[\chi]_2=f_2+f_1+f_0,
\end{aligned}
\]
<p>其中\(f_2=\sum_{i=1}^n(\gamma_{x_i}\gamma_{y_i}+\psi_i), f_1=[\chi]_1,f_2=[\chi]_2\).</p>
<p>使用以上关系, 预处理阶段的处理方式如下: \(P_0,P_1\)随机选取\([\alpha_z]_1\), \(P_0,P_2\)随机选取\([\alpha_z]_2\), \(P_1,P_2\)随机选取\(\gamma_z\). 服务器类似于乘法协议一样准备\(\langle\vec{\mathbf{d}}\rangle, \langle\vec{\mathbf{e}}\rangle\), 并将其作为图12的鲁棒3PC点积协议\(\Pi_\mathsf{dotPre}\)的输入, 计算\(\langle f \rangle\), 这里的\(f=\vec{\mathbf{d}}\odot \vec{\mathbf{e}}\). 给定\(\langle f \rangle\), \(\psi\)和\([\chi]\)的提取方式如下:</p>
\[\psi=f_2-\sum_{i=1}^n\gamma_{x_i}\gamma_{y_i}, [\chi]_1=f_1, [\chi]_2=f_0.
\]
<p>如此根据\(\langle\cdot\rangle\)-sharing语义, \(P_1,P_2\)可以得到\(f_2\), 进而得到\(\psi\), 同时\(P_0,P_1\)均可得到\(f_1\)进而得到\([\chi]_1\), \(P_0,P_2\)均可得到\(f_0\)进而得到\([\chi]_2\).</p>
<p>完整的点积计算协议如下图11. 预处理阶段的均摊通信量为\(3\ell\)比特, 在线阶段需要1轮, 均摊通信量为\(3\ell\)比特.</p>
<p>对于图12的具体协议, SWIFT中通过半诚实点积协议进行实例化, 并在验证阶段验证正确性, 通过适当地设定验证阶段参数可以给出一个均摊通信成本与向量长度几乎无关的\(\Pi_\mathsf{dotpPre}\). 见文章的附录B.</p>
<img src="media/16449265418549/16528739191826.png" alt="SWIFT1211" style="zoom: 33%;" />
<h4><a id="truncation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Truncation</h4>
<p>在定点数表示形式下进行乘法运算需要考虑截断问题, 设定点精度为\(d\). 与ABY3的截断方案类似, 服务器运行\(\Pi_\mathsf{trgen}\)协议生成截断对\(([r],[[r]]^d)\), 其中\(r\)是随机环元素, \(r^d\)是\(r\)的截断结果, 即\(r^d=r/2^d\). 给定\((r,r^d)\), 要截断的值\(v\), 截断结果表示为\(v^d=(v-r)^d+r^d\). 为了从\((r,r^d)\)的布尔分享中获得算术分享, 与ABY3需要多轮通信的方法不同, SWIFT中使用的是Trident中的方案, \(\Pi_\mathsf{trgen}\)实现布尔分享到算术分享的隐式转换只需2个点积运算的开销.</p>
<p>下面介绍如何生成所需的截断对\(([r],[[r]]^d)\). \(P_0,P_1\)随机采样\(r_1\), \(P_0,P_2\)随机采样\(r_2\). 设\(r\)的第\(i\)比特表示为\(r[i], i\in\{0,\cdots,\ell-1\}\), 定义\(r[i]=r_1[i]\oplus r_2[i]\), 则\(r^d[i]=r_1[i+d]\oplus r_2[i+d], i\in\{0,\cdots,\ell-d-1\}\). 更进一步地, 有</p>
\[\begin{aligned}
r&amp;=\sum_{i=0}^{\ell-1}2^ir[i]=\sum_{i=0}^{\ell-1}2^i(r_1[i]\oplus r_2[i])\\
&amp;=\sum_{i=0}^{\ell-1}2^i((r_1[i])^\mathsf R+(r_2[i])^\mathsf R-2(r_1[i])^\mathsf R\cdot(r_2[i])^\mathsf R)\\
&amp;=\sum_{i=0}^{\ell-1}2^i((r_1[i])^\mathsf R+(r_2[i])^\mathsf R)-\sum_{i=0}^{\ell-1}(2^{i+1}(r_1[i])^\mathsf R)\cdot(r_2[i])^\mathsf R.
\end{aligned}
\]
<p>类似地, 对于\(r^d\), 有</p>
\[r^d=\sum_{i=d}^{\ell-1}2^{i-d}((r_1[i])^\mathsf R+(r_2[i])^\mathsf R)-\sum_{i=d}^{\ell-1}(2^{i-d+1}(r_1[i])^\mathsf R)\cdot(r_2[i])^\mathsf R.
\]
<p>服务器通过表2的形式非交互生成\(r_1,r_2\)的每个比特的算术\([[\cdot]]\)份额. 然后执行两次\(\Pi_\mathsf{dotp}\)计算\(A=\sum_{i=d}^{\ell-1}(2^{i-d+1}(r_1[i])^\mathsf R)\cdot(r_2[i])^\mathsf R\)的份额\([[A]]\)和\(B=\sum_{i=0}^{\ell-1}(2^{i+1}(r_1[i])^\mathsf R)\cdot(r_2[i])^\mathsf R\)的份额\([[B]]\). 然后服务器各自根据以上两条等式本地计算\((r,r^d)\)的\([[\cdot]]\)份额.</p>
<p>然而服务器需要的并非\([[r]]\)份额而是\([r]\)份额. 将\([[r]]\)份额本地转换为\([r]\)份额的方式如下: 设\((\alpha_r,\beta_r,\gamma_r)\)是\([[r]]\)份额的相应参数. 因为\(P_0\)知道明文的\(r\)和\(\alpha_r\), 因此可以本地计算\(\beta_r=r+\alpha_r\). 然后\(P_0,P_1\)令\([r]_1=-[\alpha_r]_1\), \(P_0,P_2\)令\([r]_2=\beta-[\alpha_r]_2\).</p>
<p>整个\(\Pi_\mathsf{trgen}\)协议如下, 均摊通信量为\(12\ell\)比特.</p>
<img src="media/16449265418549/16528739182478.png" alt="image-20220102220515639" style="zoom: 33%;" />
<h4><a id="dot-product-with-truncation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dot Product with Truncation</h4>
<p>Dot Product with Truncation Protocol \(\Pi_\mathsf{dotpt}\): 允许服务器对点积计算结果\([[z]]\)进行截断得到\([[z^d]]\).  SWIFT中使用了BLAZE中相应的优化方案. 预处理阶段的均摊通信量为\(15\ell\)比特, 在线阶段需要1轮, \(3\ell\)比特的均摊通信量.</p>
<img src="media/16449265418549/16528739189432.png" alt="image-20220103113826973" style="zoom: 33%;" />
<h4><a id="secure-comparison" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secure Comparison</h4>
<p>在FPA表示法下两数比较大小只需通过\(\Pi_\mathsf{bitext}\)协议提取两数差值的最高有效位.</p>
<h4><a id="activation-functions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Activation Functions</h4>
<ul>
<li>ReLU函数: \(\mathsf{relu}(v)=\mathsf{max}(0,v)=\bar{b}\cdot v\), 其中\(\bar b=0\Leftrightarrow b=1\Leftrightarrow v&lt;0\), 反之\(\bar b=1\Leftrightarrow b=0\Leftrightarrow v\geq 0\). 因此关键在于抽取\(v\)的符号位, 在\([[v]]\)形式下可以通过\(\Pi_\mathsf{bitext}\)协议生成\([[b]]^\mathsf B\). 而\([[\bar b]]^\mathsf B\)可以令\(\beta_\bar{b}=1\oplus\beta_b\)本地计算求得. 最后将\([[\bar{b}]]^\mathsf B,[[v]]\)作为输入执行一次\(\Pi_\mathsf{BitInj}\)协议即得. 预处理阶段均摊通信量为\(21\ell-6\)比特, 在线阶段需要\(\log \ell+3\)轮, 均摊通信量为\(16\ell-6\)比特.</li>
<li>Sigmoid函数: 与SecureML相同, SWIFT通过分段函数来替代Sigmoid函数, 此时\(\mathsf{sig}(v)=\bar{b}_1b_2(v+1/2)+\bar{b}_2\), 其中\(v+1/2&lt;0\Leftrightarrow b_1=1\), \(v-1/2&lt;0\Leftrightarrow b_2=1\). 通过ReLU函数的方法来求解. 预处理阶段均摊通信量为\(39\ell-9\)比特, 在线阶段需要\(\log\ell+4\)轮, 均摊通信量为\(29\ell-9\)比特.</li>
</ul>
<h4><a id="maxpool-matrix-operations-and-convolutions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maxpool, Matrix Operations and Convolutions</h4>
<ul>
<li>Maxpool: 计算长度为\(m\)的向量\(\vec{\mathbf{x}}\)中的最大值. 两两成对进行比较, 并使用\(\Pi_\mathsf{BitInj}\)协议更新最大值.</li>
<li>矩阵乘法: 转化为点积计算.</li>
<li>卷积计算: 与SecureNN相同, 可以转化为矩阵乘法的计算.</li>
</ul>
<h2><a id="robust-4pc-and-ppml" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Robust 4PC and PPML</h2>
<p>SWIFT将3PC扩展到4PC, 不再需要调用广播, 点积计算与向量长度无关, 高效的主要原因是4PC的鲁棒JMP4原语\(\mathsf{jmp4}\). 由于4PC的实现原理多数与3PC类似, 因此下面除不同之处外, 不再展开.</p>
<h3><a id="4pc-secret-sharing-semantics" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4PC Secret Sharing Semantics</h3>
<p>扩展到4PC的\([[\cdot]]\)-sharing: 对于秘密\(v=\beta_v-[\alpha_v]_1-[\alpha_v]_2\), \(P_0\)的份额为\(([\alpha_v]_1,[\alpha_v]_2,\beta_v+\gamma_v)\), \(P_1\)的份额为\(([\alpha_v]_1,\beta_v,\gamma_v)\), \(P_2\)的份额为\(([\alpha_v]_2,\beta_v,\gamma_v)\), \(P_3\)的份额为\(([\alpha_v]_1,[\alpha_v]_2,\gamma_v)\). 易见, \(P_0,P_1,P_2\)的份额与3PC下的份额相同.</p>
<h3><a id="4pc-joint-message-passing-primitive" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4PC Joint Message Passing Primitive</h3>
<p>\(\mathsf{jmp4}\)原语允许\(P_i,P_j\)发送消息对\((v,\mathsf{H}(v'))\)给\(P_k\), 当\(P_k\)收到的信息不一致时, 设定不一致标志比特为1, 将服务器\(P_l\)作为TTP再进行相关明文计算. 称\(P_i,P_j\)通过jmp4-send发送\(v\)给\(P_k\)是指调用\(\Pi_\mathsf{jmp4}(P_i,P_j,P_k,v,P_l)\). 该原语比FLASH提出的双向传输(bi-convery)方案快2倍. 具体协议见图16, 在线阶段需要1轮, 均摊通信量为\(\ell\)比特.</p>
<img src="media/16449265418549/16528739191929.png" alt="SWIFT1516" style="zoom: 33%;" />
<h3><a id="4pc-protocols" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4PC Protocols</h3>
<h4><a id="sharing-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sharing Protocol</h4>
<p>Sharing Protocol \(\Pi_\mathsf{sh4}\): 在线阶段需要2轮, 当\(P_0,P_1,P_2\)分享秘密时, 均摊通信量为\(2\ell\)比特; 当\(P_3\)需要分享秘密时, 均摊通信量为\(3\ell\)比特.</p>
<img src="media/16449265418549/16528739184435.png" alt="image-20220104150347285" style="zoom: 33%;" />
<h4><a id="joint-sharing-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Joint Sharing Protocol</h4>
<p>Joint Sharing Protocol \(\Pi_\mathsf{jsh4}\): 允许服务器\((P_i,P_j)\)联合生成\([[v]]\), 其中\(v\)是\(P_i,P_j\)的共同秘密. 当发现信息存在不一致时, 将没有进行计算的那个服务器选为TTP. 在线阶段, 需要1轮, 当\((P_3,P_s), s\in\{0,1,2\}\)分享时, 均摊通信量为\(2\ell\)比特. 其他情况的均摊通信量为\(\ell\)比特.</p>
<p>特别地, 若\(v\)是\(P_0,P_1,P_2\)的共同秘密, 那么不需交互即可生成\([[v]]\)份额: 令\([\alpha_v]_1=[\alpha_v]_2=\gamma_v=0, \beta_v=v\).</p>
<p>若\(v\)是\(P_0,P_3\)的共同秘密, 那么可以只通信1个元素: \(P_0,P_1,P_3\)选取随机数\(r\), 令\([\alpha_v]=r\); \(P_0,P_3\)约定\([\alpha_v]_2=-(r+v)\), 然后jmp4-send发送\([\alpha_v]_2\)给\(P_2\).</p>
<img src="media/16449265418549/16528739192017.png" alt="image-20220104162456328" style="zoom: 33%;" />
<h4><a id="langle-cdot-rangle-sharing-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>\(\langle\cdot\rangle\)-sharing Protocol</h4>
<p>某些情况下, \(P_3\)需要在预处理阶段生成\(v\)的\(\langle \cdot\rangle\)-sharing, 其中\(v=v_0+v_1+v_2\), \(P_0\)持有\((v_0,v_1)\), \(P_1\)持有\((v_1,v_2)\), \(P_2\)持有\((v_2,v_0)\), 而\(P_3\)则有\((v_0,v_1,v_2)\). 具体协议\(\Pi_\mathsf{ash4}\)如下图19, 需要2轮, 均摊通信量为\(2\ell\)比特.</p>
<img src="media/16449265418549/16528739187498.png" alt="image-20220104172331359" style="zoom: 33%;" />
<p>此外, 服务器可以本地将\(\langle v\rangle\)转换为\([[v]]\), 只需按照下表5的方式约定他们的份额即可. 此时, \([\alpha_v]_1=-v_1, [\alpha_v]_2=-v_0,\beta_v=v_2,\gamma_v=-v_2\).</p>
<img src="media/16449265418549/16528739186591.png" alt="image-20220104195728881" style="zoom: 33%;" />
<h4><a id="multiplication-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiplication Protocol</h4>
<p>4PC下\([[\cdot]]\)-sharing的乘法协议\(\Pi_\mathsf{mult4}\). 预处理阶段需要\(3\ell\)比特的均摊通信量, 在线阶段需要1轮, \(3\ell\)比特的均摊通信量.</p>
<img src="media/16449265418549/16528739192958.png" alt="image-20220104193501814" style="zoom: 33%;" />
<h4><a id="reconstruction-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reconstruction Protocol</h4>
<p>4PC下给定\([[v]]\), 鲁棒地重构\(v\)的协议\(\Pi_\mathsf{rec4}\). 因为每个服务器都只缺少一个份额即可重构, 而该缺失份额其他三个服务器都有, 因此这三个服务器中的其中两个发送该缺失份额, 第三个发送该份额的Hash值以进行一致性检查. 与3PC下的乘法协议相比, 4PC下的乘法协议不需要使用承诺方案. 在线阶段需要1轮, 均摊通信量为\(8\ell\)比特.</p>
<img src="media/16449265418549/16528739192594.png" alt="image-20220104195527019" style="zoom: 33%;" />
<h3><a id="building-blocks-for-ppml-using-4pc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building Blocks for PPML using 4PC</h3>
<h4><a id="input-sharing-and-output-reconstruction-in-soc-setting" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Input Sharing and Output Reconstruction in SOC Setting</h4>
<p>下面将SOC场景中的3PC的输入分享和输出重构协议扩展到4PC. 其核心在于使用了拜占庭协定(Byzantine agreement, BA).</p>
<p>为了生成用户的输入\(v\)的\([[\cdot]]\)-sharing份额\([[v]]\), 用户从四个服务器中的三个中接收\([\alpha_v]_1,[\alpha_v]_2,\gamma_v\), 以及\(P_0,P_1,P_2\)共同选取的随机数\(r\), 接受其中大多数的那个\(r\). 用户本地计算\(u=v+[\alpha_v]_1+[\alpha_v]_2+\gamma_v+r\), 并发送\(u\)给所有服务器. 服务器执行两轮拜占庭协定接受\(u\)或者\(\perp\).</p>
<p>拜占庭协定过程如下: 设\(P_i\)接收到的来自用户的值为\(u_i\), 为达成协定, 服务器首先就\(P_i\)收到\(u_i\)达成一致, 为此, \(P_i\)首先发送\(u_i\)给所有服务器, 而这只需\(P_j\in\mathcal P\backslash P_i\)互相交换\(u_i\), 然后每个\(P_j\)从接收到的\(u_i\)的三个版本中选择最多的那个版本的\(u_i\)即可, 这由诚实大多数假设保证. 一旦协定完成, 每个服务器都将\(u_1,u_2,u_3,u_4\)中的占大多数的那个选为它们从用户接收到的值; 若没有任何一个出现占大多数, 那么就选择一个默认值.</p>
<p>BA完成后, \(P_0\)从\(u\)中本地计算\(\beta_v+\gamma_v\), 同时\(P_1,P_2\)从\(u\)中本地计算\(\beta_v\). 对于\(v\)的重构, 服务器发送它们的\([[v]]\)份额给用户, 用户选取每个份额中的占大多数的值重构输出. 在任何情况下, 如果协议识别出了TTP, 则所有服务器发送它们的份额给TTP, 由TTP选取每个份额中的占大多数的值计算功能函数的输出, 并把输出发给用户.  用户也从所有服务器中接收TTP的身份, 并接受来自占大多数的TTP的输出.</p>
<h4><a id="bit-extraction-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bit Extraction Protocol</h4>
<p>4PC下的比特抽取协议\(\Pi_\mathsf{bitext4}\): 为计算4PC下\([[v]]\)的最高有效位的布尔分享\([[\mathsf{msb}(v)]]^\mathsf B\), SWIFT仍使用了ABY3中优化的并行前缀加法器电路[Optimized Parallel Prefix Adder (PPA) circuit]方案. 因为\(v\)表示为\(v=\beta_v+(-\alpha_v)\), 因此该电路的两个输入分别为\(\beta_v, -\alpha_v\)的布尔分享\([[\beta_v]]^\mathsf B,[[-\alpha_v]]^\mathsf B\). \(P_1,P_2\)拥有\(\beta_v\), 可以通过\(\Pi_\mathsf{jsh4}\)协议生成\([[\beta_v]]^\mathsf B\). 同理, \(P_0,P_3\)生成\([[-\alpha_v]]^\mathsf B\). 于是通过优化的电路, 可计算出\([[\mathsf{msb}(v)]]^\mathsf B\). 该协议预处理阶段的均摊通信量为\(7\ell-6\)比特, 在线阶段需要1轮, 均摊通信量为\(7\ell-6\)比特.</p>
<h4><a id="bit2a-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bit2A Protocol</h4>
<p>4PC下的布尔分享与算术分享转换协议\(\Pi_\mathsf{bit2A4}\), 与3PC下的相比, 4PC下的原理在于:</p>
<p>设\(e=\alpha_b\oplus\gamma_b, c=\beta_b\oplus\gamma_b\), 则</p>
\[b^\mathsf R=(\alpha_b\oplus \beta_b)^\mathsf R=((\alpha_b\oplus\gamma_b)\oplus(\beta_b\oplus\gamma_b))^\mathsf R=(e\oplus c)^\mathsf R=e^\mathsf R+c^\mathsf R-2e^\mathsf Rc^\mathsf R.
\]
<p>\(\Pi_\mathsf{bit2A4}\)的预处理阶段均摊通信量为\(3\ell+4\)比特, 在线阶段需要1轮, 均摊通信量为\(3\ell\)比特.</p>
<img src="media/16449265418549/16528739199718.png" alt="image-20220105193218898" style="zoom:50%;" />
<h4><a id="bit-injection-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bit Injection Protocol</h4>
<p>比特映射协议\(\Pi_\mathsf{bitinj4}\): 给定比特\(b\)的布尔分享\([[b]]^\mathsf B\)和\(v\in\mathbb Z_{2^\ell}\)的算术分享\([[v]]\), 计算\([[bv]]\).</p>
<p>简单的方法是先把\([[b]]^\mathsf B\)通过\(\Pi_\mathsf{bit2A4}\)转化为\([[b]]\), 然后通过乘法协议\(\Pi_\mathsf{mul4}\)计算\([[bv]]\). 下面介绍一种减少预处理阶段和在线阶段通信量的方法.</p>
<p>记\(z=b^\mathsf Rv\), 注意到</p>
\[\begin{aligned}
z&amp;=b^\mathsf Rv=(\alpha_b\oplus\beta_b)^\mathsf R(\beta_v-\alpha_v)\\
&amp;=((\alpha_b\oplus\gamma_b)\oplus(\beta_b\oplus\gamma_b))^\mathsf R((\beta_v+\gamma_v)-(\alpha_v+\gamma_v))\\
&amp;=(c_b\oplus e_b)^\mathsf R(c_v-e_v)=(c_b^\mathsf R+e_b^\mathsf R-2c_b^\mathsf Re_b^\mathsf R)(c_v-e_v)\\
&amp;=c_b^\mathsf Rc_v-c_b^\mathsf Re_v+(c_v-2c_b^\mathsf Rc_v)e_b^\mathsf R+(2c_b^\mathsf R-1)e_b^\mathsf Re_v.
\end{aligned}
\]
<p>其中, \(c_b=\beta_b\oplus\gamma_b, e_b=\alpha_b\oplus\gamma_b,c_v=\beta_v+\gamma_v,e_v=\alpha_v+\gamma_v\).</p>
<p>具体协议如下图, 预处理阶段均摊通信量为\(6\ell+4\)比特, 在线阶段需要1轮, 均摊通信量为\(3\ell\)比特.</p>
<img src="media/16449265418549/16528739200723.png" alt="image-20220105220329517" style="zoom: 40%;" />
<h4><a id="dot-product" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dot Product</h4>
<p>4PC下的点积协议\(\Pi_\mathsf{dotp4}\). 预处理阶段需要\(3\ell\)比特的均摊通信量, 在线阶段需要1轮, \(3\ell\)比特的均摊通信量.</p>
<img src="media/16449265418549/16528739197650.png" alt="image-20220106094420778" style="zoom: 33%;" />
<h4><a id="truncation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Truncation</h4>
<p>4PC下的截断对生成协议\(\Pi_\mathsf{trgen4}\). 在线阶段需要1轮, \(\ell\)比特的均摊通信量.</p>
<img src="media/16449265418549/16528739197112.png" alt="image-20220106094541792" style="zoom:33%;" />
<h4><a id="dot-product-with-truncation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dot Product with Truncation</h4>
<p>4PC下的点积截断协议\(\Pi_\mathsf{dotpt4}\). 预处理阶段需要\(4\ell\)比特的均摊通信量, 在线阶段需要1轮, \(3\ell\)比特的均摊通信量.</p>
<img src="media/16449265418549/16528739203800.png" alt="image-20220106094635955" style="zoom:33%;" />
<h4><a id="activation-functions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Activation Functions</h4>
<ul>
<li>ReLU函数计算: 预处理阶段均摊通信量为\(13\ell-2\)比特, 在线阶段需要\(\log\ell+1\)轮, 均摊通信量为\(10\ell-6\)比特.</li>
<li>Sigmoid函数: 预处理阶段均摊通信量为\(23\ell-1\)比特, 在线阶段需要\(\log\ell+2\)轮, 均摊通信量为\(20\ell-9\)比特.</li>
</ul>
<h2><a id="experiment" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Experiment</h2>
<h3><a id="logistic-regression" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Logistic Regression</h3>
<img src="media/16449265418549/16528739197949.png" alt="image-20220106111858354" style="zoom:40%;" />
<h3><a id="nn-inference" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NN Inference</h3>
<p><img src="media/16449265418549/16528739158708.png" alt="SWIFTT78" /></p>
<h2><a id="conclusion" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h2>
<p>本文提出了一个高效PPML框架SWIFT, 实现了输出可达性(GOD)的更强安全需求，其中3PC协议基于BLAZE且实现GOD而无额外开销. 4PC协议基于实现GOD的FLASH和实现Fairness的Trident. SWIFT框架能实现GOD的关键在于文章所引入的Joint message passing原语，若发现信息不一致，则会选出一个必为诚实参与方的TTP进行明文计算. 而减少通信开销的关键仍在于试图让点积运算的开销最小化, 即使开销独立于向量长度.</p>
<h2><a id="references" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>References</h2>
<p>[1] A. Patra and A. Suresh. BLAZE: Blazing Fast Privacy-Preserving Machine Learning. NDSS, 2020.</p>
<p>[2] A. Dalskov, D. Escudero, and M. Keller. Fantastic Four: Honest-Majority Four-Party Secure Computation With Malicious Security. USENIX, 2021.</p>
<p>[3] H. Chaudhari, R. Rachuri, and A. Suresh. Trident: Efficient 4PC Framework for Privacy Preserving Machine Learning. NDSS, 2020.</p>
<p>[4] M. Byali, H. Chaudhari, A. Patra, and A. Suresh. FLASH: fast and robust framework for privacy-preserving machine learning. PETS, 2020.</p>
<p>[5] B. Alon, E. Omri, and A. Paskin-Cherniavsky. MPC with Friends and Foes. CRYPTO, 2020.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Privacy Preserving Machine Learning Resources]]></title>
    <link href="https://weiviming.github.io/16434684624710.html"/>
    <updated>2022-01-29T23:01:02+08:00</updated>
    <id>https://weiviming.github.io/16434684624710.html</id>
    <content type="html"><![CDATA[
<h2><a id="about" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>About</h2>
<p>This is a current list of resources related to the research and development of privacy-preserving machine learning.</p>
<h2><a id="secure-machine-learning" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secure Machine Learning</h2>
<ul>
<li><a href="https://eprint.iacr.org/2014/331.pdf">Machine Learning Classification over Encrypted Data, NDSS'14</a></li>
<li><a href="https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/ohrimenko">Oblivious Multi-Party Machine Learning on Trusted Processors, USENIX Security'16</a></li>
<li><a href="https://www.usenix.org/conference/nsdi17/technical-sessions/presentation/corrigan-gibbs">Prio: Private, Robust, and Scalable Computation of Aggregate Statistics, NSDI'17</a></li>
<li><a href="https://eprint.iacr.org/2017/396">SecureML: A System for Scalable Privacy-Preserving Machine Learning, S&amp;P'17</a></li>
<li><a href="https://acmccs.github.io/papers/p619-liuA.pdf">MiniONN: Oblivious Neural Network Predictions via MiniONN Transformations, CCS'17</a></li>
<li><a href="https://eprint.iacr.org/2017/1164">Chameleon: A Hybrid Secure Computation Framework for Machine Learning Applications, AsiaCCS'17</a></li>
<li><a href="https://arxiv.org/abs/1705.08963">DeepSecure: Scalable Provably-Secure Deep Learning, DAC'17</a></li>
<li><a href="https://arxiv.org/abs/1901.00329">Secure Computation for Machine Learning With SPDZ, NIPS'18</a></li>
<li><a href="https://eprint.iacr.org/2018/403.pdf">ABY3: A Mixed protocol Framework for Machine Learning, CCS'18</a></li>
<li><a href="https://eprint.iacr.org/2018/442.pdf">SecureNN: Efficient and Private Neural Network Training, PoPETs'18</a></li>
<li><a href="https://arxiv.org/abs/1801.05507">Gazelle: A Low Latency Framework for Secure Neural Network Inference, USENIX Security'18</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=3314628">CHET: an optimizing compiler for fully-homomorphic neural-network inferencing, PLDI'19</a></li>
<li><a href="https://eprint.iacr.org/2019/599.pdf">New Primitives for Actively-Secure MPC over Rings with Applications to Private Machine Learning, S&amp;P'19</a></li>
<li><a href="https://ieeexplore.ieee.org/abstract/document/8835215">Helen: Maliciously Secure Coopetitive Learning for Linear Models, S&amp;P'19</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=3363207">Efficient multi-key homomorphic encryption with packed ciphertexts with application to oblivious neural network inference. CCS'19</a></li>
<li><a href="https://www.usenix.org/conference/usenixsecurity19/presentation/riazi">XONN: XNOR-based Oblivious Deep Neural Network Inference, USENIX Security'19</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=3339819">QUOTIENT: two-party secure neural network training and prediction, CCS'19</a></li>
<li><a href="https://content.sciendo.com/view/journals/poPoPETs/2020/4/article-p355.xml">Secure Evaluation of Quantized Neural Networks, PoPETs'20</a></li>
<li><a href="https://eprint.iacr.org/2019/429">ASTRA: High Throughput 3PC over Rings with Application to Secure Prediction, CCSW'19</a></li>
<li><a href="https://eprint.iacr.org/2018/1099.pdf">SoK: Modular and Efficient Private Decision Tree Evaluation, PoPETs'19</a></li>
<li><a href="https://eprint.iacr.org/2019/1315">Trident: Efficient 4PC Framework for Privacy Preserving Machine Learning, NDSS'20</a></li>
<li><a href="https://eprint.iacr.org/2020/042">BLAZE: Blazing Fast Privacy-Preserving Machine Learning, NDSS'20</a></li>
<li><a href="https://eprint.iacr.org/2019/1365">FLASH: Fast and Robust Framework for Privacy-preserving Machine Learning, PoPETs'20</a></li>
<li><a href="https://eprint.iacr.org/2020/050">Delphi: A Cryptographic Inference Service for Neural Networks, USENIX Security'20</a></li>
<li><a href="https://dl.acm.org/doi/abs/10.1145/3404397.3404399">ParSecureML: An Efficient Parallel Secure Machine Learning Framework on GPUs, ICPP'20</a></li>
<li><a href="https://arxiv.org/abs/2004.02229">FALCON: Honest-Majority Maliciously Secure Framework for Private Deep Learning, PoPETs'21</a></li>
<li><a href="https://dl.acm.org/doi/abs/10.1145/3407023.3407045">MP2ML: A Mixed-Protocol Machine Learning Framework for Private Inference, ARES'20</a></li>
<li><a href="https://www.usenix.org/conference/usenixsecurity20/presentation/chen-hao">SANNS: Scaling Up Secure Approximate k-Nearest Neighbors Search, USENIX Security'20</a></li>
<li><a href="https://arxiv.org/abs/1811.04017">PySyft: A Generic Framework for Privacy Preserving Deep Learning</a></li>
<li><a href="https://arxiv.org/abs/1810.08130">Private Deep Learning in TensorFlow Using Secure Computation</a></li>
<li><a href="https://arxiv.org/abs/1711.05189">CryptoDL: Deep Neural Networks over Encrypted Data</a></li>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/04/CryptonetsTechReport.pdf">CryptoNets: Applying Neural Networks to Encrypted Data with High Throughput and Accuracy</a></li>
<li><a href="https://eprint.iacr.org/2019/1049.pdf">CrypTFlow: Secure TensorFlow Inference</a></li>
<li><a href="https://arxiv.org/abs/2010.06457">CrypTFlow2: Practical 2-Party Secure Inference, CCS'20</a></li>
<li><a href="https://content.sciendo.com/view/journals/poPoPETs/2020/4/article-p414.xml">Practical Privacy-Preserving K-means Clustering, PoPETs'20</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-030-58951-6_21">An Efficient 3-Party Framework for Privacy-Preserving Neural Network Inference, ESORICS'20</a></li>
<li><a href="https://dl.acm.org/doi/abs/10.1145/3427228.3427232">Secure and Verifiable Inference in Deep Neural Networks, ACSAC'20</a></li>
<li><a href="https://www.eurecom.fr/publication/6475/download/sec-publi-6475.0.pdf">Privacy-preserving Density-based Clustering, AisaCCS'21</a></li>
<li><a href="https://eprint.iacr.org/2021/459">SIRNN: A Math Library for Secure RNN Inference, S&amp;P'21</a></li>
<li><a href="https://www.ndss-symposium.org/ndss-paper/lets-stride-blindfolded-in-a-forest-sublinear-multi-client-decision-trees-evaluation/">Let’s Stride Blindfolded in a Forest: Sublinear Multi-Client Decision Trees Evaluation, NDSS'21</a></li>
<li><a href="https://people.eecs.berkeley.edu/~raluca/MUSEcamera.pdf">MUSE: Secure Inference Resilient to Malicious Clients, USENIX Security'21</a></li>
<li><a href="https://arxiv.org/abs/2103.01396">DeepReDuce: ReLU Reduction for Fast Private Inference, ICML'21</a></li>
<li><a href="https://eprint.iacr.org/2019/338.pdf">Garbled Neural Networks are Practical</a></li>
<li><a href="https://www.usenix.org/conference/usenixsecurity21/presentation/ng">GForce: GPU-Friendly Oblivious and Rapid Neural Network Inference, USENIX Security'21</a></li>
<li><a href="http://arxiv.org/abs/2104.10949">CryptGPU: Fast Privacy-Preserving Machine Learning on the GPU, S&amp;P'21</a></li>
<li><a href="https://www.ndss-symposium.org/ndss-paper/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/">GALA : Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks, NDSS'21</a></li>
<li><a href="https://arxiv.org/abs/2005.10296">SWIFT: Super-fast and Robust Privacy-Preserving Machine Learning, USENIX Security'21</a></li>
<li><a href="https://www.usenix.org/system/files/sec21fall-dalskov.pdf">Fantastic Four: Honest-Majority Four-Party Secure Computation With Malicious Security, USENIX Security'21</a></li>
<li><a href="https://arxiv.org/abs/2008.08753">When homomorphic encryption marries secret sharing: secure large-scale sparse logistic regression and applications in risk control, KDD'21</a></li>
<li><a href="https://arxiv.org/pdf/1911.07101.pdf">Glyph: Fast and Accurately Training Deep Neural Networks on Encrypted Data, NeurIPS'20</a></li>
<li><a href="https://eprint.iacr.org/2021/730">Mystique: Efficient Conversions for Zero-Knowledge Proofs with Applications to Machine Learning, USENIX Security'21</a></li>
<li><a href="https://eprint.iacr.org/2021/809">SoK: Efficient Privacy-preserving Clustering, PoPETs'21</a></li>
<li><a href="https://eprint.iacr.org/2021/087/20210127:132648">ZEN: Efficient Zero-Knowledge Proofs for Neural Networks</a></li>
<li><a href="https://eprint.iacr.org/2021/673">zkCNN: Zero Knowledge Proofs for Convolutional Neural Network Predictions and Accuracy</a></li>
<li><a href="https://arxiv.org/abs/2107.00501">Secure Quantized Training for Deep Learning</a></li>
<li><a href="https://www.usenix.org/conference/usenixsecurity21/presentation/zheng">Cerebro: A Platform for Multi-Party Cryptographic Collaborative Learning, USENIX Security'21</a></li>
<li><a href="https://proceedings.neurips.cc/paper/2021/file/11eba2991cc62daa4a85be5c0cfdae97-Paper.pdf">Circa: Stochastic ReLUs for Private Deep Learning, NeurIPS'21</a></li>
<li><a href="https://arxiv.org/abs/2106.02850">Tetrad: Actively Secure 4PC for Secure Training and Inference, NDSS'22</a></li>
<li><a href="https://arxiv.org/abs/2106.02203">Adam in Private: Secure and Fast Training of Deep Neural Networks with Adaptive Moment Estimation</a></li>
<li><a href="https://www.usenix.org/conference/usenixsecurity22/presentation/chandran">SIMC: ML Inference Secure Against Malicious Clients at Semi-Honest Cost, USENIX Security'22</a></li>
<li><a href="https://eprint.iacr.org/2022/207">Cheetah: Lean and Fast Secure Two-Party Deep Neural Network Inference, USENIX Security'22</a></li>
<li><a href="https://eprint.iacr.org/2022/322.pdf">SecFloat: Accurate Floating-Point meets Secure 2-Party Computation, S&amp;P'22</a></li>
<li><a href="https://arxiv.org/abs/2006.04593">ARIANN: Low-Interaction Privacy-Preserving Deep Learning via Function Secret Sharing, PoPETs'22</a></li>
</ul>
<h2><a id="secure-federated-learning" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secure Federated Learning</h2>
<ul>
<li><a href="https://dl.acm.org/citation.cfm?id=2813687">Privacy-Preserving Deep Learning, CCS'15</a></li>
<li><a href="https://eprint.iacr.org/2017/281.pdf">Practical Secure Aggregation for Privacy Preserving Machine Learning, CCS'17</a></li>
<li><a href="https://ieeexplore.ieee.org/document/8241854">Privacy-Preserving Deep Learning via Additively Homomorphic Encryption, TIFS'17</a></li>
<li><a href="http://cacr.uwaterloo.ca/techreports/2018/cacr2018-10.pdf">NIKE-based Fast Privacy-preserving High-dimensional Data Aggregation for Mobile Devices, CACR'18</a></li>
<li><a href="https://eprint.iacr.org/2019/979.pdf">PrivFL: Practical Privacy-preserving Federated Regressions on High-dimensional Data over Mobile Networks, CCSW'19</a></li>
<li><a href="https://ieeexplore.ieee.org/abstract/document/8765347">VerifyNet: Secure and verifiable federated learning, TIFS'19</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-030-58951-6_20">PrivColl: Practical Privacy-Preserving Collaborative Machine Learning</a></li>
<li><a href="https://ieeexplore.ieee.org/abstract/document/8981947">NPMML: A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning, TDSC'20</a></li>
<li><a href="http://www.jos.org.cn/jos/article/abstract/6052">机器学习隐私保护研究综述, 软件学报'20</a></li>
<li><a href="https://arxiv.org/abs/2007.14861">SAFER: Sparse secure Aggregation for FEderated leaRning</a></li>
<li><a href="https://arxiv.org/abs/2006.04747">Secure Byzantine-Robust Machine Learning</a></li>
<li><a href="https://eprint.iacr.org/2020/704.pdf">Secure Single-Server Aggregation with (Poly)Logarithmic Overhead, CCS'20</a></li>
<li><a href="https://www.usenix.org/conference/atc20/presentation/zhang-chengliang">Batchcrypt: Efficient homomorphic encryption for cross-silo federated learning, USENIX ATC'21</a></li>
<li><a href="https://arxiv.org/abs/2003.10637">FedSel: Federated SGD under Local Differential Privacy with Top-k Dimension Selection, DASFAA'20</a></li>
<li><a href="https://eprint.iacr.org/2021/025">FLGUARD: Secure and Private Federated Learning, Cryptology Eprint'21</a></li>
<li><a href="https://ieeexplore.ieee.org/document/9292450">Biscotti: A Blockchain System for Private and Secure Federated Learning, TPDS'21</a></li>
<li><a href="https://arxiv.org/abs/2009.00349">POSEIDON: Privacy-Preserving Federated Neural Network Learning, NDSS'21</a></li>
<li><a href="https://arxiv.org/abs/2104.14380">PPFL: Privacy-preserving Federated Learning with Trusted Execution Environments, MobiSys'21</a></li>
</ul>
<h2><a id="mpc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MPC</h2>
<ul>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-642-14577-3_6">Secure computation with fixed-point numbers, FC'10</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-642-32009-5_38">Multiparty computation from somewhat homomorphic encryption, Crypto'12</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-642-39884-1_23">GMW vs. Yao? Efficient secure two-party computation with low depth circuits, FC'13</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-642-40203-6_1">Practical covertly secure MPC for dishonest majority–or: breaking the SPDZ limits, ESORICS'13</a></li>
<li><a href="https://eprint.iacr.org/2012/405.pdf">Secure Computation on Floating Point Numbers, NDSS'13</a></li>
<li><a href="https://crad.ict.ac.cn/CN/10.7544/issn1000-1239.2015.20150763">实用安全多方计算协议关键技术研究进展, 计算机研究与发展'15</a></li>
<li><a href="https://encrypto.de/papers/DSZ15.pdf">ABY: A Framework for Efficient Mixed-Protocol Secure Two-Party Computation, NDSS'15</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=2978357">MASCOT: faster malicious arithmetic secure computation with oblivious transfer, CCS'16</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-319-96881-0_26">SPDZ^2k: Efficient MPC mod 2^k for Dishonest Majority, Crypto'18</a></li>
<li><a href="https://eprint.iacr.org/2017/1230">Overdrive^2k: Making SPDZ Great Again</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=2978331">High-Throughput Semi-Honest Secure Three-Party Computation with an Honest Majority, CCS'16</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-540-88313-5_13">Sharemind: A framework for fast privacy-preserving computations, ESORICS'08</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=2660366">Efficiently Verifiable Computation on Encrypted Data, CCS'14</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/3243734.3243837">Secure outsourced matrix computation and application to neural networks, CCS'18</a></li>
<li><a href="https://dl.acm.org/doi/abs/10.1145/3292500.3330920">PrivPy: General and Scalable Privacy-Preserving Data Mining, KDD'19</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/3372297.3417872">MP-SPDZ: A Versatile Framework for Multi-Party Computation, CCS'20</a></li>
<li><a href="https://www.usenix.org/conference/usenixsecurity21/presentation/poddar">Senate: A Maliciously-Secure MPC Platform for Collaborative Analytics, USENIX Security'20</a></li>
<li><a href="https://eprint.iacr.org/2020/338.pdf">Improved primitives for mpc over mixed arithmetic-binary circuits, CRYPTO'20</a></li>
<li><a href="https://eprint.iacr.org/2020/1137">MOTION - A Framework for Mixed-Protocol Multi-Party Computation, TOPS'21</a></li>
<li><a href="https://eprint.iacr.org/2020/1225.pdf">ABY2.0: Improved Mixed-Protocol Secure Two-Party Computation, USENIX Security'21</a></li>
<li><a href="https://encrypto.de/papers/PSSY21HOST.pdf">SynCirc: Efficient Synthesis of Depth-Optimized Circuits for Secure Computation, HOST'21</a></li>
<li><a href="https://www.usenix.org/conference/osdi21/presentation/kumar">MAGE: Nearly Zero-Cost Virtual Memory for Secure Computation, USENIX OSDI'21</a></li>
<li><a href="https://eprint.iacr.org/2021/1493.pdf">VASA : Vector AES Instructions for Security Applications, ACSAC'21</a></li>
<li><a href="https://eprint.iacr.org/2021/833">ATLAS: Efficient and Scalable MPC in the Honest Majority Setting, CRYPTO'21</a></li>
</ul>
<h2><a id="federated-learning" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Federated Learning</h2>
<h3><a id="communication-optimization" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Communication Optimization</h3>
<ul>
<li><a href="http://papers.nips.cc/paper/6749-terngrad-ternary-gradients-to-reduce-communication-in-distributed-deep-learning">Terngrad: Ternary gradients to reduce communication in distributed deep learning, NIPS'17</a></li>
<li><a href="https://papers.nips.cc/paper/2018/hash/314450613369e0ee72d0da7f6fee773c-Abstract.html">The Convergence of Sparsified Gradient Methods, NIPS'18</a></li>
</ul>
<h3><a id="byzantine-tolerant" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Byzantine-Tolerant</h3>
<ul>
<li><a href="http://papers.nips.cc/paper/6617-machine-learning-with-adversaries-byzantine-tolerant-gradient-descent">Machine Learning with Adversaries: Byzantine Tolerant Gradient Descent, NIPS'17</a></li>
<li><a href="https://papers.nips.cc/paper/2018/file/a07c2f3b3b907aaf8436a26c6d77f0a2-Paper.pdf">Byzantine stochastic gradient descent, NIPS'18</a></li>
<li><a href="https://arxiv.org/abs/1802.07927">The Hidden Vulnerability of Distributed Learning in Byzantium, ICML'18</a></li>
<li><a href="https://arxiv.org/abs/1803.01498">Byzantine-Robust Distributed Learning: Towards Optimal Statistical Rates, ICML'18</a></li>
<li><a href="https://www.usenix.org/conference/usenixsecurity20/presentation/fang">Local Model Poisoning Attacks to Byzantine-Robust Federated Learning, USENIX Security'20</a></li>
<li><a href="https://arxiv.org/abs/2012.13995">FLTrust: Byzantine-robust Federated Learning via Trust Bootstrapping, NDSS'21</a></li>
<li><a href="https://www.ndss-symposium.org/ndss-paper/manipulating-the-byzantine-optimizing-model-poisoning-attacks-and-defenses-for-federated-learning/">Manipulating the Byzantine: Optimizing Model Poisoning Attacks and Defenses for Federated Learning, NDSS'21</a></li>
<li><a href="https://www.usenix.org/system/files/sec20-pan.pdf">Justinian’s GAAvernor: Robust Distributed Learning with Gradient Aggregation Agent, USENIX Security'20</a></li>
<li><a href="https://arxiv.org/pdf/2105.02295.pdf">Byzantine-robust and privacy-preserving framework for FEDML, ICLR Workshop'21</a></li>
<li><a href="http://proceedings.mlr.press/v139/karimireddy21a/karimireddy21a.pdf">Learning from History for Byzantine Robust Optimization, ICML'21</a></li>
<li><a href="https://arxiv.org/abs/2101.02281">FLAME: Taming backdoors in federated learning, USENIX Security'22</a></li>
</ul>
<h2><a id="privacy-leakages-of-mlfl" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Privacy Leakages of ML/FL</h2>
<ul>
<li><a href="https://ieeexplore.ieee.org/abstract/document/7958568">Membership inference attacks against machine learning models, S&amp;P'17</a></li>
<li><a href="https://ieeexplore.ieee.org/abstract/document/8835245">Comprehensive privacy analysis of deep learning: Passive and active white-box inference attacks against centralized and federated learning, S&amp;P'19</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-030-58951-6_24">Data Poisoning Attacks Against Federated Learning Systems, ESORICS'20</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-030-58951-6_27">A Framework for Evaluating Client Privacy Leakages in Federated Learning, ESORICS'20</a></li>
<li><a href="https://www.computer.org/csdl/magazine/sp/2021/04/09433648/1tHMTWXyaUE">A Critical Overview of Privacy in Machine Learning, IEEE Security &amp; Privacy'21</a></li>
</ul>
<h2><a id="blogs" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Blogs</h2>
<ul>
<li><a href="https://mortendahl.github.io/">Cryptography and Machine Learning: Mixing both for private data analysis</a></li>
<li><a href="https://iamtrask.github.io/2017/03/17/safe-ai/">Building Safe A.I.: A Tutorial for Encrypted Deep Learning</a></li>
<li><a href="https://github.com/rdragos/awesome-mpc">Awesome MPC: Curated List of resources for MPC</a></li>
<li><a href="https://www.zhihu.com/column/c_1121838720017338368">知乎专栏: 机器学习隐私保护</a></li>
<li><a href="https://github.com/Ye-D/PaperNotes-MPC">Github专栏: 机器学习隐私保护</a></li>
<li><a href="https://www.zhihu.com/column/c_1380808297608613888">知乎专栏: 安全多方计算学习笔记</a></li>
</ul>
<h2><a id="libraries-and-frameworks" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Libraries and Frameworks</h2>
<ul>
<li><a href="https://github.com/esonghori/TinyGarble">TinyGarble: Logic Synthesis and Sequential Descriptions for Yao's Garbled Circuits</a></li>
<li><a href="https://github.com/bristolcrypto/SPDZ-2">SPDZ-2: Multiparty computation with SPDZ, MASCOT, and Overdrive offline phases</a></li>
<li><a href="https://github.com/encryptogroup/aby">ABY: A Framework for Efficient Mixed-Protocol Secure Two-Party Computation</a></li>
<li><a href="http://oblivc.org/">Obliv - C: C compiler for embedding privacy preserving protocols:</a></li>
<li><a href="https://github.com/tfhe/tfhe">TFHE: Fast Fully Homomorphic Encryption Library over the Torus</a></li>
<li><a href="https://www.microsoft.com/en-us/research/project/simple-encrypted-arithmetic-library/">SEAL: Simple Encypted Arithmatic Library</a></li>
<li><a href="https://github.com/Lab41/PySEAL">PySEAL: Python interface to SEAL</a></li>
<li><a href="https://github.com/shaih/HElib%5D">HElib: An Implementation of homomorphic encryption</a></li>
<li><a href="https://github.com/mpc-msri/EzPC">EzPC: programmable, efficient, and scalable secure two-party computation for machine learning</a></li>
<li><a href="https://github.com/vernamlab/cuFHE">CUDA-accelerated Fully Homomorphic Encryption Library</a></li>
<li><a href="https://github.com/facebookresearch/CrypTen">CrypTen: A framework for Privacy Preserving Machine Learning</a></li>
<li><a href="https://github.com/tf-encrypted/tf-encrypted">tf-encrypted: A Framework for Machine Learning on Encrypted Data</a></li>
<li><a href="https://sourceforge.net/projects/sharemind/">Sharemind</a></li>
<li><a href="https://github.com/data61/python-paillier">PythonPaillier</a></li>
<li><a href="https://github.com/OpenMined/TenSEAL">TenSEAL</a></li>
<li><a href="https://github.com/data61/MP-SPDZ">MP-SPDZ</a></li>
<li><a href="https://github.com/snwagh/securenn-public">Securenn-public</a></li>
<li><a href="https://github.com/FudanMPL/SecMML">SecMML</a></li>
<li><a href="https://github.com/csiro-mlai/mnist-mpc">mnist-mpc</a></li>
<li><a href="https://github.com/bit-ml/Private-Set-Intersection">Private-Set-Intersection</a></li>
<li><a href="https://github.com/snwagh/falcon-public">falcon-public</a></li>
<li><a href="https://github.com/LatticeX-Foundation/Rosetta">Rosetta</a></li>
<li><a href="https://github.com/alipay/Antchain-MPC">Antchain-MPC</a></li>
<li><a href="https://github.com/yuchen1024/Kunlun">Kunlun</a></li>
<li><a href="https://github.com/encryptogroup/MOTION2NX">MOTION2NX</a></li>
<li><a href="https://github.com/anderspkd/SecureQ8">SecureQ8</a></li>
<li><a href="https://github.com/mkskeller/mpc-benchmarks">mpc-benchmarks</a></li>
<li><a href="https://github.com/mc2-project/muse">muse</a></li>
<li><a href="https://github.com/Ye-D/PPML-Resource">ABY3: A Three Party MPC framework for Machine learning and Databases</a></li>
<li><a href="https://www.win.tue.nl/~berry/mpyc/">MPyC: MPyC for Secure Multiparty Computation in Python</a></li>
<li><a href="https://github.com/OpenMined/SyMPC">SyMPC: A SMPC companion library for Syft</a></li>
</ul>
<p>来源: <a href="https://github.com/WeiViming/PPML-Resource">Materials about Privacy-Preserving Machine Learning</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安全与密码会议排名]]></title>
    <link href="https://weiviming.github.io/16425853998520.html"/>
    <updated>2022-01-19T17:43:19+08:00</updated>
    <id>https://weiviming.github.io/16425853998520.html</id>
    <content type="html"><![CDATA[
<p>根据<a href="https://people.engr.tamu.edu/guofei/sec_conf_stat.htm">Guofei Gu</a>的Computer Security Conference Ranking为主排名, 列出了部分会议的中国计算机协会(CCF)2019年版会议分级和中国密码协会(CACR)2018年版会议分级, 其中CCF分级以网络与信息安全为基准.</p>
<table>
<thead>
<tr>
<th style="text-align: center">级别</th>
<th style="text-align: center">会议全称</th>
<th style="text-align: center">会议简称</th>
<th style="text-align: center">会议类型</th>
<th style="text-align: center">CCF分级</th>
<th style="text-align: center">CACR分级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">1</td>
<td style="text-align: center">IEEE Symposium on Security and Privacy</td>
<td style="text-align: center"><a href="http://www.ieee-security.org/TC/SP-Index.html">S&amp;P</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">A</td>
<td style="text-align: center">A</td>
</tr>
<tr>
<td style="text-align: center">1</td>
<td style="text-align: center">ACM Conference on Computer and Communications Security</td>
<td style="text-align: center"><a href="http://www.sigsac.org/ccs.html">CCS</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">A</td>
<td style="text-align: center">A</td>
</tr>
<tr>
<td style="text-align: center">1</td>
<td style="text-align: center">USENIX Security Symposium</td>
<td style="text-align: center"><a href="https://www.usenix.org/conferences/byname/108">USENIX Security</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">A</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">1</td>
<td style="text-align: center">ISOC Network and Distributed System Security Symposium</td>
<td style="text-align: center"><a href="https://www.ndss-symposium.org/">NDSS</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">B</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">1</td>
<td style="text-align: center">International Cryptology Conference</td>
<td style="text-align: center"><a href="http://www.iacr.org/conferences/">Crypto</a></td>
<td style="text-align: center">密码</td>
<td style="text-align: center">A</td>
<td style="text-align: center">A</td>
</tr>
<tr>
<td style="text-align: center">1</td>
<td style="text-align: center">European Cryptology Conference</td>
<td style="text-align: center"><a href="http://www.iacr.org/conferences/">Eurocrypt</a></td>
<td style="text-align: center">密码</td>
<td style="text-align: center">A</td>
<td style="text-align: center">A</td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">European Symposium on Research in Computer Security</td>
<td style="text-align: center"><a href="http://www.laas.fr/~esorics/">ESORICS</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">B</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">International Symposium on Recent Advances in Intrusion Detection</td>
<td style="text-align: center"><a href="http://www.raid-symposium.org/">RAID</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">B</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">Annual Computer Security Applications Conference</td>
<td style="text-align: center"><a href="http://www.acsac.org/">ACSAC</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">B</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">The International Conference on Dependable Systems and Networks</td>
<td style="text-align: center"><a href="http://www.dsn.org/">DSN</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">B</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">Internet Measurement Conference</td>
<td style="text-align: center"><a href="http://www.sigcomm.org/events/imc-conference">IMC</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">ACM Symposium on Information, Computer and Communications Security</td>
<td style="text-align: center"><a href="http://www.sigsac.org/">ASIACCS</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center">B</td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">Privacy Enhancing Technologies Symposium</td>
<td style="text-align: center"><a href="http://petsymposium.org/">PETS</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">IEEE European Symposium on Security and Privacy</td>
<td style="text-align: center"><a href="http://www.ieee-security.org/TC/SP-Index.html">EuroS&amp;P</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">EEE Computer Security Foundations Symposium.<br/>Supersedes CSFW (Computer Security Foundations Workshop)</td>
<td style="text-align: center"><a href="http://www.ieee-security.org/CSFWweb/">CSF</a> <br>(CSFW)</td>
<td style="text-align: center">安全</td>
<td style="text-align: center">B</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">International Conference on the Theory and Application of Cryptology and Information Security</td>
<td style="text-align: center"><a href="http://www.iacr.org/conferences/">Asiacrypt</a></td>
<td style="text-align: center">密码</td>
<td style="text-align: center">B</td>
<td style="text-align: center">A</td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">Theory of Cryptography Conference</td>
<td style="text-align: center"><a href="https://www.iacr.org/meetings/tcc/">TCC</a></td>
<td style="text-align: center">密码</td>
<td style="text-align: center">B</td>
<td style="text-align: center">B</td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">Conference on Cryptographic Hardware and Embedded Systems</td>
<td style="text-align: center"><a href="https://ches.iacr.org/">CHES</a></td>
<td style="text-align: center">密码</td>
<td style="text-align: center">B</td>
<td style="text-align: center">B</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">Internation Conference on Security and Privacy in Communication Networks</td>
<td style="text-align: center"><a href="http://www.securecomm.org/">SecureComm</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">IEEE Conference on Communications and Network Security</td>
<td style="text-align: center"><a href="http://www.ieee-cns.org/">CNS</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">GI SIG SIDAR Conference on Detection of Intrusions and Malware and Vulnerability Assessment</td>
<td style="text-align: center"><a href="http://www.dimva.org/">DIMVA</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">International Conference on Applied Cryptography and Network Security</td>
<td style="text-align: center"><a href="http://jianying.space/acns/">ACNS</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center">C</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">ACM Symposium on Applied Computing</td>
<td style="text-align: center"><a href="http://www.acm.org/conferences/sac/">SAC</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">Australasia Conference on Information Security and Privacy</td>
<td style="text-align: center">ACISP</td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center">C</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">International Conference on Information and Communications Security</td>
<td style="text-align: center"><a href="http://www.icics.cn/">ICICS</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">Information Security Conference</td>
<td style="text-align: center">ISC</td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center">C</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">International Conference on Information Security and Cryptology</td>
<td style="text-align: center"><a href="http://www.icisc.org/">ICISC</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center"></td>
<td style="text-align: center">C</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">ACM Symposium on Access Control Models and Technologies</td>
<td style="text-align: center"><a href="http://www.sacmat.org/">SACMAT</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">IFIP International Information Security Conference</td>
<td style="text-align: center"><a href="http://www.ifipsec.org/">SEC</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">ACM Conference on Wireless Network Security Supersedes WiSe (ACM Workshop on Wireless Security) and SASN (ACM Workshop on Security of Ad-Hoc and Sensor Networks)</td>
<td style="text-align: center"><a href="http://www.sigsac.org/wisec/">WiSec</a> <br> (WiSe, SASN)</td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">Symposium On Usable Privacy and Security</td>
<td style="text-align: center"><a href="https://www.usenix.org/conferences/byname/884">SOUPS</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">IFIP WG 11.9 International Conference on Digital Forensics</td>
<td style="text-align: center"><a href="http://www.ifip119.org/Conferences/">IFIP WG 11.9</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">Digital Forensic Research Conference</td>
<td style="text-align: center"><a href="http://www.dfrws.org/">DFRWS</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">ACM Conference on Data and Application Security and Privacy</td>
<td style="text-align: center"><a href="http://www.codaspy.org/">CODASPY</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">International Conference on Malicious and Unwanted Software</td>
<td style="text-align: center"><a href="http://www.malwareconference.org/">MALCON</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">Conference on Fast Software Encryption</td>
<td style="text-align: center"><a href="https://www.iacr.org/meetings/fse/">FSE</a></td>
<td style="text-align: center">密码</td>
<td style="text-align: center">B</td>
<td style="text-align: center">B</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">International Conference on Practice and Theory in Public Key Cryptography</td>
<td style="text-align: center"><a href="https://www.iacr.org/meetings/pkc/">PKC</a></td>
<td style="text-align: center">密码</td>
<td style="text-align: center">B</td>
<td style="text-align: center">B</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">International Conference on Financial Cryptography and Data Security</td>
<td style="text-align: center"><a href="http://www.ifca.ai/">FC</a></td>
<td style="text-align: center">密码</td>
<td style="text-align: center">C</td>
<td style="text-align: center">B</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">RSA Conference, Cryptographers' Track</td>
<td style="text-align: center"><a href="https://www.rsaconference.com/">CT-RSA</a></td>
<td style="text-align: center">密码</td>
<td style="text-align: center">C</td>
<td style="text-align: center">B</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">IEEE International Symposium on Hardware Oriented Security and Trust</td>
<td style="text-align: center"><a href="http://www.hostsymposium.org/">HOST</a></td>
<td style="text-align: center">密码</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">USENIX Summit on Hot Topics in Security</td>
<td style="text-align: center"><a href="https://www.usenix.org/conferences/byname/158">HotSec</a></td>
<td style="text-align: center">研讨会</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">New Security Paradigms Workshop</td>
<td style="text-align: center"><a href="http://www.nspw.org/current/">NSPW</a></td>
<td style="text-align: center">研讨会</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">Workshop on Information Hiding and Multimedia Security</td>
<td style="text-align: center"><a href="https://www.ihmmsec.org/">IH&amp;MMSec</a></td>
<td style="text-align: center">研讨会</td>
<td style="text-align: center">C</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: center">IEEE International Information Assurance Workshop</td>
<td style="text-align: center"><a href="http://www.iwia.org/">IWIA</a></td>
<td style="text-align: center">研讨会</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">4</td>
<td style="text-align: center">IEEE Secure Development Conference</td>
<td style="text-align: center"><a href="http://secdev.ieee.org/">SecDev</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">4</td>
<td style="text-align: center">Information Security Practice and Experience Conference</td>
<td style="text-align: center">ISPEC</td>
<td style="text-align: center">安全</td>
<td style="text-align: center"></td>
<td style="text-align: center">C</td>
</tr>
<tr>
<td style="text-align: center">4</td>
<td style="text-align: center">Nordic Conference on Secure IT Systems</td>
<td style="text-align: center"><a href="http://www.nordsec.org/">NordSec</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">4</td>
<td style="text-align: center">International Conference on Information Theoretic Security</td>
<td style="text-align: center"><a href="http://event.cwi.nl/icits2011/">ICITS</a></td>
<td style="text-align: center">安全</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[隐私计算技术路线]]></title>
    <link href="https://weiviming.github.io/16414786119962.html"/>
    <updated>2022-01-06T22:16:51+08:00</updated>
    <id>https://weiviming.github.io/16414786119962.html</id>
    <content type="html"><![CDATA[
<p>根据“大数据联合国全球工作组”(Bigdata UN Global Working Group)的定义, 隐私计算(Privacy-Preserving Computation)是一类技术方案, 在处理和分析计算数据的过程中能保持数据不透明、不泄漏、无法被计算方以及其他非授权方获取. 隐私计算是指在保护数据本身不对外泄漏的前提下实现数据分析计算的技术集合.</p>
<h2><a id="%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据安全法律法规</h2>
<table>
<thead>
<tr>
<th style="text-align: center">法律法规</th>
<th style="text-align: center">英文全称</th>
<th style="text-align: center">简称</th>
<th style="text-align: center">发起地区</th>
<th style="text-align: center">施行时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">《通用数据保护条例》</td>
<td style="text-align: center">General Data Protection Regulation</td>
<td style="text-align: center">GDPR</td>
<td style="text-align: center">欧盟</td>
<td style="text-align: center">2018.5.25</td>
</tr>
<tr>
<td style="text-align: center">《加利福尼亚州消费者隐私法》</td>
<td style="text-align: center">California Consumer Privacy Act</td>
<td style="text-align: center">CCPA</td>
<td style="text-align: center">美国</td>
<td style="text-align: center">2020.1.1</td>
</tr>
<tr>
<td style="text-align: center">《网络安全法》</td>
<td style="text-align: center"></td>
<td style="text-align: center">–</td>
<td style="text-align: center">中国</td>
<td style="text-align: center">2017.6.1</td>
</tr>
<tr>
<td style="text-align: center">《数据安全法》</td>
<td style="text-align: center"></td>
<td style="text-align: center">–</td>
<td style="text-align: center">中国</td>
<td style="text-align: center">2021.9.1</td>
</tr>
</tbody>
</table>
<h2><a id="%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐私计算与传统数据安全的关系</h2>
<p>来源: 《隐私计算介绍》华控清交 赵一飞</p>
<table>
<thead>
<tr>
<th style="text-align: center">传统数据保密</th>
<th style="text-align: center">隐私计算</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">数据在加密后不可计算, 使用必须解密</td>
<td style="text-align: center">数据加密后仍可计算, 计算结果解密后与明文计算结果一致</td>
</tr>
<tr>
<td style="text-align: center">需要信任系统管理员、硬件平台和操作系统</td>
<td style="text-align: center">无需信任系统管理员、硬件和操作系统(密码学流派)</td>
</tr>
<tr>
<td style="text-align: center">主要能力面向数据的存储和传输</td>
<td style="text-align: center">主要能力面向数据的使用和计算</td>
</tr>
<tr>
<td style="text-align: center">以Hash、非对称、对称等密码学为基础</td>
<td style="text-align: center">安全性和正确性由数学理论保证(密码学流派)</td>
</tr>
</tbody>
</table>
<p>传统数据安全与隐私计算是互补关系, 综合使用才能够保障数据的全生命周期安全.</p>
<h2><a id="%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF%E6%B5%81%E6%B4%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐私计算技术流派</h2>
<p>来源: 《隐私计算介绍》华控清交 赵一飞</p>
<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center">联邦学习</th>
<th style="text-align: center">多方安全计算</th>
<th style="text-align: center">可信执行环境</th>
<th style="text-align: center">安全沙箱</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">能力概述</td>
<td style="text-align: center">数据不出域, 本地明文计算, 交互通过MPC加密</td>
<td style="text-align: center">原始数据不出域, 纯密文计算</td>
<td style="text-align: center">数据通过安全通道进入隔离硬件环境计算, 支持各种通用计算</td>
<td style="text-align: center">明文数据进入安全沙箱, 支持第三方软件协作分析</td>
</tr>
<tr>
<td style="text-align: center">应用场景</td>
<td style="text-align: center">多数据源联合机器学习建模</td>
<td style="text-align: center">多数据源联合基础运算、联合查询、联合统计、部分机器学习建模</td>
<td style="text-align: center">多数据源联合基础运算、联合查询、联合统计、机器学习建模</td>
<td style="text-align: center">多数据源联合基础运算、联合查询、联合统计、机器学习建模</td>
</tr>
<tr>
<td style="text-align: center">安全等级</td>
<td style="text-align: center">中~高</td>
<td style="text-align: center">高(满足一定安全假设前提下)</td>
<td style="text-align: center">高</td>
<td style="text-align: center">低</td>
</tr>
<tr>
<td style="text-align: center">核心技术</td>
<td style="text-align: center">交互层使用密码算法<br> HE, OT, RSA, Hash</td>
<td style="text-align: center">底层基于严格论证的密码算法<br>GC, SS, OT, HE, ZKP</td>
<td style="text-align: center">在硬件层面安全指令集设计</td>
<td style="text-align: center">在网络、操作系统之上软安全域设计</td>
</tr>
<tr>
<td style="text-align: center">性能对比</td>
<td style="text-align: center">中~高</td>
<td style="text-align: center">分布式模式性能低<br>代理模式性能中~高</td>
<td style="text-align: center">高</td>
<td style="text-align: center">高</td>
</tr>
<tr>
<td style="text-align: center">部署形式</td>
<td style="text-align: center">各方部署计算和数据节点</td>
<td style="text-align: center">分布式模式各方部署计算和数据节点<br>代理模式计算节点集中部署</td>
<td style="text-align: center">各方部署数据节点，计算节点集中部署</td>
<td style="text-align: center">集中部署</td>
</tr>
</tbody>
</table>
<h2><a id="%E5%AF%86%E7%A0%81%E5%AD%A6%E7%A0%94%E7%A9%B6%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>密码学研究领域划分</h2>
<ol>
<li>计算问题: 基础困难假设;</li>
<li>密码原语: 基础功能算法, 包括对称加密算法、公钥加密算法、哈希函数算法、伪随机生成器等;</li>
<li>密码协议: 基于密码原语实现多种功能, 多方安全计算、零知识证明、可搜索加密等;</li>
<li>安全系统: 基于密码协议构建安全系统, 多学科交叉.</li>
</ol>
<p>以上四个层次层层递进, 每一层都依赖于上一层的相应实现.</p>
<h2><a id="%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97%E7%9A%84%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安全多方计算的类型</h2>
<h3><a id="%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通用安全多方计算</h3>
<ol>
<li>支持<strong>任意</strong>函数;</li>
<li>相同设计应用不用场景, 易于设计.</li>
</ol>
<h3><a id="%E4%B8%93%E7%94%A8%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>专用安全多方计算</h3>
<ol>
<li>支持<strong>部分</strong>函数;</li>
<li>针对特定问题的解决方案定制, 效率高;</li>
<li>常见场景: 隐私集合求交(PSI)问题, 门限密码等.</li>
</ol>
<h2><a id="%E5%85%A8%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全同态加密技术的发展</h2>
<table>
<thead>
<tr>
<th style="text-align: center">发展阶段</th>
<th style="text-align: center">困难性假设</th>
<th style="text-align: center">特点</th>
<th style="text-align: center">代表方案</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">第一代</td>
<td style="text-align: center">理想格陪集问题、稀疏子集和问题</td>
<td style="text-align: center">理论可行, 实现效率低</td>
<td style="text-align: center">Gentry09</td>
</tr>
<tr>
<td style="text-align: center">第二代</td>
<td style="text-align: center">LWE/NTRU问题</td>
<td style="text-align: center">优化充分, 当前效率最高, 多项式运算优势</td>
<td style="text-align: center">BGV、BFV、CKKS</td>
</tr>
<tr>
<td style="text-align: center">第三代</td>
<td style="text-align: center">LWE问题</td>
<td style="text-align: center">形式简洁, 参数选取更简便, 逻辑运算优势</td>
<td style="text-align: center">TFHE、FHEW</td>
</tr>
</tbody>
</table>
<h2><a id="%E4%B8%8D%E5%90%8C%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E7%9A%84%E5%AF%B9%E6%AF%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不同技术路线的对比</h2>
<table>
<thead>
<tr>
<th style="text-align: center">安全多方计算类型</th>
<th style="text-align: center">技术路线</th>
<th style="text-align: center">优点</th>
<th style="text-align: center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">通用</td>
<td style="text-align: center">通用安全多方计算(混淆电路 + 不经意传输 + 秘密共享)</td>
<td style="text-align: center">功能全面</td>
<td style="text-align: center">计算及通信开销大</td>
</tr>
<tr>
<td style="text-align: center">通用</td>
<td style="text-align: center">基于全同态加密的通用安全多方计算(FHE)</td>
<td style="text-align: center">功能全面</td>
<td style="text-align: center">自举效率低</td>
</tr>
<tr>
<td style="text-align: center">专用</td>
<td style="text-align: center">基于秘密共享的专用安全多方计算</td>
<td style="text-align: center">效率较高, 功能较多</td>
<td style="text-align: center">运算往往依赖第三方辅助, 部分运算计算及通信开销大</td>
</tr>
<tr>
<td style="text-align: center">专用</td>
<td style="text-align: center">基于不经意传输的专用安全多方计算</td>
<td style="text-align: center">效率高</td>
<td style="text-align: center">功能单一</td>
</tr>
<tr>
<td style="text-align: center">专用</td>
<td style="text-align: center">基于半同态算法的专用安全多方计算</td>
<td style="text-align: center">效率较高</td>
<td style="text-align: center">功能有限</td>
</tr>
<tr>
<td style="text-align: center">专用</td>
<td style="text-align: center">基于全同态加密的专用安全多方计算(Leveled HE)</td>
<td style="text-align: center">效率较高, 功能按需设计</td>
<td style="text-align: center">需要面向应用场景设置参数</td>
</tr>
</tbody>
</table>
<h2><a id="%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐私计算关键技术综合评价表</h2>
<p>来源: 中国信息通信研究院、阿里巴巴(中国)有限公司、北京数牍科技有限公司《隐私保护计算技术研究报告(2020年)》</p>
<table>
<thead>
<tr>
<th style="text-align: center">技术</th>
<th style="text-align: center">计算过程保护</th>
<th style="text-align: center">计算结果保护</th>
<th style="text-align: center">计算性能</th>
<th style="text-align: center">计算精度</th>
<th style="text-align: center">硬件依赖</th>
<th style="text-align: center">理论支持场景</th>
<th style="text-align: center">实际已商用场景</th>
<th style="text-align: center">计算模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">安全多方计算MPC</td>
<td style="text-align: center">★★★★★</td>
<td style="text-align: center">无</td>
<td style="text-align: center">★★☆☆☆</td>
<td style="text-align: center">★★★★★</td>
<td style="text-align: center">无</td>
<td style="text-align: center">任意计算</td>
<td style="text-align: center">国外: 拍卖、薪资统计、密钥管理; <br>国内: 密钥管理、联合建模</td>
<td style="text-align: center">分布式</td>
</tr>
<tr>
<td style="text-align: center">联邦学习FL</td>
<td style="text-align: center">★★★☆☆</td>
<td style="text-align: center">无</td>
<td style="text-align: center">★★★☆☆</td>
<td style="text-align: center">★★★★★</td>
<td style="text-align: center">无</td>
<td style="text-align: center">机器学习建模</td>
<td style="text-align: center">国外: 以横向FL为主, 如谷歌Gboard; <br>国内: 以纵向FL为主, 在金融风控领域应用居多</td>
<td style="text-align: center">分布式</td>
</tr>
<tr>
<td style="text-align: center">机密计算CC</td>
<td style="text-align: center">★★★☆☆</td>
<td style="text-align: center">无</td>
<td style="text-align: center">★★★★★</td>
<td style="text-align: center">★★★★★</td>
<td style="text-align: center">有</td>
<td style="text-align: center">任意计算</td>
<td style="text-align: center">国外: 密钥管理; <br>国内: 联合建模、区块链</td>
<td style="text-align: center">中心化</td>
</tr>
<tr>
<td style="text-align: center">差分隐私DP</td>
<td style="text-align: center">无</td>
<td style="text-align: center">有</td>
<td style="text-align: center">★★★★☆</td>
<td style="text-align: center">★★★☆☆</td>
<td style="text-align: center">无</td>
<td style="text-align: center">任意计算</td>
<td style="text-align: center">谷歌Gboard</td>
<td style="text-align: center">中心化</td>
</tr>
<tr>
<td style="text-align: center">本地差分隐私LDP</td>
<td style="text-align: center">★★★★☆</td>
<td style="text-align: center">有</td>
<td style="text-align: center">★★★★☆</td>
<td style="text-align: center">★★☆☆☆</td>
<td style="text-align: center">无</td>
<td style="text-align: center">数据统计</td>
<td style="text-align: center">谷歌Chrome/苹果iPhone</td>
<td style="text-align: center">分布式 + 中心化</td>
</tr>
<tr>
<td style="text-align: center">全同态加密FHE</td>
<td style="text-align: center">★★★★★</td>
<td style="text-align: center">无</td>
<td style="text-align: center">★☆☆☆☆</td>
<td style="text-align: center">★★★★☆</td>
<td style="text-align: center">无</td>
<td style="text-align: center">任意计算</td>
<td style="text-align: center">---</td>
<td style="text-align: center">中心化</td>
</tr>
</tbody>
</table>
<h2><a id="%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐私计算技术体系</h2>
<p>来源: 中国信通院调研、Gartner</p>
<table>
<thead>
<tr>
<th style="text-align: center">技术</th>
<th style="text-align: center">性能</th>
<th style="text-align: center">通用性</th>
<th style="text-align: center">安全性</th>
<th style="text-align: center">可信方</th>
<th style="text-align: center">整体描述</th>
<th style="text-align: center">技术成熟度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">多方安全计算(MPC)</td>
<td style="text-align: center">低~中</td>
<td style="text-align: center">高</td>
<td style="text-align: center">高</td>
<td style="text-align: center">不需要</td>
<td style="text-align: center">通用性高,计算和通信开销大,安全性高,研究时间长,久经考验,性能不断提升</td>
<td style="text-align: center">已达到技术成熟的预期巅峰</td>
</tr>
<tr>
<td style="text-align: center">可信执行环境(TEE)</td>
<td style="text-align: center">高</td>
<td style="text-align: center">高</td>
<td style="text-align: center">中~高</td>
<td style="text-align: center">需要</td>
<td style="text-align: center">通用性高,性能强,开发和部署难度大,需要信任硬件厂商</td>
<td style="text-align: center">快速增长的技术创新阶段</td>
</tr>
<tr>
<td style="text-align: center">联邦学习(FL)</td>
<td style="text-align: center">中</td>
<td style="text-align: center">中</td>
<td style="text-align: center">中</td>
<td style="text-align: center">均可</td>
<td style="text-align: center">综合运用MPC、DP、HE方法, 主要用于AI模型训练和预测</td>
<td style="text-align: center">快速增长的技术创新阶段</td>
</tr>
<tr>
<td style="text-align: center">同态加密(HE)</td>
<td style="text-align: center">低</td>
<td style="text-align: center">中</td>
<td style="text-align: center">高</td>
<td style="text-align: center">不需要</td>
<td style="text-align: center">计算开销大, 通信开销小, 安全性高, 可用于联邦学习安全聚合、构造MPC协议</td>
<td style="text-align: center">快速增长的技术创新阶段</td>
</tr>
<tr>
<td style="text-align: center">零知识证明(ZKP)</td>
<td style="text-align: center">低</td>
<td style="text-align: center">低</td>
<td style="text-align: center">高</td>
<td style="text-align: center">不需要</td>
<td style="text-align: center">广泛应用于各类安全协议设计, 是各类认证协议的基础</td>
<td style="text-align: center">快速增长的技术创新阶段</td>
</tr>
<tr>
<td style="text-align: center">差分隐私(DP)</td>
<td style="text-align: center">高</td>
<td style="text-align: center">低</td>
<td style="text-align: center">中</td>
<td style="text-align: center">不需要</td>
<td style="text-align: center">计算和通信性能与直接明文计算几乎无区别, 安全性损失依赖于噪声大小</td>
<td style="text-align: center">快速增长的技术创新阶段</td>
</tr>
<tr>
<td style="text-align: center">区块链(BC)</td>
<td style="text-align: center">低</td>
<td style="text-align: center">中</td>
<td style="text-align: center">中</td>
<td style="text-align: center">不需要</td>
<td style="text-align: center">基于带时间戳的块链式存储、智能合约、分布式共识等技术辅助隐私计算, 保证原始数据、计算过程及结果可验证</td>
<td style="text-align: center">逐渐接近技术成熟的预期巅峰</td>
</tr>
</tbody>
</table>
<h2><a id="%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%83%BD%E4%B8%89%E8%A7%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐私计算中的不可能三角</h2>
<p>以下三点相互制约, 三者无法同时达到最优.</p>
<ol>
<li>安全性/隐私性</li>
<li>效率性</li>
<li>精确性</li>
</ol>
<h2><a id="%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%9A%BE%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安全多方计算协议的实现难度</h2>
<p>来源：阿里安全双子座实验室 洪澄博士</p>
<table>
<thead>
<tr>
<th style="text-align: center">实现难度</th>
<th style="text-align: center">诚实大多数</th>
<th style="text-align: center">不诚实大多数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">半诚实安全</td>
<td style="text-align: center">☆</td>
<td style="text-align: center">☆☆☆</td>
</tr>
<tr>
<td style="text-align: center">恶意安全</td>
<td style="text-align: center">☆☆☆</td>
<td style="text-align: center">☆☆☆☆☆</td>
</tr>
</tbody>
</table>
<h2><a id="%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>联邦学习开源框架对比</h2>
<p>来源: 《WeBank - 联邦学习白皮书2.0》</p>
<table>
<thead>
<tr>
<th style="text-align: center">开源框架</th>
<th style="text-align: center">FATE</th>
<th style="text-align: center">TensorFlow Federated</th>
<th style="text-align: center">PaddleFL</th>
<th style="text-align: center">PySyft</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">受众定位</td>
<td style="text-align: center">工业产品/学术研究</td>
<td style="text-align: center">学术研究</td>
<td style="text-align: center">学术研究</td>
<td style="text-align: center">学术研究</td>
</tr>
<tr>
<td style="text-align: center">牵头单位/机构</td>
<td style="text-align: center">微众银行</td>
<td style="text-align: center">Google</td>
<td style="text-align: center">百度</td>
<td style="text-align: center">OpenMined</td>
</tr>
<tr>
<td style="text-align: center">联邦学习类型</td>
<td style="text-align: center">横向/纵向/迁移</td>
<td style="text-align: center">横向</td>
<td style="text-align: center">横向/纵向</td>
<td style="text-align: center">横向</td>
</tr>
<tr>
<td style="text-align: center">联邦特征工程算法</td>
<td style="text-align: center">支持特征的分箱、选择、相关性分析</td>
<td style="text-align: center">不支持</td>
<td style="text-align: center">不支持</td>
<td style="text-align: center">不支持</td>
</tr>
<tr>
<td style="text-align: center">机器学习算法</td>
<td style="text-align: center">LR, GBDT, DNN等</td>
<td style="text-align: center">LR, DNN等</td>
<td style="text-align: center">LR, DNN等</td>
<td style="text-align: center">LR, DNN等</td>
</tr>
<tr>
<td style="text-align: center">安全协议</td>
<td style="text-align: center">HE, SS, RSA, DH</td>
<td style="text-align: center">DP</td>
<td style="text-align: center">DP</td>
<td style="text-align: center">HE, SS</td>
</tr>
<tr>
<td style="text-align: center">联邦在线推理</td>
<td style="text-align: center">支持</td>
<td style="text-align: center">不支持</td>
<td style="text-align: center">不支持</td>
<td style="text-align: center">不支持</td>
</tr>
<tr>
<td style="text-align: center">Kubernetes</td>
<td style="text-align: center">支持</td>
<td style="text-align: center">不支持</td>
<td style="text-align: center">不支持</td>
<td style="text-align: center">不支持</td>
</tr>
<tr>
<td style="text-align: center">代码托管平台</td>
<td style="text-align: center"><a href="https://github.com/FederatedAI/FATE">Github</a></td>
<td style="text-align: center"><a href="https://github.com/tensorflow/federated">Github</a></td>
<td style="text-align: center"><a href="https://github.com/PaddlePaddle/PaddleFL">Github</a></td>
<td style="text-align: center"><a href="https://github.com/OpenMined/PySyft">Github</a></td>
</tr>
</tbody>
</table>
<h2><a id="%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AE%A1%E7%AE%97%E5%AE%89%E5%85%A8%E7%AD%89%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐私保护机器学习的计算安全等级</h2>
<p>来源: 《隐私保护机器学习》, P85, 王力、张秉晟、陈超超 著, 2021.</p>
<table>
<thead>
<tr>
<th style="text-align: center">等级分类</th>
<th style="text-align: center">安全要求</th>
<th style="text-align: center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">第一安全等级</td>
<td style="text-align: center">不传输原始数据, 但不对中间数据进行保护</td>
<td style="text-align: center">不传输原始数据, 明文传输梯度</td>
</tr>
<tr>
<td style="text-align: center">第二安全等级</td>
<td style="text-align: center">概率性地保护半诚实安全模型下中间数据的安全, 概率应可计算</td>
<td style="text-align: center">对传输梯度进行差分噪声的保护</td>
</tr>
<tr>
<td style="text-align: center">第三安全等级</td>
<td style="text-align: center">在半诚实安全模型下, 可证明安全</td>
<td style="text-align: center">基于半诚实安全模型的多方计算方案</td>
</tr>
<tr>
<td style="text-align: center">第四安全等级</td>
<td style="text-align: center">在恶意安全模型下, 可证明安全</td>
<td style="text-align: center">基于恶意安全模型的多方计算方案</td>
</tr>
<tr>
<td style="text-align: center">第五安全等级</td>
<td style="text-align: center">在恶意安全模型下且有多攻击方共谋时, 可证明安全</td>
<td style="text-align: center">不诚实大多数的多方计算方案</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Falcom Pastebin Link]]></title>
    <link href="https://weiviming.github.io/16410231259573.html"/>
    <updated>2022-01-01T15:45:25+08:00</updated>
    <id>https://weiviming.github.io/16410231259573.html</id>
    <content type="html"><![CDATA[
<p>Pastebin Link: <a href="https://pastebin.com/G2mswYCt">Click here</a></p>
<pre class="line-numbers"><code class="language-plain_text">This is the Falcom Pastebin!

FOR ALL LINKS: Add mega.nz to the beginning of all links!

Scroll to bottom to see the Cold Steel 3 Dengeki (電撃PlayStation)/Famitsu scans and other miscellaneous scans/info!

Cold Steel III 4K Wallpapers
 /#F!XIUHCLrZ!Q9G5PEXBLb16IvM9U0Ji4A

-Falcom Magazine (ファルマガ)
This first MEGA folder is Falcom Magazine PDFs distributed by Falcom &amp; free issues. Issues 1, 17-121 (Current and actively updated)
Falcom Magazine Issues 1, 17-121 &amp; Free (PDF)
 /#F!M4R33IwS!5MMg28iDemkEm6vhqYI8nw

This second MEGA folder contains Falcom Magazine scans (image version.) - Issues 1-64, not current
 /#F!VR4SULCQ!oK0F2KByY62RtWTAV4HqBw
-Sen no Kiseki Magazine
These are 2 magazine issues that were included with Dengeki issues 646 and 647, respectively. Physical only, scans.
 /#F!lOAXDZiQ!B9-aqMVydcWiq409EV8TAA

-Falcom Live Performances &amp; Video
[20101112][NW10102840]FALCOM JDK BAND LIVE 2010 IN LIQUIDROOM(iso+mds).7z 6.70 GB
 /#!YwBxHY4J!Okzrh0RnVL0FO9SqoaObFw6xZRQeNp95MR0Ey9gvWIo
[MIDI] FALCOM GAME COMPLETE MIDI PACK [Version 3].7z 3.2 MB
 /#!gY4DjBhb!D4zvjYXTMeFf-twS1TAIjBx4s0-HG2sNT2uHg8Mj-WY
-Ys Special Collection - All About Falcom is a DVD digitization of a 1993 VHS tape bundled with the Ys VI JP limited edition. 
Ys-Special_Collection-All-About-Falcom.iso 4.03 GB
 /#!bRNxzIgL!S7xxCxJzqXuYWJAM0IRoVxRai0MjF_CH_qY1UH8g-iM

-Falcom MIDI Collections. These CDs are MIDI collections with the original MIDI data on them, but also have full recordings of the music being played on the actual MIDI modules in CDDA audio format, so both of these are included in these rips. These include the Yamaha XG, the Roland SC-88, and 24-tone tracks that are GM/GS-compliant.
CD rips with Data Tracks &amp; scans:
[EAC] New The Legend of Heroes MIDI Collection [CDDA FLAC+MIDI+cue+log+BK].7z 325.4 MB
/#!zR0nXTga!TYBTR3GKH8EWSzA_7FVegNAlY6pLaCMGvo2MHFohL7Q
[EAC] SC-88 MIDI Collection [CDDA FLAC+MIDI+cue+log+BK].7z 341.3 MB
/#!qAUnULxR!b1hnXOCyyt7R1_UrQ54954QZX5sfaDLuv-fPOPoCaGQ
[EAC] The Legend of Heroes MIDI Collection [CDDA FLAC+MIDI+cue+log+BK].7z 375.7 MB
/#!aIdlkDaK!VpDWqSQTFiI6NDBUx4ifvMRA-qo2XESatxuRjdVnYq4
[EAC] Sorcerian MIDI Collection [CDDA FLAC+MIDI+cue+log+BK].7z 373.1 MB
 /#!3VUQQIRD!IcbL_L8X7zZR19MFnQw0-bpxC_KIWK3Hv5oTZ9_hMEc
Brandish MIDI Collection [CDDA FLAC+MIDI+BK].7z	374.2 MB
 /#!CF1zXR4B!GlsfGcMEfpgUm0w7bTiVxD_gA2BmTTCBLOsh-W2iOI8
[EAC] Ys MIDI Collection [CDDA FLAC+MIDI+cue+log+BK].7z	349.9 MB
 /#!qdFHhbBL!r2HDNJp0NLNCWg6yyKUhuI1U5WB2YYRn2kvK9_R9ck0
[EAC] The Legend of Heroes IV MIDI Collection [CDDA FLAC+MIDI+cue+log+BK].7z 265.4 MB
 /#!GYlSGICQ!l9FzDdiGMGl_jecdqN1o8qbrq-mgRAHifXxQWp2ESfc

-Material Collections

-Ys Material Collection 2 (イース・マテリアル・コレクション２)
-Recordings of special MIDIs through Roland SCVA VSTi
Ys Material Collection 2 SCVA VSTi MIDI Recordings [FLAC].7z	223.4 MB
 /#!fEcxVB5Q!aahFWfqHZ992fJw7F_w_PhgsU50ETKmS-E0N3siB_DI
-Disc Image
Ys Material Collection 2 (MDX)[Art+Music+SFX+Docs+WIP].7z	428.2 MB
 /#!OBFG2ZII!0ETnqnhtxHwnzovgNbKE8ejuLoQU4mEAsliaejiMPfY


--Sorcerian
-Sorcerian Complete
(Project EGG Authentic PC-88 Recording)
This is a Project EGG limited package, with a 2-disc soundtrack that is actual professional hardware PC-88 recordings
of Sorcerian music.
[EAC] SORCERIAN COMPLETE -RARE SELECTION- (Windows 10 Reprint 2019)[flac+cue+log+jpg].7z 775.2 MB
 /#!kO5EyKJD!gq4YckUAwSPRTs1vOKjhxF_4vdpMWLMx2gxuFRGhr_w
-Physical scans from me/PDFs included with Sorcerian Complete (Windows 10 Reprint 2019, higher quality PDFs):
Sorcerian Complete PDFs + Scenario Card Scans.7z 1.28 GB 
 /#!IwgDXKwL!UfCuMJedepmqDYmLlVuHJU8mWMGSdFM7j4nfBEvptdY

-パーフェクト・コレクション　ソーサリアン vol1-3
[EAC][910721]Perfect Collection Sorcerian(ape＋cue＋jpg).7z 493.4 MB
 /#!cxJX1BBa!J7EYrmylzq-Mn8JyExM2w1RbEbw_Y7RCkF-uTzTfkK8
[EAC]Perfect Collection Sorcerian Vol. 2 (flac+cue+log+bk).7z
 /#!A9wUCYKZ!PHq2mkw_qSVRg64sb0G8Rmh9sL1kyWyKTMnYxiMgSEI
[EAC][911121]Perfect Collection Sorcerian Vol.3 (FLAC+cue+jpg).7z 490.8 MB
 /#!FlxhBKSY!SzDrIzVCOUZNqGplCCPxgBSYGGZvkNP2cbm8bETx-vw
-Music from Sorcerian
[EAC][880421]ミュージック フロム ソーサリアン(MUSIC FROM SORCERIAN)(FLAC＋log＋cue＋jpg).7z
 /#!nVlVEK5a!53nbY4WMk3vBImrwv2ViDk8C3DQQLh3M9kHOoCnuzIk
[EAC] ソーサリアンフォーエバー I (Sorcerian Forever I) [FLAC+cue+log+BK].7z 458.9 MB
 /#!MxZlAYTL!J-fC63OYL2bX5q1j_CBzyB_slCgcI1_RoCijNvUDvMs
[EAC] ソーサリアンフォーエバー II (Sorcerian Forever II) [FLAC+cue+log+BK].7z 522.3 MB
 /#!wx5ClQgC!Fdd54gyc7gjwUBOQzdHw8zlso7YsiE-m9MRWAfXd6sA
(Extra direct rip game tracks exclusive to Sorcerian Forever)
Falcom Sound Team jdk - Sorcerian Forever ~Extra Unofficial Edition~[FLAC].7z 352.4 MB
 /#!DQkBwaCC!gtZbdlrzECV6ID0nXvqYg7ndKJrg4ai_t3-H4EtSpXI
Sorcerian Forever General MIDI Soundtrack (SCVA)[FLAC].7z 320.3 MB
 /#!aREGXZyD!n0UN2V4oUQfMawNE2IqhmrZqcj5eTE2_F74W7k6O-sU
[EAC][970627]ソーサリアン・ミュージック・グラフィティ [FLAC+cue+log+BK].7z 287.2 MB
 /#!LF9HiTyZ!iOP7vWykIgznT90lEsQP0LyrCDNqF9iXUJFjmqXD6ig
(Sorcerian Mega Drive OST)
[EAC][081029]ソーサリアン メガドライブバージョン オリジナル·サウンドトラック(flac＋log＋cue).7z 610.2 MB
 /#!V4MlDJSL!OcRJ7ygZBXn7Xq8KbkrDDjT6f_A6ApmVhki0oj00tVo
[EAC] MIDI Piano Sorcerian Forever [FLAC+cue+log+bk].7z 192.4 MB
 /#!TdMiHR5Z!tWl4M-P79WSRMJyHlUWbMtCza4gJ3au7FMw9cpHMyag
[XLD][890705]Symphony Sorcerian(交響曲ソーサリアン)[FLAC＋cue＋log].7z 222.6 MB
 /#!7EtC3QbZ!gBWgXMR_-RQYjP522vbBr0EAxYGF3SY7LmKdbfRkISA
[EAC] Dragon Slayer 5 - Sorcerian (ソーサリアン) PC Engine [binrip+FLAC+cue+log].7z 292.0 MB
 /#!gdoDQbbT!ERigvasWhGXA8dPC51EVPbWzq4HK-DOhp5BeoweJzhI
-Sorcerian Super Arrange 1-3
[EAC][880421]ソーサリアン スーパーアレンジバージョン(ape＋cue＋jpg).7z 244.9 MB
 /#!Bsxy2BqQ!cP5A_l5vhTSje7jnaoHDuQlk6Uxl2gy_ioLUQTd8XZ0
[EAC][880921]ソーサリアン スーパーアレンジバージョンII(ape＋cue＋jpg).7z 295.1 MB
 /#!49Y2ASYJ!NOLv9m4V81oEn4by9nQG5wMLAGdlclMNFMXUl8rtQ6c
[EAC][890321]ソーサリアン スーパーアレンジバージョンIII 戦国ソーサリアン VS ピラミッドソーサリアン(ape＋cue＋jpg).7z 391.6 MB
 /#!w5RQkarQ!cQKIYGRKOypIAhhihJm19y8_QRszInDGRbvDXL9pITI
Sorcerian Sharp X1 Turbo Archive - PSG + OPM (.VGM Source)[FLAC].7z	2.52 GB
 /#!9YpDFRIC!gSXJg4jUQ6Lp6IZaiKj6YH9flqY8PqtT7eA7p9ihlyk
--Sorcerian for DOS was localized by Sierra in the West, and Ken Allen &amp; Rob Atesalp from Sierra arranged MIDIs for use with MT-32.
Sorcerian (DOS) Sierra Arrange MT-32 Hardware Recording - Incomplete [FLAC].7z	207.5 MB
 /#!5EZXiJaI!e3nftvVYTE-2LnCag-oXg_p1NXOjhXFKYRd56ZPD5k8
Sorcerian Original WAVs [FLAC].7z	425.6 MB
 /#!gEJEBboK!d0DqVFDYbh7SOtTMLllOGLCAEuatDeFMb-IU4_RKcYw
-Sorcerian Dreamcast
[EAC] Sorcerian - Apprentice of the Seven Star Magic - Sorcerian Music Collection [FLAC+cue+log+img].7z	449.9 MB
 /#!LFUH1DYD!JJi1otkFe8HGAeDlR1UdFo9866geDSn0AiLDdQeqT2c


--Ys I &amp; II - Ancient Ys Vanished &amp; Ancient Ys Vanished – The Final Chapter
Ys Book I &amp; II TurboDuo [Redbook].7z 453.7 MB
 /#!ssgwCbyB!GNr9ACShfLzIejwqGJxmu0Q-AHRL84QItW_uAG0uZ5I
-Ys I&amp;II Eternal
[EAC][010210]イース＆イースII エターナル オリジナル·サウンドトラック(CD2枚組)(ape＋cue＋jpg).7z 717.2 MB
 /#!tlJXnKqK!RJ6FFH8J_3aE_tQ9sOcnXkv48yEus66bvWJfrOy6wZU
Ys I &amp; II Complete (SC-88 SCVA)[FLAC].7z 629.3 MB
 /#!mRcA1A6R!a2LEb_dm5u7OL-YZoPZrxgQQY54eeSmdP-ymdKc4wII
-Ys II Special (Port of Ys II by Korean company MANTRA to IBM PC/AT, with extra music by SoundTeMP)
Ys II Special - Game Recording from Hardware [DOS+Sound Blaster AWE32+ALAC].7z	1.25 GB
 /#!RFpR0ITY!7Xj030rq9AEVNNJlXcJ9argUBCzWpud2Fv_u8IWsFY0
Ys II Special - IBM PC AT (.VGM Source) [FLAC].7z	459.6 MB
 /#!wFBWiQQD!9QUS0gzAVhWiQOjRHlVXlIpEj4apmSHb5pYlGEkmfwg
-Ys I &amp; II DS
[EAC] Legacy of Ys Books I &amp; II Original Soundtrack [flac+cue+log+jpg].7z 491.7 MB
 /#!Z9FWUTAA!SV69KAtbwbuJS6uFvjDdeHBDaDpOErMA6QDcnMERrpE
-Ys I &amp; II Chronicles
Ys I&amp;II Chronicles ORIGINAL SOUND TRACK [NW10102810].7z 906.5 MB
 /#!9gkVTTKC!Zlr7-jZ1slOeduZh2m-kplOHWIdILOJltXZz0NgqFQo
[EAC][090716]イース I&amp;II ベストサウンドコレクション(Ys I&amp;II Best Sound Collection)[flac+cue+log+jpg].7z 452.4 MB
 /#!1AZkFKTA!iXMk83sOtjAbKy73tf_px3p1ol3kGAK85C-v1XyczdM
-PERFECT COLLECTION Ys I·II Complete Works of RYO YONEMITSU
[XLD][010913]パーフェクトコレクション イース I・II～米光 亮全曲集[FLAC+cue+log].7z 510.1 MB
 /#!XUkXEBYJ!w-_LKq0GwNidECC_ij9MqPt0Q6EcZaYzDTxVydQsvsE
-Perfect Collection Ys I·II - Super Arrange Version
[XLD][010913]パーフェクトコレクション イース I・II～スーパーアレンジ[FLAC+cue+log].7z 467.1 MB
 /#!ORcGyb7T!VRIOZP1OJq3a_TjK9VRp6cgsNFn1RLUU4JJObKteBJQ
-Perfect Collection Ys
[EAC][900805]パーフェクト コレクション イース(ape＋cue＋jpg).rar 458.1 MB
 /#!wxB3kL4I!RPjsfl3D3y7RSN5EOz9SNU6A8u5jLN_B_TP6bX_NBao
[EAC][900905]パーフェクト コレクション イースII(Perfect Collection YsII)(ape＋cue＋jpg).7z 538.0 MB
 /#!d1QgADSZ!ejRKjXKpKtFsvvw6Jy0d4inIe182KgHeWNm-vGuzbl4
[EAC][930922]イース ピアノコレクション(Ys Piano Collection)(flac＋cue＋jpg).7z 176.1 MB
 /#!dtMBQT5Q!LdR1WDBQNsrUwOO0RHxarj6R6x47f6GU-foHzX9re3E
[EAC][940525]イース ピアノコレクション2(Ys Piano Collection2)(flac＋cue＋jpg).7z 204.7 MB
 /#!4sEEDCIS!SGBJ9giLPgIKuopJv4QqQGTU9KoNV_AHC1gXPe8RWPM
[EAC][010210]Ys ＆Ys II、朱紅い雫 Unpublished Music(flac＋cue＋log＋jpg).7z 592.9 MB
 /#!w0s1mZ6T!FvgP81lPICpyZFIjmKoR62H2S_FaxviHb7UsJKtDFAc
[EAC][871105]ミュージック フロム イース(Music From Ys)(flac＋cue＋log＋jpg).7z 310.5 MB
 /#!54NGRBDS!f5_szziccMt-pOYgnmxK-k51zs0IrDg1PIynWoUmAcw
[EAC][880621]ミュージック フロム イースII(Music From Ys II)(flac＋cue＋log＋jpg).7z 318.5 MB
 /#!5plTGIKa!bkvvfUM_wgtBwkL6-0E8ulPZTrdGSS5FDlyqN4rNZkg
[EAC][951025]イース ミュージックフロムイース リニューアル(Music From Ys RENEWAL)(ape＋cue＋jpg).7z 362.6 MB
 /#!p4oHyYaY!bZ54WCc6v40uaYiQc-HQEV7HQuhxEyXac9hQSWv9EdI
[EAC][960323]Music From Ys II Renewal (flac+cue).7z 346.9 MB
 /#!9w1C2Yra!O3XER1UDYDXl9ofAG5FDNkLAWKkSTSo8pY4qNhlC5Tc
Ys I - Ancient Ys Vanished (X68000 Hoot Rip)[FLAC].7z	175.4 MB
 /#!8I4HWTbL!CXjF-Il5N3ekgZFU96GL9OZ1YZJSqjpXuSNLnVSd8Gc
Ys I - Ancient Ys Vanished X68000 (.VGM Source)[FLAC].7z	173.3 MB
 /#!kFonxQZa!kUKyt0NpxNvAJTHcfOcUod9edDJyFFQ_QwHpQQ79W3I
Ys - The Vanished Omens (Sega Master System FM Version) [.vgm rip + FLAC].7z	85.4 MB
 /#!RYxyQSaT!iBR5U0kOo_8dzdxd6PZouT1q0LduA_JLBxELkQdQpUg
Ys I &amp; II Eternal Story (PS2, Digicube)[.psf2, FLAC].7z	922.8 MB
 /#!hMJXkBhY!Z2Qec8hH4uTmIGzx3-U1BMPbZukpwIQ0yQhJXHqleSA
Ys II (Famicom) - .nsf rip [FLAC].7z 125.8 MB
 /#!9JQUjBhY!pwmjwB8-U7gPVqdnIhSkWY4nwj-hmKDEdjgJUnCMLFg
Ys I (Famicom) .vgm rip [FLAC].7z 113.1 MB
 /#!BVQGUCoC!2m5Zu2MR4J549-fy333uQWb2-MoecmkFFNlHkiVX8YY
Ys II (Famicom) .vgm rip [FLAC].7z	86.4 MB
 /#!sYJXnQyA!vDj4ajYNpw-XfeGYCbv6GV4n6vIzDEaxFDyKALj7VBw
Ys Eternal GS MIDI (FLAC).7z 379.4 MB
 /#!FFRzyJ6L!GT8-Ckjb0yTlrD5NRJARTFEwrplRySmfNDKXRPsnttE
Ys Eternal SC-88 MIDI (FLAC).7z	298.2 MB
 /#!kcYVjaYI!euy8jN7K1eWKp6CBaHc9MIMO83idzGejBdg-ZLGT80M
Ys II Eternal SC-88Pro MIDI (FLAC).rar	370.1 MB
 /#!EEgg3LxD!NyV51isHpKy25HOQ9hojSusxmGMpxAsjIDDXr2Aea1U
[XLD] 三石琴乃 - Lilia ～from Ys～ (1992) [FLAC].7z 282.8 MB
 /#!7QNnwKqQ!aMV__tsM76T3rg4Ig4DT0VZ7SfR2g9B0_ja-dyi4-b4

--Ys III
Ys III PC Engine [Redbook].7z 408.1 MB
 /#!85kT2IqB!IkvmUgPVL8e0nYp2fO5Li3mlCS585J_bz-ZtCx-LH_U
Ys III - Wanderers from Ys (1989) [PC-88 Rip].7z 374.7 MB
 /#!o4MSRCAS!Xq_ZsmnoFFpTYcaCRDXAc3CRwnNmdTN8RhdxlGyiABA
-メガドライブ - (Both of these are Genesis/Mega Drive)
Ys III OST (Sega Genesis, 1991) [line-out, FLAC@24bit／96KHz].7z 1.51 GB
 /#!IUhA1IRK!gu7CiuDNpOrKwczbf-JuNqFrCqkqbFxIw3_amZ3DMis
Ys III - Wanderers from Ys (Sega Mega Drive)[.vgm rip + FLAC].7z 439.1 MB
 /#!lNp0wKbD!SnSe5jG36e6u75C1920YBEIVZIoZAaxjFO_SWyDTk_c
-Ys III X68000 OST
[EAC][100422]ワンダラーズ·フロム·イース X68000 オリジナル·サウンドトラック(flac＋cue).7z 339.1 MB
 /#!Y4FEnTCB!Y-wz6ElT2wp1nwmTWv19tWiJqm8hw1lDHi0kHkn1rjA
[EAC][900321]イースIII J.D.K.スペシャル (Ys III J.D.K. Special)[flac+cue+jpg].7z 428.6 MB
 /#!EYZTnZ7K!AdqYl_Fv-nfEgrpFOVzAOxMYVOzpdMfwC_AjzPwm5fc
-Music from Ys III Wanderers from Ys
[EAC][891021]ミュージック·フロム·イース III ワンダラーズ·フロム·イース [FLAC+cue+jpg].7z	408.1 MB
 /#!sY4FlAxK!cLZsd2ulR5cxeylkIdIy31qj5f1I6rilmzMvFwytJbc
-Ys III Wanderers from Ys Super Arrange
[EAC][891021](イースIII) ワンダラーズ・フロム・イース スーパー・アレンジ・バージョン (flac+cue+log+jpg).7z	339.3 MB
 /#!NNBh2Y6S!I_zyZXtId215SM7WnPRyQ__w6s4BhkRx0jJBzwZp_zY
[EAC][910315]パーフェクト コレクション イースIII(Perfect Collection YsIII)(ape＋cue＋jpg).7z 548.6 MB
 /#!x4p1xQIL!M2YC2GKUn8cvaZV63YlKsgzV1REsV7siF3zDtc6cap8
Ys III - Wanderers from Ys (PS2, Taito)[.psf2, FLAC].7z 315.2 MB
 /#!RcxDQILY!FUIcwQ9hikVgQul5rqIW2lFJAXx5rTGCBfDZHvttMWs
Ys III (Famicom) .vgm rip [FLAC].7z	84.5 MB
 /#!1co1lTBT!6kXfgOUU15q9Ikn9sQ2xOMeVLd7TbMm_N3YxGIRCK1E

--Ys IV: Dawn of Ys
PERFECT COLLECTION Ys IV The Dawn of Ys VOL.1.7z 388.4 MB
 /#!ApYikLjb!NbPkpmnQsUtCnRwBWrSVfB0V2Zkw9SspZA7-ZhJ-MnM
PERFECT COLLECTION Ys IV The Dawn of Ys VOL.2.7z 388.1 MB
 /#!44AHzTTB!ZRBcPwzoye0TihgaujlrCnt899BDFNRZOdhMA66FCzI
PERFECT COLLECTION Ys IV The Dawn of Ys VOL.3.7z 303.6 MB
 /#!xCJBEAoI!q-3EkdyBGBMsMzHdXeXsq3N0SNfHTjJj6xsyxoT7reg
Ys IV J.D.K. Special The Dawn of Ys [KICA-1137].7z 438.9 MB
 /#!EgwCESqC!YtPOiDSHZd943THS_8CqizydNIJFQTvzbr-eefZbgUA
-Ys IV PC Engine rip, all CDDA audio, ADPCM clips, and internal PC Engine tracks in JP and ENG (Fandub)
Ys IV - The Dawn of Ys (PC Engine) JP and ENG [bin, .VGM source + FLAC].7z 888.1 MB
 /#!0NhkiIqS!GQ0R22xjn2sEafbRVU4JAcEGvMyrRU6ph4ridvBn95o

--Ys IV: Mask of the Sun
Ys IV - Mask of the Sun (SNES) Gamerip [WAV+jpg].7z	748.1 MB
 /#!hTIVXCIR!WqlP8T8aBNp6nMMqxqwykCzx5kUv4K_sVEvlNbZ6Wwg
Ys IV - Mask of the Sun - A New Theory (PS2, Taito)[.psf2, FLAC].7z 432.8 MB
 /#!BUhmTT4Y!Gr8S8R9VNCrubMqAIdz5DvSXyIvDZbS59IYyRo5fFpU

--Ys V
[EAC][960323]ミュージック フロム イースV～失われた砂の都ケフィン～(Music From Ys V)(CD2枚組)(ape＋cue＋jpg).7z 821.6 MB
 /#!o0pAHL5D!BjeFFjjnfjquD_o5KmJ1xR2WWjMQ88tKnn2qMGcei3c
[EAC][960424]イースV オーケストラ バージョン(YsV Orchestra Version)[FLAC+BK].7z 276.2 MB
 /#!KQ8j0boT!ZC_rBQC6ZiKXSWf9uWkFj9v809LASImytyj8xNdIIpo
[EAC][960106]Image Album Ys V：Kefin,The Lost City of Sand(flac＋cue＋jpg).7z 315.5 MB
 /#!1o1SmaQT!FitpPSz8udlNklZP6JaBN34mrQtrvUNmFL02pbvsbok
Ys V - Lost Kefin, Kingdom of Sand (PS2, Taito)[.psf2, FLAC].7z	580.9 MB
 /#!AFhy0ZRD!apNMbNgzSKsn8x7Mig9pdCFKm3Oy9Tcm-KNiswcWTbQ

--Ys VI - Ark of Napishtim
Falcom Special Box 2004 (Contains Ys 6/VI Ark of Napishtim OST, and Legend of Xanadu OST)
[EAC][031219]ファルコム スペシャル ボックス'2004 イースVI+風の伝説ザナドゥ(ape＋cue).7z 1.85 GB
 /#!U8Y1HaSb!bYTVuS2gfI1gRPD39ce_4jPSlNw9SO9jcK_9a62bHOU
Small vocal:
[EAC][050317]ザ・ソングス・オブ・ゼメス～イース VI ボーカルバージョン～(flac＋cue＋jpg).7z 335.3 MB
 /#!F4EVlaqC!KFgcmAopkbj7TXX96_X8wkuoVvNJ1It52uW6gsBsVRw
Instrumental version of that same CD, but with a bonus data CD
[EAC][050317]ザ・ソングス・オブ・ゼメス～インストゥルメンタル・オンリー～(flac＋img＋cue＋jpg).7z 708.2 MB
 /#!x8dHVJBY!Jon2QXQH1NRQGj3hUUJt5S1L3ow-SdxRTjEnYUWrv1Q
[20050310][VW265-J1]Ys The Ark of Napishtim Special Sound CD(ape＋cue＋rr3%).7z 313.6 MB
 /#!JoYCUb5A!R2itWTIk0cZq2FqOxHuqlDGZv5s4baipZDK--ccGeW4

--Ys Oath in Felghana (Premium Box includes some Ys III original versions)
Original Soundtrack + Super Arrange
[EAC][050923]パーフェクトコレクション イース -フェルガナの誓い-(3ape+cue+jpg).7z 989.0 MB
 /#!I8QxTZjY!NEg3kTIQ3Jk9eWJR6gD3vSKCBrFc3Tejah_4cP_TwSc
Giant box of mixes
[EAC][050630]イース -フェルガナの誓い-初回限定特典「PREMIUM MUSIC CD BOX in Felghana」(ape＋cue＋jpg).7z 2.52 GB
 /#!E9pngYLJ!XsE1SxEb5iAdKojb8d0YBnohKBUtAZArZIZqvfIJRpM
JDK Special
[EAC][100422]イース -フェルガナの誓い- jdk スペシャル(ape＋cue＋jpg).rar 263.0 MB
 /#!A55G3L6L!G-pSXyyJhPJ7S7FeSnqHJy_djWAhALcBEwaEYkVNyRE
Ys -The Oath in Felghana- Drama CD
イース　ドラマ CD　異說～もう一つのフェルガナ冒険記～.7z 437.6 MB
/file/0MlgDbYJ#zW42rgGZ4-9UtL_0MZWHwj6yFTU1tTAbHUWYR6CmKcQ

--Ys Origin
Ys Origin Original Sound Track
イース・オリジン オリジナルサウンドトラック.7z 573.1 MB
 /#!s1VHxbYT!ZeMm_Swo2Cb9jBm9YMOiCSDDSUB3JxSh-Y7cE1Y23rI
Ys Origin Super Arrange Version
[EAC][070628]イース·オリジン スーパーアレンジバージョン(ape＋cue＋jpg).7z 335.1 MB
 /#!Nh1EmSQS!ElR3y0cFd33oWfIctFVeJD_uHhMTUefk3VsziM7p3eA

--Ys Seven
[EAC][091119](ゲームサントラ) イース Ys SEVEN ORIGINAL SOUND TRACK [FLAC+cue+jpg].7z 949.3 MB
 /#!HZkn0ZIR!yMaj-KT4_1dWb_smYsL3pQFbX8D6-PYPM2AWf9KhpG0
--Ys Seven Drama CDs
[EAC][090917]イース7プロローグ・ドラマCD ～綴られざる冒険譚～ [FLAC＋cue＋log＋jpg).7z 382.5 MB
 /#!vVFgmIgI!CVU_5pTTRrBCs5u_YH1-R_ETfhPppK_0dKzNhysV3lg

--Ys: Memories of Celceta OST
『イース セルセタの樹海』オリジナルサウンドトラック.7z 1.09 GB
 /#!Z8JwgKJC!fJh-Kk-HTCEFnwF-ty0LNWtPvpNOV1pZIK6SWKZABmE
-Ys Celceta CE Collector's Edition Silver Anniversary Edition
[EAC]Ys SILVER ANNIVERSARY EDITION -Music From the History of Ys- [3CD](flac+cue+log).7z 1.69 GB
 /#!M1tSTBwQ!aQFnHTQjl87kKbdti25Wq3K1knQOr4M4rfun4PtfjJM

--Ys VIII: Lacrimosa of Dana
Original Soundtrack
[EAC]イースVIII -Lacrimosa of DANA- オリジナルサウンドトラック [FLAC+cue+log+BK].7z 909.9 MB
 /#!GMlRlAgT!r2fh4BlDeBndfkCLlLbivI1kkex-FqaiTBDpHj3nd7E
[mora.jp][Hi-Res] イースVIII -Lacrimosa of DANA- オリジナルサウンドトラック [FLAC 24bit／96khz].7z	3.97 GB
 /#!hZQXXawA!NAJaJG42Fg427FN7_mKxZ5A_1I69g6B3nJVgyhdmarc
--Ys VIII: Lacrimosa of Dana OST: Append Music Collection (The 6 PS4 Exclusive Tracks)
イースVIII -Lacrimosa of DANA- オリジナルサウンドトラック 追加楽曲集.7z	351.2 MB
 /#!2UMUSSZK!W5FikkK4QSOL2ptFQyhEbd6e4CbINlDR2mSjrLdW4zs
Mini Soundtrack
[EAC][160721] PSV「イースVIII -Lacrimosa of DANA-」オリジナルサウンドトラックmini／Falcom Sound Team jdk (flac+cue+log+bk).7z 133.1 MB
 /#!sYpTgApI!dlOjjXz5i8X5eyel3xh5MGKoIsjbcfdMG35UabkudOY
Original Soundtrack COMPLETE
[Hi-Res][ototoy] イースVIII -Lacrimosa of DANA- オリジナルサウンドトラック [完全版][FLAC 24bit／96kHz].7z 3.20 GB
 /#!wT4EQI7R!27W7ZYmi8qXPSXYChDWHyKAjPY4Y-nCq6ilSnqBZ9t0
[ototoy.jp][Hi-Res] イースVIII Christmas of DANA [FLAC 24bit／96khz].7z	135.9MB
 /#!bYcEwabJ!-2ntf4YHdeZFvXRImrOiP6X5ACOfJRowCi7db4ypEAQ
[Hi-res][ototoy] Ys VIII SUPER ULTIMATE [FLAC 24bit／96kHz].7z 1.18 GB
 /#!xsgxACSK!xXaJP15z150sDxoGsak8O3MMBuEcd8O22gxyCY1rYcs

--Ys IX: Monstrum Nox
[Hi-Res][ototoy] イースIX -Monstrum NOX- オリジナルサウンドトラック [FLAC 24bit／96kHz].7z	2.89 GB
 /#!w4BikagR!kaVXgxCjJAS7PRbvEe6YKDvtARlOgTL_0kdDzO-WGEY
24 bit 96khz - Ys IX SUPER ULTIMATE.zip 1 GB
/file/BQ9RHACY#7rkcRTl8EycDZ1LdYoCMxxEpF5i9yUDh-OBcX8CWXSw

--Ys Strategy
[EAC][060323]イース ストラテジー オリジナルサウンドトラック(flac＋cue＋log＋jpg).7z 142.0 MB
/#!U1FxhZwK!XM_jizisKyUNn1D9gD2M2To-5ksrm0SWY4nGIrANLrM

--Miscellaneous Ys
Ys SPECIAL COLLECTION -ALL ABOUT Falcom- MEMORIAL SOUNDS.7z 416.8 MB
 /#!5kBgzDLA!AipBpnd-J28lY3RT-Do9KiWWtFEcpEjCfQDTCPQFYb4
（C83）[121229][Falcom]Ys ZANMAI[CUE+WAV].7z 376.6 MB
 /#!89xU1LhR!ApJb_Ud-kdZ1pGxb9q3VdX8mv302-SKOSS_wbrlwR-k
[EAC][881105]SYMPHONY Ys(交響曲イース)(flac＋cue＋jpg).7z 217.4 MB
 /#!Aw0gmZwD!Jf5isT-O6vcujSl4CEdmp1lLyCEsVIBcLoKyW2FmBsk
-Symphony Ys '95
[EAC][950524]交響曲イース'95　フィーナ～草原～そして旅立ちの朝(flac＋cue＋jpg).7z 274.7 MB
 /#!lgEhXazQ!IW7-I38kLsoRZQoIlWN7ADqEJaZYYd9qL0mu5Z11Mgs
-Symphony Ys -21st Century-
[EAC][010628]交響曲イース -21st Century-[FLAC+cue+log].7z 189.7 MB
 /#!nQsTlRoI!Y4YUJg0Xn0O69jzDB5zmS07EalnvVQIuD5dHV5yEePU
[EAC][980424]イース スーパー コレクション(イースエターナル初回特典 Ys Super Collection)(ape+cue).7z 507.1 MB
 /#!90BmxQJJ!DaMhUH6A2KoZY4ztja3FE0nDtMQ6RNF7PclC4_xK6GA
The Collected Ys MUSIC of Ancient and Modern Times.7z 335.1 MB
 /#!5s4hETJY!eOCIan4BVvh3R-Zc5GhJXXn-jJZllDOxKgcXDYFUiTg
-Ys Music History
[EAC][090917]イース‧ミュージックヒストリー （イースセブン、予約限定特典）(flac＋cue＋log＋jpg).7z 531.0 MB
 /#!w8E2kLSL!MeWctU6nBWhW663urYMiWFn3aRxQlkEOTe31YtSLdIs
-Provincialism Ys (プロヴィンシャリズム イース)
[EAC][KICA-1051] Provincialism Ys [flac+cue+log+jpg].7z 241.8 MB
 /#!loERzb4Q!cpVtfxd0WGCFJd_jHzEVtnwTTmhXgNvA5vSNQxaKjDg
[EAC][011220]Ys Healing(イース ヒーリング)(flac+cue+jpg).7z 209.2 MB
 /#!h9UgSb5b!OQhmCFyvCbJKx7d7h8KHP3u2htwK5clWdzdci49Sc-8
-Falcom Label The 10th Anniversary: Very Best of Ys
[EAC][981127]ファルコムレーベル10周年記念特別盤 ベリー ベスト オブ イース(flac＋cue＋jpg).7z 404.9 MB
 /#!BktgmQ6I!enuHOHOk_5LQ6888wRHH1GtKW-YE9yC0g-5OH7KsM9Q

--MelodYs and HarmonYs (old &amp; new)
[OLD VERSION] MelodYs and HarmonYs [FLAC+jpg].7z 1007.1 MB
 /#!Ml4AkArS!uK4m6QbiUH5mJx9ikWrQWMHVq-JAPnAFcLTo-ux5UV4
[NEW VERSION] MelodYs and HarmonYs [FLAC+jpg].7z 1.28 GB
 /file/18JGUYQD#_f2WUo7KeIFB9QKsEvUpciuyW_-mJnlPqcjTX7GyeYY

--Ys Anime section
[EAC][910521]イース・ドラマチック・コンサート(Ys Dramatic Concert)[flac+cue+jpg].7z	301.2 MB
 /#!Yd422KiS!5OqD5bElwGlGkFB3MMzk65uDDU4gUtdJwtrrm-oy6GI
Ys: Tenkuu no Shinden (Ys: Heaven's Sanctuary) Original Soundtrack ~ Electric Orchestra
[EAC][010210]イース 天空の神殿 オリジナル・サウンドトラック 〜寺嶋民哉ｅオーケストラ編〜[flac+cue+jpg].7z	329.9 MB
 /#!5AZRkQrR!8wp9Y29xqn06sQ_EsXqutLyb8cmuYudem8axHs3ICqE
Ys: Tenkuu no Shinden (Ys: Heaven's Sanctuary) Original Soundtrack ~ J.D.K. BAND
[EAC][010210]イース 天空の神殿 オリジナル・サウンドトラック ～J.D.K.BAND編[flac+cue+jpg].7z	413.1 MB
 /#!MMpDSYRD!-atbNXIctIluKWcfp1HnO554Xi5jCJ94nvg4Y8w_aok

--Fan-made Roland MIDI arrangements of Falcom JDK music. Falcom Music Room's owner closed the site in 2008.
These recordings were WAV files directly made from the official Roland Sound Canvas VSTi using SAVIHost.
Credit goes to Dragoon En Regalia for his work on this.
Falcom Music Room Sound Canvas MIDI Collection V2.0 (FLAC).7z	2.55 GB
 /#!lARFSS6R!W1tgXpO4dh4FoklzICeDd518k87yCrG02x44G-sIFgE

--FMPSG001-020. Some of these CDs had Falcom related tracks so I compiled them into one archive.
FMPSG Falcom Arrangement Collection (from FMPSG001-020 CDs)[FLAC].7z 354.6 MB
 /#!hc4FkLJT!Ke0P_yPB8noOz6nIH3GBlj2MXUbYcTxhYP09JSAFUmk

--Doujin CDs (all CDs have at least one Falcom related track in them)
Aoki Katsumata - Arrange Project- Ys X Kiseki.zip 415.2 MB
 /#!ElZAlaLD!6iIjKAtO-Thn5eixie1dS46psRjHzC4lUvTvIGK0yJI
The Legend of Xanadu Arrange Album KLEENE
 /#!7MVjmZaL!22LRvuykAwC7Zg06Bc8io3Kv-No_f0SOfT8DDoat8L4
[EAC] Yuzo Koshiro Arrange Collection [flac+cue+log+jpg].7z 313.7 MB
 /#!NEQ2VIiD!XyKLMDRMeV10ruUoBmeWuQLQE7P9iO7siie3T-3TE78
[EAC](C68) 2005.08.14 [OEMM-0088] sepher.jp [FLAC+cue].7z 1.28 GB
 /#!1QhnnaBK!Y5cXclLAh3RcWy0th8OcNp2gYedR3VLm7LtfRQiVphc
-Snow Rabbit-
[EAC][050814] (C68) (同人音楽) SYNC ART'S - ゆきうさぎ [FLAC+cue+log].7z 461.5 MB
 /#!yEMlFRLA!9cOc_3TCuMW2Y84ieH7oLiwDmVhG1Y9T_4FHFpEEzfU
[EAC] windtales from Ys - Mushi.net [FLAC+cue+log+jpg].7z 278.4 MB
 /#!uMFmkKQY!PBil5pL2rDTweFYB4sHl8kFwlXss9aftNthmtD4BkrE
[SFCD-0001] ANCIENT GRADE.7z 375.4 MB
 /#!5kMSiIBR!dAju1BRa_XpkrWr1LH6BL0KJ-FJEnxB6TmdPhyNVkoY
(M3-27)[EtlanZ]ふっかつのじゅもん～MEMORIES OF GAME MUSIC～(flac＋cue＋jpg).7z 595.4 MB
 /#!eY0EgAaD!D449E-5M2AehwSeQKMpCKAM5kvSKv00Td4zZXpEtxy4
[061009](M3-18)[Zephyr Cradle]Bifrost - Way to Chronos [FLAC+cue+log].7z 222.9 MB
 /#!XJNCEI4a!1qGjYqDQR4OE_tilsjs2KENqh6UPu8wNlwfLOFJHkkg
[041009](M3-14)[同人音楽][とよしまハウス]Falcom Collection イース vs 英雄伝説[FLAC+cue+log].7z 232.4 MB
 /#!iBUzmbBK!16mT9ie6wmHRL0yqS4dpTx-xcKb49tOAPJqMkfu-V9U
Endless History - Ys 1&amp;2 Series Arrange CD.7z
 /#!dpRk1A4I!J4vm5lIWqp7wtCTy-S3ZuWg71Dk9sfBBsEjkF_HUXFM
[031230](C65)(同人音楽)[Levo Lution]REFLEX[FLAC+cue+log+BK].7z 552.1 MB
 /#!iJ8QELRJ!exDQ0VDah4-kG9EclDe6k77ysfiqGfZyHbLGydjmtTQ
[M3-29][Dangerous Mezashi Cat] Newtype Destroyer.7z
 /#!ggBkEC6Q!ahkfSQm_oga7kM9yrkNRGhmfJ6VP4DQds9tpIJP7eko
[EAC][大江戸宅急便]f [ef] The Falcom game music arrange collection [flac+cue+log+bk].7z	367.8 MB
 /#!2BFiUKbS!ffFvpnEjJb4nqahyn1Yb4JwYWhn6HcwQPA85-AoBQQM
[041230](C67)[同人音楽][大江戸宅急便]f II[ef]The falcom game music arrange collection 2(flac+cue+log).7z 529.0 MB
 /#!IklnzZjZ!Wi36p3v9yQDkXxeHic_a1gaT9Qsa4SvN1y2PKaMlhZY
(C66)(同人音楽)[Levo Lution]PHOBOS(flac＋cue＋log＋jpg).7z 522.7 MB
 /#!E8kh0DRQ!CSt1LntjI_81mSp9kCEI1XHQrHJhN47kcqw5rovqAPg
(C74)(同人音楽)(東方)[Karkan]幻想英雄譚(flac＋cue＋jpg).7z 276.6 MB
 /#!dsNWSLSY!Q30742TBXAn9vwY62jKRzUKzFrdSCLhPlGSSWb6h1DU
(同人音楽)[Mushi.net]イース バトル·スペシャル(Ys Battle Special)[FLAC+cue+log].7z 284.9 MB
 /#!nZEBSQjD!SRxO7Qf5-U4DHGw_07IQC2LzDdCPGCcFrfqEufbTteU
[981231](同人音楽)[Mushi.net]Ys MIDI蟲 Special(flac＋cue＋log＋jpg).7z 264.0 MB
 /#!IwswGLRa!GHglZgh9aT573lMIfsZ_4zjImxA0zRwrVoAx1RENNO4
[01](同人音楽)[Mushi.net]Ys MIDI蟲 Special II(flac＋cue＋log＋jpg).7z 324.3 MB
 /#!tl9RnKbb!X8uLgxTc7XQRc3E7j-PxyBvD7ntIdZTZXLaXa-En-qg
[2005.08.14] Levo Lution CLSADE (C68).7z 530.5 MB
 /#!iJ1AWCja!EvBUyB85uEj7BbWpS75iFn2fW8jBlBRzLMjx80xEIjA
[060811](C70)[同人音楽][Levo Lution]Earthlight [flac+cue+log+jpg].7z 479.1 MB
 /#!VskEQQKA!TN2Zhwp43esiTc4yXHcJDUwF-ch-UBSPPFpneHWqBuU
[060813](C70)[同人音楽][SJV-SC]Spiritual Energy(flac+cue+log＋jpg).7z 162.0 MB
 /#!VocjhDbC!F8vdVjdAqhXRYOIlQMW282W1NM84gbbd8jxNM0SFjf4
(To the Boys with Wings) LAYER-0 As'257G - 2006 - 翼を持った少年達へ - Falcom Arrange Collection I [FLAC].7z 323.4 MB
 /#!GM8D1AxZ!C4cu7G25zx7zFJ71s8KTaKnfMWfTBoj0qEx_e_sM6HY
(Sora he no tsubasa) [070817](C72)[同人音楽][LAYER-0]天空への翼 - Falcom Arrange Collection II(flac＋cue＋log＋jpg).7z 240.1 MB
 /#!tl810CIT!OV2iFCPkieowpuCydkU3ai-TpvofkxMMLnmClyujG0Q
[120124](同人音楽)[OverClocked ReMix]Unsung Heroes(flac+mp4＋cue＋jpg).7z 603.3 MB
 /#!18ESEQjB!ebVyVC-qE-zEripsI4JeTwXhFB15u2RSuv0K8kEbDYc
2005.12.30 [K2-0001] SUPERNOVA [C69].7z
 /#!g45CWK7a!eD6Tvhfdm52wc1EKKsxwyAu58QAFLZhOqJm6cmwA4U0
[081229](C75)(同人音楽)[WOODSOFT] めっさ!!ちいさなたからばこ(flac＋cue＋jpg).7z 345.4 MB
 /#!E90FHT7L!eAhTDmLfB8ECGXS__aISNSHxfksASXdjW1g3SZMjpMc
[EAC][100911][Enterbrain]プレススタート 5周年記念アルバム(flac＋cue＋log＋jpg).7z 318.0 MB
 /#!0ssxhT7L!MhQAdgBk6AiluHE-PakD2QpR1axyIeMTuIFs8H-saO8
[EAC][100922]PiA-COM II／PIA-COMS(ピアコンII／ピアコンズ)(flac＋cue＋log＋jpg).7z 173.0 MB
 /#!Fxt3jYCL!cHdEaiZVD9IgJMGYXWVjWnG8sBcwCVUxcg1X3EfmAV0
(同人音楽) [AWG software] BOSS TUNES [falcomボス曲midiアレンジCD+オリジナルソフト+midi](ccd)(C66).7z 45.0 MB
 /#!E4cQhQob!ezfMvGfy8TIj9m2fxgv7dWypKuY0CMlFVCRTgewq0So
+Out of Sight (Tak Ohmiya, Taka) - 2003 - Ys Series Metal Arrange CD Tears For The Lovers [FLAC+cue+log].7z 408.0 MB
 /#!7Q0DmIoJ!tmKWGUuB_yBpr37E79H9jrevOygbzJ9eo2Bw0ZaoJ0A
--Hellion Sounds
2004.11.19 - The Sentence of Death Extra Tracks [FLAC] {HSCD-0002}.7z 214.9 MB
 /#!TIVB0KQS!XIZHi_8sClJ0TQoT79E0h65NozQnS41CsXQZBQtXivA
2004.12.30 - Baroque (C67) [FLAC] {HSCD-0003}.7z 422.7 MB
 /#!fVcXyKbJ!ZiYDcSzYtWoL6VHtuOKH_C9itkdjcpwvnSdGsNbuxpw
2007.08.17 - Legacy (C72) [FLAC] {HSCD-0006}.7z 413.1 MB
 /#!XBk2BIRL!g_EzHbW3XLmzzqdkHSjRaFLQaVRXzZPUc5VIp2-PHsQ

-LEGEND OF HEROES: GAGHARV TRILOGY
[EAC][010913]交響曲ガガーブトリロジー (Symphony Gagharv Trilogy) - Falcom Sound Team jdk [flac＋cue＋jpg].7z	348.6 MB
 /#!MEYHzZ4L!lZRVDmKKNofQxnVhsxudQWyb95mADNSd-YtKFyP6AhU
[EAC][991209]Gagharv sound trilogy -ガガーブサウンドトリロジー(含特典)(ape＋cue＋jpg).7z 718.3 MB
 /#!A5pknYIC!QyBTwSj1MOhys038WIdql1d8ZxMwOPwlQFaDD07YDM0

--Legend of Heroes 3: White Witch
[EAC][000316]英雄伝説III「新･白き魔女」オリジナル·サウンドトラック-前編-(ape＋cue＋jpg).7z 368.4 MB
 /#!ssp1QIAB!TN1ZKB8PERPD2CuCNvcyA0sJKa4_y5wtnyLjKD4bIM0
[EAC][000316]英雄伝説III「新･白き魔女」オリジナル·サウンドトラック-後編-(ape＋cue＋jpg).7z 380.2 MB
 /#!U8YDiRwa!MItlRUUuMZ6Xrq7AXQ_yFgLc-ogXCgI1p6iV-1x7vwo
The Legend of Heroes III - White Witch NEC PC-9801 OPNA (.VGM Source)[FLAC].7z	652.4 MB
 /#!lQwXzIjA!C9psIT1OxqTS6MqvOz4kB16r5NiOPgUjOt0yi2qnlAM
Legend of Heroes III -first part- General MIDI Soundtrack (SCVA)[FLAC].7z 413.2 MB
 /#!bA1hRJLS!HDbQC4hXBcaadlopgw6C3YWRvUfuOga3UhUivE0IrDc
Legend of Heroes III -second part- General MIDI Soundtrack (SCVA)[FLAC].7z 310.4 MB
 /#!bF0Q1K7R!N5Uoi9mOrGsgcecsv6JlyaJOIYeyn1G9rSpEqoQJSQw
[EAC] Symphonic Fantasy - White Witch (2002) [NW10102510] [FLAC+cue+log].7z	301.2 MB
 /#!LVtijSAK!JAdtT1RXt_226Xn9X6lSXL2qwzcVBUsSHoTxouQ-i-g
-THE LEGEND OF HEROES III Windows Version SC-88 MIDI Soundtrack
LOH III 新白き魔女MIDI全曲集 (SC88+SC88Pro SCVA)[FLAC].7z 995.6 MB
 /#!iRMl3a7Y!dtcRBm74S5TVY-dpNTQNX8jzKWgot5cWCyjTmZiwBpo
-New The Legend of Heroes III [Gagharv Treasure] Vol.1 (ISO includes materials and MIDI)
[iso][19990423]新英雄伝説Ⅲ 「白き魔女」ガガーブの宝 その1[flac+bin+jpg].7z	477.5 MB
 /#!tIgwRCJT!Ytsk74Lcl5oJDgBNrkiGrIh3QWEKQqejZRi7CCB2mp8
--Legend of Heroes 3 PSP
The Legend of Heroes III White Witch (PSP New Arrange)[FLAC].7z 147.3 MB
 /#!iENkwAyb!apNHof5_qfd3YPAHvZ_Ys0xhQJbC5sxOgsRkJSn_skU
[EAC]『英雄伝説_ガガーブトリロジー 白き魔女』オリジナルサウンドトラック.7z 374.8 MB
 /#!kkdmVCAa!AJFociauHSL81HNya6soxGUIZsZjG5KMz5PjSUAczlM
[EAC][050324]英雄伝説 ガガーブトリロジー「白き魔女」OPテーマ - 時の向こう側／riya(flac＋cue).7z 132.0 MB
 /#!c1EGyBzZ!UgeluSGjRV5NnuWizbCQpnc3GuFkP-xUdZ1pXMi_aK8
--Legend of Heroes 3 Drama CDs:
[EAC][941202]ドラマCD 英雄伝説III -白き魔女- [FLAC＋cue＋jpg).7z 369.8 MB
 /#!rA0WSAiD!zN7Q0nQdNFzj6qElJGHkaqUS-shn3--yKH4Y4TZUDho

--Legend of Heroes 4: Tear of Vermillion
[EAC][010210]英雄伝説Ⅳ「朱紅い雫」オリジナル･サウンドトラック(ape＋cue＋jpg).7z 817.6 MB
 /#!gwYHGYbD!L3MiLzhG1cQAbcrYbbwRkiFgzW1W7n7MT5KaAWaFR4s
[EAC][960921]英雄伝説 IV エレクトリック・オーケストラ(ape＋cue).7z 233.7 MB
 /#!phB3TCJR!VbtHim4f1330xz-ayfJq7R5bEiZ92RvZxBS_5LO5cRY
[EAC] The Legend of Heroes IV MIDI Special (flac+cue).7z 899.8 MB
 /#!xsMQjDIA!EnMCCE5hslGEdShgJNLOtDZOoT523PAR1o0yFisqFGg
-The YM2203 chipset has different instrumentation from YM2608,
unlike LoH III which is the same with missing samples.
[YM2203 Version] The Legend of Heroes IV - A Tear of Vermillion NEC PC-9801 OPN (.VGM Source)[FLAC].7z	465.4 MB
 /#!NRRTCQhC!9AaMNfWlfQGNn_qOtZQdUB3gosklKdPriEqf7bslZ94
[YM2608 Version] The Legend of Heroes IV - A Tear of Vermillion NEC PC-9801 OPNA (.VGM Source)[FLAC].7z	676.0 MB
 /#!UQ5jkLrK!nQxvEBXqFCtiFsC-m0O4Dl3LoSKl3vELrUAB3oQkCQw
The Legend of Heroes IV A Tear of Vermilion (PSP New Arrange)[FLAC].7z 181.8 MB
 /#!CF8FTThC!x6vSczIZwDi2odue9nv4Xd5TGkBLGjjYlvKG0FRmsic
-THE LEGEND OF HEROES IV Windows/PC-98 Version (SC-88 &amp; SC-88Pro) MIDI Soundtrack
LOH IV 朱紅い雫・初期版MIDI全曲集（SC-88版 SCVA)[FLAC].7z 863.3 MB
 /#!bQ0gCT7Y!y92_wpR8IHUrKxTl22IDZjyA8j0B-eWYUYWvBXRqEYQ
-LOH4 DOS IBM-PC version (TAIWAN, TAN TON NERW)
The Legend of Heroes IV - A Tear of Vermilion (IBM-PC TAIWAN)[FLAC].7z	390.5 MB
 /#!qA0ACL6B!JqCFnmHEO8XoK5PUlioL5dwBw4vX6S9OZa9Qqw9iulQ
-This is a special SC-55 software recording of LOH4. It's the closest and most accurate recording compared to how the original sounds through a real SC-55.
Legend of Heroes IV SC-55 (Ristar Tweaked Software Recording).7z 1.05 GB
/file/dFtEQTDL#nytIlkXL933pigZuIU2FM38SYuPBcrmPvryoMae_IGE

--Legend of Heroes 5: A Cagesong of the Ocean
-The Legend of Heroes V Original Soundtrack
[EAC]英雄伝説V「海の檻歌」オリジナル･サウンドトラック- 前編+後編(ape+cue+jpg).7z 680.3 MB
 /#!IpB30QAI!Ng2o8y1CsUuvc0n7B59MkhnXcGMVazYYkFE7LwMCHog
The Legend of Heroes V General MIDI Soundtrack (SCVA)[FLAC].7z 681.5 MB
 /#!SU9DXARJ!6K0QIuTGz2kaCfzJNqBUsWFfg0cwOQtu-LsnUKbb5XU
The Legend of Heroes V A Cagesong of the Ocean (PSP New Arrange)[FLAC].7z 189.6 MB
 /#!6YFkHDzR!SQQmkjAIJPHsPRniE5qlv9KS4SVZweXDpPDwzCrWgQQ

--Zwei!!
[EAC][011220]ツヴァイ!! オリジナル·サウンドトラック(ape＋cue＋jpg).7z 618.6 MB
 /#!I9Q0jTCa!GBQDLCGIYjkyQNK0UwOpTlOSTQErobecOjIDvmQHulo
[EAC] Zwei!! Super Arrange Version (2002) [NW10102540] [FLAC+cue+log+jpg].7z 315.9 MB
 /#!QxBTwYLK!0k6_vdETOJQnGs3vWHwtXcM_vdFcvikVCxDIU5xCnI8
[EAC][081211]ツヴァイ!! オリジナル·サウンドトラック2008(ape＋cue＋jpg).7z 449.0 MB
 /#!IhZgmZqJ!DUJdonlIc9bzgHjmHgU1A3KtIAIZSJa3zCLWLiYihMY
--Zwei 2 (Zwei: The Ilvard Insurrection)
[EAC][080925]ツヴァイ２ オリジナル·サウンドトラック[2CD FLAC+cue+log+BK].7z 833.5 MB
 /#!WFFkXZjT!E78I08FvuwR2uA0vHRJnUUkOaJGK5cH-MAsfDpfENz0

--Falcom Special Box Collection
[EAC][881205]Falcom Special Box'89(ファルコム スペシャル ボックス'89)(ape＋cue＋jpg).7z 672.1 MB
 /#!glhH2bQA!ZW3laDcDJe1Md7LkUZMZOGtMfg8RGyOtK0azmgxcXAs
[EAC] Falcom Special Box'90 [FLAC+cue+log+BK].7z 504.1 MB
 /#!os4DDCwC!Zr8MKLivyEWBd9YHPPdWm6qMKusVDBNxCiL5LjDcNYA
Falcom SPECIAL BOX '91.7z 834.8 MB
 /#!pgwWRYgD!O5-qjxPi2GzjHvUfk3HOL3aejIwGELJxjjfJxNRKIpM
Falcom Special Box '92
[EAC][911221]ファルコム スペシャル ボックス'92(CD3枚組) [FLAC+cue+log+BK].7z 521.6 MB
 /#!SINXzajB!S1sTOR55a8vFV6UffC-02oNOi5RpzaCoHrxHFN5itoQ
Falcom Special Box '93
[EAC][921224]Falcom Special Box '93(ファルコム スペシャル ボックス'93)(4CD)(flac＋cue＋jpg).7z 1.05 GB
 /#!MhxjAYKQ!W3HVMWSq439SpvlrUCnnAl_Cr6gu8C3gDD0CCBCvbQI
Falcom Special Box '94 (replacement new rip)
[EAC] Falcom Special Box '94 (ファルコムスペシャルボックス'94) [flac+cue+log+jpg].7z 793.3 MB
 /#!sppWQKYC!7YQraZEEPYd7Zn7pdhBJ4uLiUbMCOUZ78v_ldaJy3VY
Falcom Special Box '95.7z 1.39 GB
 /#!J8ZCXBrK!XgfXimXZV1-sNVBRn_a-cBU-_ixQ_CtL8-iNn49yj5A
Falcom Special Box '96
[EAC][951221]Falcom Special Box '96(ファルコム スペシャル ボックス'96)(3CD)(flac＋cue＋jpg).7z 1.44 GB
 /#!JlBFCTpR!QhZOoljCzfW9Oq4s7-AwPmFb_E8zjzZbysI0V984xE8
Falcom Special Box '97
[EAC][961221]Falcom Special Box '97(ファルコム スペシャル ボックス'97)(3CD)(flac＋cue＋jpg).7z 1.08 GB
 /#!g1owHCSS!UYtypVY_kzw4VI3aGECjFGm7_TliufZsPpNDlWLPvYY

-------------LEGEND OF HEROES: TRAILS IN THE SKY FC, SC AND 3RD--------
--Sora no Kiseki (Trails in the Sky) First Chapter
英雄伝説Ⅵ 空の軌跡FC (Trails in the Sky) Original Sound Track [FLAC].7z	722.4 MB
 /#!BRgi3bDR!LNhxkG30y8hXhk6I1E1uyPYlxW0C8QGy37Hlo_0rbkM
--Sora no Kiseki SC (Trails in the Sky SC) Second Chapter FLAC version
[EAC]英雄伝説Ⅵ 空の軌跡SC (Trails in the Sky SC) Original Sound Track [flac+cue+log].7z 889.6 MB
 /#!dEQylBJD!GIL4z8uvYcNzV6bFU3-lqbkkUvjlpLKVLpy0MJj0xSY
--Sora no Kiseki SC (Trails in the Sky SC) Second Chapter WAV version
[EAC]英雄伝説Ⅵ 空の軌跡SC Original Sound Track(wav+cue+ジャケ).7z 1.21 GB
 /#!0oA3VZbJ!ST7uMS0bXbm2u2yyhaHCKCVwExc6OciS1SZ_kuNULO0
--Sora no Kiseki (Trails in the Sky) Third Chapter
The Legend of Heroes ~Sora no Kiseki the 3rd~ Original Soundtrack.7z 895.6 MB
 /#!ycswiLZQ!Doo3mKFR1y86OAWIES25rIKV0uApNZoqAVDTa0FkzYo
--Trails FC Super Arrange 
[EAC](サントラ)英雄伝説Ⅵ 「空の軌跡」初回特典 スーパーアレンジバージョン [flac+cue+log].7z	269.9 MB
 /#!sQQA3SDQ!fx90mcal20L3EKk2Wb3DHt1zufYVzRq8-b4Y5CGliNE
--Trails First and Second Chapter Super Arrange
[EAC]英雄伝説Ⅵ 空の軌跡 FC&amp;SC Super Arrange Version.7z 762.5 MB
 /#!0xQFUAJJ!AF7FZgGpwPL_Ij6YMBMnuWVo3oI-4ygz1CCnJgZ35TY

--Sora no Kiseki (Trails in the Sky) Evolution
Falcom Sound Team jdk - 英雄伝説 空の軌跡FC (Trails in the Sky) Evolution OST (FLAC).7z 773.5 MB
 /#!111z2JqT!a86ew_nOoeX1pMQVcBKCkYCNW4di6Tte2rKN9Cvee3g
[Hi-Res] Falcom Sound Team jdk - 英雄伝説 空の軌跡FC (Trails in the Sky) Evolution OST (FLAC 96kHz／24bit).7z 3.92 GB
 /#!5tM3RR7J!ENYjFFAHPOx7-s7OTn0zGHUrT-C4T-T0Ztury574Ob4
--Sora no Kiseki SC Evolution (Trails in the Sky SC Evolution) (英雄伝説Ⅵ 空の軌跡SC Evolution)
[EAC] Trails in the Sky SC Evolution Original Soundtrack - Falcom Sound Team jdk [FLAC+log+BK].7z 920.0 MB
 /#!vU1TTRDT!CkxrU6YachZYPn3pFcVpbqrkd6o9bt3svwvLgGc9jNo
[Hi-Res] Trails in the Sky SC Evolution Original Soundtrack - Falcom Sound Team jdk [FLAC 24bit／96khz].7z 4.14 GB
 /#!mEUQGY7A!DOW1R_6EUXm0YA3bX9C8L0qG3hjTj6pbYXfRXJYMudE
Trails in the Sky the 3rd Evolution:
[EAC]英雄伝説 空の軌跡 the 3rd Evolution オリジナルサウンドトラック [FLAC+cue+log+BK].7z 1001.3 MB
 /#!DA11HaSB!wkNenh-LMIR7iToY44UTmc93avL1g82tpQCmaAvRQB8
[mora.jp][Hi-Res] 英雄伝説 空の軌跡 the 3rd Evolution オリジナルサウンドトラック [FLAC 24bit／96khz].7z	4.35 GB
 /#!YMgVSJBR!1f7Q7uPX95VBQMdk-8b_gnMU576_1fBN5tmBiL87bUE

Sora no Kiseki Zanmai
072313SNKZFL.zip 318.4 MB
 /#!k45FGDrS!LkGQrSM01LlLIOocN0XOYgq59UAwDPN0IpD26Qy1dN4
--Trails in the Sky Unused Music
[EAC][040624]Falcom Sound Team jdk：未使用曲集「空の軌跡 通販限定特典 unused music」[flac+cue+jpg].7z	262.1 MB
 /#!xYg0nSLY!JiqK6RGEiOxWlOtaAknp9rIS53fsP4qDXqaMPOAAvJo
--Looking Up At the Sky - Sora no Kiseki Vocal Version
[EAC][060825]空を見上げて ～英雄伝説 空の軌跡 ボーカルバージョン～(flac＋cue＋jpg).7z 693.4 MB
 /#!h9kzhA5Q!F7vwJHSruDF7dizqnxX1mCmUqFxAxgu1DqLcx4x4170
Hoshi no Arika Zanmai
[111230](同人音楽)[Falcom]ほしのありかざんまい(flac+cue+log+jpg).7z 388.9 MB
 /#!MpEy0QzZ!BgFYZigWoQ22Y4c-3W5rsx_qHZ0cmeha4qYlvJzoC8w
--Character Songs (Trails in the Sky FC Evolution) [FLAC]
Falcom Character Song Vol.1.7z 141.4 MB
 /#!BcpRhCrT!6i0JDnhosryoy5sBRze-rneWaXn6fyXeicYtqtu73vI
Falcom Character Song Vol.2.7z 114.9 MB
 /#!AFxBUS5I!K89Mtqsvzk5FMj3yB0mzEGe2r4siCrNXiqP8eSI8y9w
--We Love Sora no Kiseki (Trails in the Sky)
[EAC] We Love Sora no Kiseki - Falcom Sound Team jdk [FLAC+cue+log].7z 291.0 MB
 /#!qYEVhQRR!bJpeqn56z-IbDbrn_xZHAXigpvbQhw80eZbpKLMekzc
[Hi-Res][ototoy] Falcom Sound Team jdk - We Love 空の軌跡 [FLAC 24bit／96kHz].7z 1007.7 MB
 /#!6VNXwTQA!4VQGb-ftrJ0QntIsThBKEszdeoG0cAInkSfkdNdzZ9I

--Trails in the Sky Anime section
-The Legend of Heroes: Trails in the Sky THE ANIMATION Original Soundtrack CD
[EAC][120224]英雄伝説 空の軌跡 THE ANIMATION オリジナルサウンドトラックCD[flac+cue+log].7z 265.4 MB
 /#!FAgRXbBL!xnVojmqY7d5CNCGR8G36SaogJjAdl8yh88TqGChKLgI
-The Legend of Heroes: Trails in the Sky THE ANIMATION ED
[EAC][111123]英雄伝説 空の軌跡 THE ANIMATION ED主題歌「ハルモニア」／ちょうちょ[flac＋cue＋jpg].7z 158.9 MB
 /#!IABTzLTY!2VI35RMhe7QTaniyghZqLJulI8nECsd5RJH-5U4-gsc
[LACM-4887] ハルモニア／ChouCho [FLAC].7z 144.6 MB
/file/hRdBVITL#kr4bt3cbjRLHFctKKBK6av8MvaY8M0mGEWIqH84k1SQ

--Trails in the Sky / Sora no Kiseki series Drama CDs (ドラマCD)
-The Legend of Heroes Sora no Kiseki Drama CD ~Decision To Leave~ / ~Bonds Tied Together~
[EAC][090425]英雄伝説空の軌跡 ドラマCD ～去り行く決意～／～繋がる絆～ [FLAC+log].7z 821.1 MB
 /#!GJ8kGLwK!RdOWtHlGQniCRoZw-h20LyU0cfaYZQFU8pc3bG_BlQA
-The Legend of Heroes Sora no Kiseki Drama CD Uroboros Report
[EAC][100327]英雄伝説 空の軌跡 ドラマCD ～ウロボロス·レポート～[FLAC+cue].7z 275.7 MB
 /#!yZtDhLRR!GCN7jyAC57NGe_zPDKirlSxjACnxgT0MHZLIIlLsJ5I
-The Legend of Heroes Sora no Kiseki Drama CD Klose Monogatari ~Tsubasa, Habataku Toki~
[EAC][091128]英雄伝説空の軌跡 ドラマCD クローゼ物語 ～翼、羽ばたくとき～[FLAC＋cue].7z 356.5 MB
 /#!WV9FWDwJ!E_HBIFccUFo-5SyTSwOveretLEyN_0GCDdF7Vhx4SIw
-The Legend of Heroes Sora no Kiseki the 3rd Drama CD ~Tamashii no Kokuin~ / The Legend of Heroes Sora no Kiseki Drama CD - Joshua Story ~Sealed Memory~
[EAC][090725]英雄伝説空の軌跡 ドラマCD the 3rd ～魂の刻印～／ヨシュア物語 ～封じられた記憶～ [FLAC+log].7z 810.0 MB
 /#!HE8yXKCJ!xc3tAfEgArX2HBa-8_mcW8CdNnxSk4lMlD0q-9gBZLs
-The Legend of Heroes Sora no Kiseki Drama CD Olivier Story ~Mikansei no Jojoshi~
[EAC]英雄伝説 空の軌跡 ドラマCD オリビエ物語 ～未完成の叙事詩～[FLAC+cue].7z 369.3 MB
 /#!gZJWFYhZ!I9PG1eFpxn5NDuAVrypGrRBo5RKAQSnnKEHcu1dd-_M
-The Legend of Heroes Sora no Kiseki Theme Song Album 2 (Cast Commentary, Vocal, Talk)
[EAC]英雄伝説 空の軌跡 主題歌アルバム2 [FLAC+cue+log].7z 164.9 MB
 /#!QZh11SBZ!aNQBTdZJvlJGaIvvqDxRGo3laLZWBOl-HrfIZbLWlF8
-[PJCA-0003B] 空の軌跡 外伝 The book of CARNELIA.7z 381.0 MB
/file/8YFxXa7C#wLhffFed1lbmVlAH56ey9cOdG9VSf7C7SCy2OHR29p0

--Kanako Kotera
[EAC] Falcom jdk BAND Diva Kanako sings Vol.1 (flac+cue).7z 421.3 MB
 /#!ZxsDUCiJ!ak_agVYEy2q4PskBdNJSBCxrQ1IMkFIslB98YjRRgX8
[EAC] Falcom jdk BAND Diva Kanako sings Vol.2 (flac+cue).7z 395.0 MB
 /#!QxF1nThS!TYdFCzbETVSnb8OAbUK0Rxn7u4QdiB0zgRL0ZSm2lCE
Karaoke of those 2 CDS:
[NW10103230] Falcom jdk BAND Diva Kanako sings Vol.1 &amp; 2 カラオケ全曲集 [FLAC] 777.6 MB
/file/VdFRESRS#9nbXn-USYaESq1cjCipoT6rU73qdKntSBN0D4YTzD38

--Zero no Kiseki (Trails of Zero)
Zero no Kiseki OST:
[EAC][101216]英雄伝説 零の軌跡 オリジナル·サウンドトラック[3CD FLAC＋cue＋jpg).7z 1.13 GB
 /#!Wc9hHTxK!yrxDX4QXtsnVktGn3dBZh_6IiGUuXnW26gM1sTCQrlg
Zero no Kiseki Super Arrange:
[EAC][110218]英雄伝説 零の軌跡 スーパーアレンジバージョン[FLAC+jpg].7z 372.9 MB
 /#!LZknSaDA!IxBAw-zhGRvXr19egbsBTQyga8Wea_elpIoPtuRJDgg
零の軌跡 Evolution Soundtrack Special Edition I-III.7z 409.9 MB
 /#!JsJnXa5A!AF6hnm9_Ydis8VumVEwEtT-gQKZlv7jFvb8kqyn_Y4I
The Legend of Heroes Zero no Kiseki Evolution Original Soundtrack.7z 1.35 GB
 /#!6d81jQRY!bGnHvL9k7ttMnwj-p1k3Mtf1kAE-PmiaN297wFOX2eA
--Zero no Kiseki Drama CDs
The Legend of Heroes Zero no Kiseki Evolution Original Drama CD
[EAC]英雄伝説 零の軌跡 Evolution オリジナルドラマCD 『みにどらまざんまい』[FLAC+cue].7z 437.2 MB
 /#!hUh3DLSK!cPZDSftHqyMVw5lUuMcW-WqZOU5TMpi0OoIw8ZMKjl4
The Legend of Heroes Zero no Kiseki Drama CD Chapter1 ~Shinrotachi no Gogo~
[CADC-0047] 英雄伝説 零の軌跡 第一章 ドラマCD ～神狼たちの午後～ [FLAC].7z 380.2 MB
/file/8AEjSA7T#hMNd1r76plGzqnChbRONPoNmVB0lw_zjLtxnXYsMORM

--Ao no Kiseki (Trails of Azure)
Ao no Kiseki OST:
[111210]英雄伝説 碧の軌跡 オリジナル・サウンドトラック [FLAC+log+BK].7z 901.0 MB
 /#!2cUVTbJb!sV5T8eNIWlHXRSxblxSxGiBb-VyQp4cAQ9Ea8PJ6aEA
&gt;SAMPLER CD&lt; [EAC][140612] 碧の軌跡Evolution SoundTrack CD (flac+cue+log).7z 173.7 MB
 /#!xx8kSYrJ!LcnUwiw32Ys9L26Rb_jKU2Q9C7xLh6WjXTLhbFRfe_E
Ao no Kiseki Evolution.7z 1.12 GB
 /#!8tsUQQbS!VJUL2jm7rTwQECBsPR3klVypd2Ni6sFPiqWWC0vq0Ak
--Ao no Kiseki Drama CDs
[EAC][110929]英雄伝説 碧の軌跡 ドラマCD ～未来へ続く道～[FLAC+cue].7z 380.1 MB
 /#!uJchwCQa!hlJRQHW_gP1ET04gTf0mE3gFYT-l1QjYrTQ9nL06Vl8

--Sen no Kiseki (Trails of Cold Steel)
[EAC] Falcom Sound Team jdk - 英雄伝説 閃の軌跡 (Sen no Kiseki) OST [4CD][flac+log+cue+BK].7z 1.59 GB
 /#!M85nDCYT!SlUCLmK6W4pn2Fl3yQcUsgnsps8-ZLSrI8qZiaYX7mo
[Hi-Res] Trails of Cold Steel Original Soundtrack MASTER - Falcom Sound Team jdk [FLAC 24bit／48khz + pdf].7z 3.82 GB
 /#!vRlVWJJL!kbcZY2T_jWehaqaiwWPPjjhdXm6MNR5SDeuUoHBF1hg
Sen no Kiseki Super Arrange (Trails of Cold Steel) 
[EAC] Falcom Sound Team jdk - 英雄伝説 閃の軌跡 スーパーアレンジバージョン [FLAC+log+BK].7z 351.6 MB
 /#!8lZngZgA!FKLKPV6T38Y7y5R6HF1cIHR1SBx9ybiVMbe9E1CPkAI
The Legend of Heroes: Trails of Cold Steel Drama CD Homecoming ~The End of Uncertainty~
[EAC]「英雄伝説 閃の軌跡」ドラマCD 帰郷~迷いの果てに~[FLAC+PNG].7z	323.1 MB
 /#!FQQwBAgZ!XT_RUlUZZNbdiM8sfg735WUbtSCPzn844isArpORtZ4

--Sen no Kiseki II (Trails of Cold Steel II)
[140806]「英雄伝説 閃の軌跡ＩＩ」OPテーマ『閃光の行方』／小寺可南子 (FLAC 24bit／96khz+pdf).7z 102.7 MB
 /#!Vo91lZiR!OVJM02rgLY3h-wHO_G6OmSNEXCojw6Y8R_nCHQ9Fz8k
Falcom Sound Team jdk - 英雄伝説 閃の軌跡II (Sen no Kiseki II) OST MASTER [48k／24b flac+jpg].7z 1.86 GB
 /#!90lCTLSI!ngTT-S6YCV4uz_gki1Pz6_mhC138zqAh2aWkXeurQR0
The Legend of Heroes: Trails of Cold Steel II Drama CD Side Story ~The Remote Village of Ulster~
[EAC]英雄伝説 閃の軌跡II ドラマCD 『外伝～辺境の里アルスター～』[FLAC+cue+log].7z 310.1 MB
 /#!JBoSjbQT!g5k7X4VOck9B-zkc9flzWJrzXlkyl9A22RDqCksi7E4
--Singles
I'll remember you - Trails of Cold Steel II, Ao no Kiseki Evolution, Tokyo Xanadu
[EAC][160115] I'll remember you ／佐坂めぐみ＜リアル☆SPiKA＞ [flac+cue+log].7z	 169.3 MB
 /#!0MhjgQ5b!w6phom8V9xksqsx3G6YzdQvaJJl2sMsYEPNtSzNUOJk
[Hi-Res][ototoy] I'll remember you -リアル☆SPiKA／佐坂めぐみ-[FLAC 24bit／96KHz].7z 599.4 MB
 /#!0dpzSabI!hwIJsUKpTRBbfK2nu5bcvh6IxyYsETA5Xa_73Sho5-s

----Sen no Kiseki III (Trails of Cold Steel III)
-CD version
[EAC] THE LEGEND OF HEROES SEN NO KISEKI III ORIGINAL SOUNDTRACK Complete Edition (2017) [FLAC].7z 1.43 GB
 /#!wGph0IpR!Bzg8wMCmnq-0qw6jMj0wuEbrVu7__WZd6XCSOsqXjZ4
-Hi-Res 24bit version
[Hi-Res] The Legend of Heroes - Trails of Cold Steel III ORIGINAL SOUNDTRACK Complete Edition [FLAC 24bit／96khz].7z	4.69 GB
 /#!IH5jDYgI!N3OXJU-CCKYA_RehA7YzwffZJskCRfkkrVQfpOZxjPs

----Sen no Kiseki IV (Trails of Cold Steel IV)
-CD version
[XLD] THE LEGEND OF HEROES- SEN NO KISEKI IV -THE END OF SAGA- ORIGINAL SOUNDTRACK (2018)[FLAC].7z 1.18 GB
 /#!sSwmTYLK!l59U4hmezG-96n30SHiLtTbaxePgyMzpA0F65DMkgqc
-Hi-Res 24bit version
[Hi-Res][ototoy] 英雄伝説 閃の軌跡IV -THE END OF SAGA- オリジナルサウンドトラック [FLAC 24bit/96kHz].7z 3.78 GB
 /#!AWphgAxC!PGtbX_qdO0H8jgWmPxSbxcb70TkuWeFfA4rz4iBxAVY

--Hajimari no Kiseki
[Hi-res][ototoy] 英雄伝説 創の軌跡 オリジナルサウンドトラック [FLAC 24bit／96kHz].7z 4.25 GB
 /file/EMtEUTbS#yQsO2LozdpM1StD4PW38X4MQYxWHaeoWiNWNzssF2t8

--Nayuta no Kiseki
[EAC][120927][NW10103170]那由多の軌跡 オリジナルサウンドトラック (wav+cue+log+jpg).7z 1.33 GB
 /#!04pgQTyK!eUQzkhjdxC0UnDYfbk0BhHIHgj4GN7POdxnWwgrm3K0
-NAYUTA NO KISEKI DRAMA CD ~Yoake no Hoshi~
[EAC] 那由多の軌跡 ドラマCD 〜夜明けの星〜 [flac+log].7z	345.8 MB
 /#!TQcygJDT!7fwqHzHvzYl3W7Q2AK6IegzsmLN4peaGZTKkVyXMOoM

--Vantage Master
[EAC][080424]Vantage Master Portable Original Sound Track (flac＋cue＋jpg).7z 850.9 MB
 /#!WNshFCjS!wLaEBIzXHOYPGOYjCpUlEgCHCvns3E43E90xw2S3fj0
[EAC][020627]魔喚精靈3 VM JAPAN オリジナル·サウンドトラック(ape＋cue＋jpg).7z 717.8 MB
 /#!A5ZlkChR!dmkwMgU-zY_ON1X-QMMwwAzJnAcZQZ1u4SDZMQB-ZIs
Vantage Master SC-88 &amp; Pro (SCVA)[FLAC].7z 83.4 MB
 /#!rV1C2AgT!MzgWKWR3vzvmO_9ihNSeRew-T9cjlmr99Xf2o6dpNKQ
Vantage Master General MIDI Soundtrack (and V2)(SCVA)[FLAC].7z 323.2MB
 /#!bRFTxLhA!bwtyWJPv3qvDvJBSi9fTXDz8unxipaXI2ozB5KQgRB4

--Brandish
[EAC][090319]Brandish - The Dark Revenant - ORIGINAL SOUND TRACK (flac+log+jpg).7z 597.1 MB
 /#!RpJXDS6T!KuPd5yzQpyEigPCH775ymDjJoa0htBaHSuCP7PEN5ZM
[EAC][090519]Brandish Original Sound Track ～FM TOWNS &amp; Renewal～(FLAC+log+cue).7z 925.6 MB
 /#!50kVlLwY!eGulWGSKep17W0lpKaH4kSL1cekzZQbjRHRqlmZZbik
Brandish (Super Famicom &amp; SNES)[.spc rip to FLAC].7z    283.9 MB
 /#!rU0CQICY!z5r37TsXN-ePvhTzartMqv8ehWHT1uwfdfsFRIB8c8w
[EAC][930421]Music from Brandish 2 - THE PLANET BUSTER [FLAC+cue+BK].7z 451.2 MB
 /#!yU8nSaZK!6PFrvY6EFlYuSlE8FdJbHub2urnB3OLx4EloxTV3vsU
Brandish 2 Renewal (ブランディッシュ 2 リニューアル版) PC-98 Hootrip + Brandish 2 Unpublished Tracks [FLAC].7z	549.1 MB
 /#!bEMm2SpD!dEFRBiL0tBFdWpNJgUqshSq2oN8qQE4F1YLkz5s2T-A
Brandish 2 The Planet Buster Game Music Files (IBM-PC KOREA, MANTRA)[FLAC].7z 225.4 MB
 /#!HFlnhBIS!HhnkR7ObsUzdXZfhcqzy50MJT4WDOKJ7v9VWUnl8pqY
[EAC][950316]ミュージック・フロム・ブランディッシュ３(Music From Brandish 3)(ape＋cue＋jpg).7z 891.2 MB
 /#!N1hQHJKY!GfXYzCzyVqEkDGCYuwgghR-61_NSC4T1dMXOYJbqchE
Brandish 3 Spirit of Balcan (IBM-PC CHINA, TAN TON NERW)[FLAC].7z	394.3 MB
 /#!iR922Tja!C7KrpuQ3Tk8-z19f7wFusmEDnbivdhIv6UFQvur6ncY
[EAC][941021]ブランディッシュ・ピアノ・コレクション(Brandish Piano Collection)(flac＋cue＋jpg).7z 203.8 MB
 /#!oxEXEahB!BeTMOh8UxFq9WjMLtqJAIQvTnK9ivbo-ss6w2OdwDW0
Brandish VT (ブランディッシュVT) - PC-98 OPNA Game Music Hootrip [FLAC].7z 332.3 MB
 /#!kYZ0iSKD!RZoHeLsJ9JrOAdOPxW-D0gzJ6aiT7qhE-5Pjp749ZRE
Brandish 4 (RIP).7z 253.7 MB
 /#!9skhQBgR!YH3etwXmw11ZEN2IApC3eEwrd-YlEdGeCel-tHN6pUc
Brandish 4 General MIDI Soundtrack (SCVA) [FLAC].7z 422.5 MB
 /#!qVVVVKza!0v1DwJjpoFqk6eEwr5jTauoNDV9bZbhmVpYcBJdGxMw
Brandish 4 Image Soundtrack (GM &amp; SC88Pro SCVA)[FLAC].7z 89.5 MB
 /#!XQ8GEKBC!KALE20WPLQn2TEEn_P7V4NUPiPOmmG4GAF9WmO-QYXM
Falcom Sound Team jdk - Perfect Collection Brandish (パーフェクト・コレクション・ブランディッシュ)[FLAC+jpg].7z	345.2 MB
 /#!hVgBRB6Y!nZKT2BxvWRTMISM9UbxPHG_hjTeg1SbTLUhAM2ZQTRY

--Assorted Falcom CDs

-Falcom ACOUSTICS 2 / Falcomアクースティックス2 
[Hi-res][ototoy] Falcom アクースティックス (ACOUSTICS) 2 [FLAC 24bit／96kHz].7z 750.8 MB
 /file/wctDVQ6a#gUy5iGnu2PID-KY51t8jf3ybTzk0B1AlFdmqIoGH_R0
[K15TH-VO] KISEKI 15th Anniversary Vocal Collection [FLAC].7z 758.1 MB
/file/oZVzzKaJ#wUlskLc7V2xjZkQGcTcx_LzKNOQ_t_u5ZvuBQQgCUCA

-BEST OF The Legend of Heroes GOLD &amp; SILVER
ベストオブ英雄伝説 ゴールド
[ED-GOLD] BEST OF 英雄伝説 GOLD [FLAC].7z 266.6 MB
/file/ZBEjgSiR#imWBRtoLkSN7aSTou5UZyu6xF7fUcx1Tk88iHxNE4gQ
ベストオブ英雄伝説 シルバー
[ED-SILVER] BEST OF 英雄伝説 SILVER [FLAC].7z 434.3 MB
/file/hMFRHAaR#7hfV03sxD8oUh__N1rHn-gdogUIJ906K81kCZCFEjwk

[EAC] Falcom Field Zanmai (ふぁるこむフィールドざんまい)[FLAC+cue+log+BK].7z 340.4 MB
 /#!Iw4lDJaJ!U0JkXzW_-l-IrPbOOK0APBqMiYV90KgUq-cVxGVnigM
Kiseki jdk Acoustics.7z 778.7 MB
 /#!E5EWQDba!90IyffFlv0wATwYSFCZ04zsGUqnfcHDQVqYbDUXGWb4
[EAC][010210]英雄伝説I-IV ピアノ コレクション(The Legend of Heroes Piano Collection)(ape＋cue).7z 196.2 MB
 /#!IgJ2QJLC!X_CXxx4WYL4s_UFgJqlSMG9jbFoQDPvPQCqV3hMVidg
[EAC][080515]ファルコム jdk BAND 2008 Spring(ape＋cue＋jpg).7z 372.3 MB
 /#!VkBmRTqI!N2lgEybi-3E9FoUFKk7s4QOR9BkKVBAaNJvS1jRwtiI
[EAC][901105]プレプリマ M.Fujisawa Pre-Project(ape＋cue＋jpg).7z 253.3 MB
 /#!p54QyLrQ!agOjmwD_V4mcbbYjQP9pmiuI2LJIVmWC_bJCGhdZ0NE
[EAC][910705]PreprimerII - M-FUJISAWA &amp; Pre-Project [FLAC+cue+log+BK].7z 340.2 MB
 /#!GQ1QEAba!8KiPb9TVDXpo3v0hOajXJERLx9Uxq215vKdnDshKVec
-The Vocal from Ys + Surround Theater Sorcerian &amp; Plus Mix Version
[EAC][991222]ザ・ボーカル・フロム・イース Plus サラウンドシアターソーサリアン＆プラスミックス [FLAC+log].7z 382.6 MB
 /#!OdMHna4K!J6tMZBuRWB1gUO-dSNKfm2gIKDPC3fqf6TPQhPju_ss
[EAC][920221]ファルコム ナンバ コレクション「”NAMBA” Collection」(flac).7z 346.4 MB
 /#!I8kQUDiT!dwZpgBykHusludxK9bwBP0iNehV3ksGvPl5RnYt19-s
-FALCOM LIVE 2007 Original Sounds
[EAC][070329]ファルコムライブ2007 オリジナル·サウンズ(CD2枚組)(ape＋cue＋jpg).7z
 /#!05NwgAID!IJLCYm0koqbRCRABfSE1TU3fKrB1wnukwHGipHHs7xQ
-Ys &amp; Sora no Kiseki vs. Van Jyo Drama CD
[EAC][100729]ドラマCD イース&amp;空の軌跡 VS.ヴァン·ジョー[FLAC+cue].7z 328.6 MB
 /#!zINnwAjL!JG9nZAkQP_heyJDWZGznsL_F0qbNKZ4vC-MZy5gmud4
-(ファルコム・エンディング・コレクション)
[EAC] Falcom ENDING COLLECTION 1987 - 1992 - Falcom Sound Team jdk [FLAC+cue+log+bk].7z 844.3 MB
 /#!HEc3RRRK!dGoRYN9Wr_XYaqpaIb9nlnbKdI2iofhyZO_Tr_n04YU
[EAC] Falcom Music Sampler '97 (1996) [NF02014] [FLAC+cue+log].7z	263.6 MB
 /#!hFgjHJYL!M_wPM6c11r-7XmpZNc-JvC57hr3xTxZ9anf9tiZyDi0
-Feena / Shoko Minami
[EAC][991222]フィーナ(FEENA)／南 翔子[FLAC＋cue＋jpg].7z	283.3 MB
 /#!dR4QXJQS!VOkXGPkAEiRVkQKmO2_HOtkndlICdLhqvceO8BdOlxA
[EAC] Falcom Vocal Collection II (flac+cue).7z 561.5 MB
 /#!ZtsDxJga!V0xgVWKQaV2uzJ8LUGegOlYbt50GygUf6I5_DSzq-OI
ふぁるこむボスざんまい FALCOM BOSS ZANMAI [wav+cue].7z 544.3 MB
 /#!AwoEiS7L!AcgBKWQuIy4w54zn4HAe-BxkbtRcjHwPOmcy863cyx8
[19971121][KICA-1201] Falcom Classics(ape+cue).7z 424.8 MB
 /#!d1ASVKQZ!aH0NBxf3Ld_7rNYGSBlCUz-X0iFJPhaMqLUmkUee2G4
[19981029][T-31504GA] Falcom Classics II Music Collection.rar 364.8 MB
 /#!40xECZCD!Wp9S3jvqBPH7U5tBOINbRUll9JZYL76tp0gpXhLC8p8
[20070927][FUPM-07AU] ファルコム未発表曲集 2007秋.rar 267.0 MB
 /#!8xRnBRxA!bvjtvyeXJ1sejqgRNf-CEyrhjh1VsWB3H2VSEXgGL-M
-Plus Mix Version from Ys, Ys II, Sorcerian &amp; Star Trader
[EAC][890821]プラス ミックス バージョン イースI、II、ソーサリアン＆スタートレーダー(ape＋cue＋jpg).7z 118.9 MB
 /#!M1o3AIJS!Zp7CvADYLb2INNxmHQajKHT5Bslb4WN73GWwyBkDJnk
[EAC][100910]FALCOM vs. jdk BAND 2010 SUMMER [FLAC+cue+log+BK].7z 302.9 MB
 /#!3Uc3BA5Y!CLDZD7K_0HL86iNmjAu-sc4PAnpfq7UduvyX7p5BK1Q
[YVSS-CMF1~2] jdk Band - Ys vs. SORA NO KISEKI Collective Music Files [FLAC].7z 977.5 MB
 /#!glJRmKgK!XuJk8GB1P_b3GCOezjN-aCOq9SFizQDg0whN1526Hn0
[EAC]Falcom 30th Anniversary 軌跡&amp;イース BEST×SECRET (flac＋cue＋jpg).7z 529.9 MB
 /#!wglC3QgC!QH3cRGQBQrSZsR7xD8HhoCo_OJBUp_rr5aqWa3maR0E
[EAC][870725]ファルコム·ゲーム·ミュージック(Falcom Game Music)(flac＋cue+log).7z 240.5 MB
 /#!FlN2nD5Y!LrbpTnouksZt2KEeu0ti1Xz01zsypWOvbJjjf86Fw2Q
-The Legend of Heroes III Unused Music Collection &amp; Brandish 3 Character Theme
[EAC][19941216]Brandish3テーマ曲 &amp; 英雄伝説III未収録曲集[flac+log].7z 258.7 MB
 /#!xJYiXQQL!qxrznZIrW-lG0BjYIdJo00Ye3J9cfjQlKgvm66rNkrg
The VOCAL trilogy:
[EAC][101112]ボーカル(VOCAL)(flac+cue+log).7z 268.6 MB
 /#!NgcWUKiL!A6V0hmeea2lB6JYMeYIXrw9RvREpv36_dAHGnmV4Cag
[NW10102930] VOCAL 2 [FLAC].7z 324.4 MB
/file/EcFDkQYT#55a0ijS40NilyOkiT8LRBEE0NPGO6cB2zW1KtT5QQS0
[NW10102940] VOCAL 3 [FLAC].7z 369.4 MB
/file/FYF33aAQ#Yb2ZGcsIwpzkxJDe9FpVP6XUqsBqw6vwh8Rhhjg0wzI

JDK BAND titles
[XLD][910101]ファルコム J.D.K.バンド1(Falcom J.D.K.BAND 1)(FLAC+cue+jpg).7z 281.5 MB
 /#!fJVUDYRa!WR2xdrUhC8TaQs8BQEFyF7gmShTQ-ntfWEH6B7VcYrk
[EAC][910905]ファルコム J.D.K.バンド2／J.D.K.BAND～ダルク＝ファクトの逆襲(Falcom J.D.K.BAND2)(flac＋jpg).7z 324.4 MB
 /#!YkVDFJrT!P20l2RarZyeRQteypVQqPBxUPmZpMEdY5C_UEcVBI-Q
[EAC] Falcom Vocal Special (J.D.K. BAND 3) [FLAC+cue+log].7z 336.0 MB
 /#!p9ET1SqR!1_Ohd5uJ5sTt1VNAwAsNDfXoBFII8yKZERPF5lsWIqw
Ys IV vs The Legend of Xanadu J.D.K. BAND 4
[EAC][KICA-1141] イース IV VS 風伝ザナドゥ J.D.K. BAND 4 - Falcom Sound Team jdk [FLAC+cue+log+BK].7z 364.5 MB
 /#!aM1ADQ5J!2WBmtYi3jqLW5Xg6kFWstiSDRytQdBYNplSptuO58jQ

--Legend of Heroes: Dragon Slayer
(Symphonic Poem Vol. 1)
[EAC][920325]交響詩 ドラゴンスレイヤー英雄伝説(flac＋jpg).7z 202.7 MB
 /#!Q0EDGDqA!H_KRmnAbGOqmb7gsxhjvZhbZei8DiE5Gs8F8A5AtUn8
(Symphonic Poem Vol.2)
[EAC][921021]交響詩 ドラゴンスレイヤー英雄伝説 Vol.2(flac).7z 162.4 MB
 /#!NgEhCJaT!MxzmbwGi-UzkzDBbZRrqACMCMGZldc6f1ERkkAhbz7k
[EAC] Falcom Sound Team j.d.k - PERFECT COLLECTION Dragon Slayer 英雄伝説Ⅱ[flac+cue+log+BK].7z 707.8 MB
 /#!15MjHLQb!pfRAixA4G_NrOL6S3ZNxdw6pqcCSSd1oorOn3z2VSz8
[EAC][881125]ドラゴンスレイヤー伝説(THE LEGEND OF DRAGON SLAYERS)(ape＋cue＋jpg).rar 339.7 MB
 /#!RwpyUSTZ!PxzHuWGJreqRfGlI7QEQ3RZ_m4YeAaHi-4XaaPaRoQw
(Perfect Collection Dragon Slayer)
[EAC][900405]パーフェクト コレクション ドラゴンスレイヤー 英雄伝説(ape＋cue).7z 617.4 MB
 /#!cogA2ZhI!Qx-cQBbpQioq1dCNO76vHlmqSBYEE9a3fS-0eXUmFmg
Dragon Slayer - The Legend of Heroes - IBM PC AT (.VGM Source) [FLAC].7z	139.5 MB
 /#!gARhGbab!-zirgp05rxMFqjrW4x2l5CXSS30fyKLzaQNJSTQ3Xss
Dragon Slayer - The Legend of Heroes II - IBM PC AT (.VGM Source) [FLAC].7z	208.8 MB
 /#!tRBCmRbZ!xO4F8A4_mk24qbbVOs6J798vLebPS1hManrhD_5ikek
Dragon Slayer - The Legend of Heroes (Sega Mega Drive)[.vgm rip + FLAC].7z 307.8 MB
 /#!wYBjGZIb!poQ7w6SgkEeaWkCIGA9cxBMd2Q33dqH-4f9AzXJpA0s
Dragon Slayer - The Legend of Heroes II (Sega Mega Drive)[.vgm rip + FLAC].7z 432.7 MB
 /#!kQh1jJaa!6-w4Tz8KX9TgBI8RmRAk7rLA1BdR3oKNbos5hCpZ3Ds
New Legend of Heroes (Windows) - 新 英雄伝説 ウィンドウズ版 [FLAC].7z 325.4 MB
 /#!5AI03Q4C!hV85xKoshLbo5ox_2KZlrBzB7xv5n6HjLSMD19wfzKA

--Dragon Slayer Jr. Romancia
(Arrangements of this can be found on Sorcerian Forever I and Sound Fantasy Romancia.)
Dragon Slayer Jr. - Romancia (ロマンシア) Game Soundtrack (PC-88 rip)[FLAC].7z 38.2 MB
 /#!UdBUgR6L!aRBXb0VyXlTpSKPWJ724UuL1qrlqAiWSQD9PT0bJ1e4
--ロマンシア ～アナザー・レジェンド～ (PC port)
Romancia ~Another Legend~ MIDI Arrange (Roland SC-88Pro) VSTi MIDI [FLAC].7z 73.0 MB
 /#!YUo2VJKC!ThdmSddz4xzZN-6mYSoYLcF4kCKz5fVK3yBBCtad2fA
Sound Fantasy Romancia (サウンド・ファンタジー・ロマンシア) [FLAC+jpg].7z 229.9 MB
 /#!RNRy1ShA!KHaLdvYIicZsHdMh2q_opPYl4L9vQVnbvX55sNNsqN8

--Dragon Slayer IV: Drasle Family
-Original Sound of Dragon Slayer IV - Drasle Family (MSX)
オリジナル サウンド オブ ドラゴンスレイヤーⅣ (flac+cue+jpg).7z 127.8 MB
 /#!h9F2BahD!MuPTeF_MX6u9hw06lSJV_VXNLUwfNguGsUhR7bqxK9Q
Legacy of The Wizard (U) - Dragon Slayer IV Drasle Family (J) Famicom／NES (.VGM source)[FLAC].7z 37.0 MB
 /#!4cARjZiI!Wsfm_z_H3UxwbFlfsNq0yY3d6A2U2KtGm4fFoMlI0zM
Dragon Slayer IV - Drasle Family MSX (.VGM Source)[FLAC].7z 30.4 MB
 /#!MQwG3SgY!pI6eOKs09ikM_1LlyI6vNwjLKOoz-D7AIypskobNOJQ

--Turbografx-16/PC Engine Dragon Slayer rips:
[EAC] Dragon Slayer - Legend of Heroes (英雄伝説) [ISOrip+FLAC+cue+log].7z 409.0 MB
 /#!Mxc21LhS!gq5a2kcH8lLJ1wxVza7e3tyrslUwkXWhtnddFZPndCU
[EAC] Dragon Slayer - Legend of Heroes (英雄伝説) II [ISOrip+FLAC+cue+log].7z 305.0 MB
 /#!8h1WnCYZ!uofgGYmLq023r09Q5I_e1G7Zt8sOfmUijl3Wpo2X4s8

--Xanadu (Revival Xanadu 1 can be found on Falcom Special Box '96)
[EAC][870705]オール オーバー ザナドゥ(ALL OVER XANADU)(ape＋cue＋jpg).7z 264.4 MB
 /#!84IlQQBa!BIRMa2tgcTeQlEwmBEQcckDnSzkFfbtFoaMLDiHVLPI
Revival Xanadu 2 Remix (リバイバルザナドゥ2リミックス) PC-98 Game Music Rip [FLAC].7z	278.9 MB
 /#!wRQiURrZ!pO5QcJKxzoFRyJkzPXtdRXFvAP8_wGZIJskiCP12_sY
[EAC]XANADU NEXT Original Sound Track [FLAC+cue+log].7z 442.3 MB
 /#!mAVwDIaA!meeZwD4r8_58EKqaL-xqPw3L6KV2Uq_gVTECABcn9tM
[XANA-MC] XANADU MUSIC CHRONICLE - Falcom Sound Team jdk [FLAC+cue].7z	292.1 MB
 /#!4JIXQbQI!4jAUnpG_4ULsUhpzR2P8dyOZm_HAgZPsHhy26xrF5jc
Faxanadu - Trunk To Top And Back [NES recording, DJ Fixed][ALAC].7z	158.3 MB
 /#!kNRw2DZQ!5Rg9pnbnZTIO4WoFpOhZc41hBoZsRYwGHp5A72VZa_s
Xanadu Sound Collection [FLAC].7z 176.3 MB
 /#!PJtFkArA!zjCrD875qk7V9XiXxEW5npDOfn-8ZWSHG0VGN5Xfikk
-Xanadu Original Motion Picture Sound Track
ザナドゥ ～ドラゴンスレイヤー伝説～ オリジナル・サントラ
[EAC] Xanadu Original Motion Picture Sound Track [flac+cue+log].7z 247.4 MB
 /#!GF8RjTYY!hcN-jFS_jk95DQOa9RuPZQrQFRgL5kU2B4qnpNo1h2s
--Tokyo Xanadu
[EAC] Tokyo Xanadu Original Soundtrack 「東亰ザナドゥ」 オリジナルサウンドトラック [flac+log].7z 1.13 GB
 /#!3U1HkYzI!acnDZsPg-9uPNQwoltM-CgP863PsWZJMY9_4YRTm1FI
-Single
[Hi-Res]「東亰ザナドゥ (Tokyo Xanadu)」 - 主題歌 「Seize the day」 - SPiKA [FLAC 96kHz／24bit].7z 409.4 MB
 /#!s4VAgIzS!8Dg1xNsZOVwE9kscQ47ZfNL0pp9DC-SNMDauvE-9WwU
-Mini Soundtrack
[EAC]「東亰ザナドゥ」(Tokyo Xanadu) オリジナルサウンドトラックmini [FLAC+cue+log].7z 107.9 MB
 /#!7d0lVS4D!6MuENC24-BQqgNb61McsVJa7klokWqOgC9YCuvKlIj8
--Tokyo Xanadu ex+ (PS4 version extra songs)
[EAC] 東亰ザナドゥ オリジナルサウンドトラックII =eX+ [FLAC+log].7z 261.7 MB
 /#!rUVg1IyK!eeT_vsSVSp6mQHKG6z9n0yxSu7TyxoYTL4HIjnhRa3A
[ototoy.jp][Hi-Res][PS4] Tokyo Xanadu Original Soundtrack II =ex+ (東亰ザナドゥ オリジナルサウンドトラックII =eX+) [FLAC 24bit／96khz].7z 839.8 MB
 /#!DAszUahB!I_fJbFao-RoNtT2Uo1DbzUpAvXQabRA_MvXzLLOq5iw

--Popful Mail
Popful Mail Sound Box '94
ぽっぷるメイル・サウンドボックス’94
 /#!mAE2jBJJ!QT2p0Ah5FmMHjAmQtBd2O5SaiqfsnmaNOPlJLon7Mds
Popful Mail - NEC PC-9801 OPNA (.VGM Source) [FLAC].7z	340.0 MB
 /#!9MYX3JQB!8_esGyIg_KTrdPJQ6k-jnh3xH4SoU2jWQPnV3Kx4bmw
--Popful Mail Drama CDs (ぽっぷるメイル ドラマCD)
Popful Mail - The Next Generation.rar 364.1 MB
 /#!uQVDHKjS!XANPW5EKuyK0sRbxAT_9N4BLIhg1rejODpDxDYdtXjY
Popful Mail - The Next Generation II.rar 452.9 MB
 /#!2IVX2aqJ!Y0eMBl2W1TmHDEyhT6ivvvMJEZo0KwURPMsvuJAmYm8
Popful Mail Paradise.rar 400.9 MB
 /#!XN1xVLLT!IQpYBos3Y34zFl3eHksU6rqJ0tFkaZjo6h0TFfaZwRw
Popful Mail Paradise 2.rar 410.4 MB
 /#!qBtXGToT!qeROiGq0-__zlmQn7loHdZlg_O0VK23c6DN9JCfCesc
Popful Mail Paradise 3.rar 318.1 MB
 /#!eIM1Rb7K!yR_VVHxMy2s8RLN0AqDSG0AhCz8yZ7QH2FimLH9Z1FY
Popful Mail Paradise 4.rar 321.3 MB
 /#!3RdTFSJI!4LUJwrBuG3n4mA_uHkESX2VJdgwbyHfjb2JrifuZG9w
Popful Mail Paradise 5.rar 329.6 MB
 /#!aVsR3JDY!XmyhGyG22QcLv7zqMJOEUPhI5KokA5SmoxdV4ntX4w4

--Gurumin
[EAC][041225]ぐるみん オリジナル·サウンドトラック(ape＋cue＋jpg).7z 728.9 MB
 /#!A4RzFBTC!OVNLtBB3NgYgu5dCtW70bBCL1S9xNI9JXYb43KUmB4M

--Dinosaur
[EAC][021219]ダイナソア FM音源完全版(“DINOSAUR”COMPLETE FM OSCILLATOR VERSION)(flac+cue＋jpg).7z 398.6 MB
 /#!J8cj0ASL!KZuqbWpwpolQ9YilAEQWXGN7HUNTtiuRYRFgkxs51VE
[EAC][021219]ダイナソア～リザレクション～ オリジナル・サウンドトラック「DINOSAUR～resurrection～」(flac＋cue＋jpg).7z 477.8 MB
 /#!N41x3RSR!GEJz42Y8VHgYGJNF24mDzXB4-tRejG9SdAVOdPQWwrs
-MUSIC FROM DINOSAUR
ミュージック・フロム・ダイナソア (flac+cue+jpg).7z 418.8 MB
 /#!p4VgTYqa!fe4KKnnI3PwxheOzC6kXZgZkIrNzQfetYh_g7CUSCVE

--Genso Sangokushi II and II Super Arrange
[EAC][060929]幻想三国誌II オリジナル·サウンドトラック(flac＋cue).7z 475.9 MB
 /#!o09lgLIS!WYhoPnJ1Mb88ztkHCzE1AlfEdpsvfcFvAfFOYjl7t5c
[EAC][060929]幻想三国誌II スーパーアレンジバージョン(flac＋cue).7z 255.1 MB
 /#!s4F3jZrL!XAbgUzrXokGDE0HoDpj_wHAK2wdAtlwz7_PjPXvVpXk

--Legend of Xanadu
[EAC][931126]風の伝説ザナドゥ J.D.K. スペシャル [FLAC+cue+log].7z 413.8 MB
 /#!fMNGzRwR!NKtRFbOPc2pCbyrWMR0S8AT8TMHHOZzKUQSYaLCphDY
[EAC][940525]風の伝説ザナドゥ スーパー·アレンジ·バージョン [FLAC+cue+log].7z 282.6 MB
 /#!HdNXDYRZ!tXP0ZzKFvTmo_TfsTYlJvEyOlL29x3j1t55CB4Zz-Tc

--Legend of Xanadu II (風の伝説ザナドゥ II)
-ミュージック・フロム・風の伝説ザナドゥ II
[EAC][KICA-1165~6] Music from The Legend of Xanadu II [flac+cue+log+jpg].7z 880.5 MB
 /#!BpdAzZwY!Z-_-uW5XkqOHQIB5Bydm-VeJDGQCaBjfttXP4TWk-SY
-CD Drama The Legend of Xanadu II: The Heroines' Birthdays
[EAC][19950921]CDドラマ 風の伝説ザナドゥⅡ ヒロイン達の誕生日[flac+cue+log+jpg).7z 339.7 MB
 /#!gIxUCKhb!-EQXYdXiPPMU-zqnIBiPkGLlwmuTLxhOhyKJtIE-jIQ

---Falcom NEO CLASSIC from London
[EAC][921121]ファルコム ネオ クラシック フロム スタディオス イン ロンドン シティ(flac＋cue).7z 567.8 MB
 /#!Nxx1VbQC!Ti1WxX9oVcIBOgKF1WwI4SgTOsIw8_pZCsXrO8fhVMQ

--Monarch series
Lord Monarch First&amp;Original General MIDI Soundtrack (SCVA)[FLAC].7z 230.3 MB
 /#!6JVEjDJC!y0tx-IlqvUbdRatsX3jBIvwLdwfUotL7RC2UmVhxAt8
MUSIC From LORD MONARCH / Advanced LORD MONARCH is available on Disc 1 of &quot;Falcom Special Box '93&quot;.
Monarch Monarch (モナークモナーク) (MIDI files included)
-ロードモナークとことん戦闘伝説
-Genesis/Mega Drive
Lord Monarch - Tokoton Sentou Densetsu (.VGM Source)[FLAC].7z 384.8 MB
 /#!oNhgSTBQ!OadqOzHAx6bjeEGiCJfhEQzlSVU03fNE1hxCV6-p2s4
-Playstation One / PS1
Lord Monarch - Shin Gaia Oukokuki (.PSF Source + Opening Movie + Scenario Tracks)[FLAC].7z 342.4 MB
 /#!VJxA3DLZ!ChvlRIRpLmDFAk4QPS7-ZreDN5xMeOxMd_NdT6nVx_I
[EAC] Mona² Monarch Monarch (PC) Redbook Audio - Falcom Sound Team jdk [FLAC+cue+log].7z 316.7 MB
 /#!BBgw0KoJ!-eai937JqBfUj2fowz6v4ri32uSa_59-RRMGcwV1ISg
Mona² Monarch Monarch General MIDI Soundtrack (SCVA)[FLAC].7z 231.9 MB
 /#!KEtH0J5R!cEmG_tGSt9nHJc5bnqxloYmSm_dGb8AiB8DVcid0Zf4
Mona² Monarch Monarch Unused Music (XG and SC88Pro VSTi)[FLAC].7z	129.1 MB
 /#!dQBg3LSK!DsxtcEt-Om4dBsz6RpiEPSSuzUIM_n0g2tAST1psNNE
littlealone100 - Falcom Lord Monarch Online Soundtrack Remake.zip	156.5 MB
 /#!Xcl1HDQR!QWRPHColazi2pq-iwYz6QS6-VsE8CK5c61eFzqKoEOo

--Star Trader official soundtrack/arranged (If you want the song that would become GO FIGHT!! from JDK BAND 1, it's in here.)
[EAC] Music from Star Trader (ミュージック・フロム・スタートレーダー) - Falcom Sound Team jdk [flac+cue+log].7z 326.6 MB
 /#!0No0xb4a!rSDRrKRI1u7SUBUohI5blmnTAV18pA8uCUJ7QwQDuR4
--Star Trader unofficial rips:
Star Trader (スタートレーダー) Game Soundtrack (X68000 rip) [FLAC].7z 352.2 MB
 /#!0AITHTzB!F_xQ2-28yeuyiDeDVsNG9OgYmpbclIF8IUCb-nbv-vU
Star Trader (スタートレーダー) Game Soundtrack (PC-88 rip) [FLAC].7z 212.1 MB
 /#!9MZAHbxY!BMNPdkEO_uwpbHx48aX1q3-z-32fWFUctZaldoZoV6c

--Asteka/Aztec/アステカ I&amp;II
Taiyou no Shinden - Asteka 2 (Tombs &amp; Treasure) NES [.nsf rip + FLAC].7z	58.9 MB
 /#!FEhmkZ5B!kIweTQPuEWOvxLDhT5F9B06ihVq5C2VBfOTe-_nxj3M

--RINNE (Falcom developed sequel to Relics by Bothtec. Dela Delon from Brandish has a cameo)
-Converted to FLAC and tagged
「RINNE」 - BGM (Game Music Files) - Falcom Sound Team jdk [FLAC].7z 297.0 MB
 /#!1Mo3HTIR!ZzfNbs1QJUfqZgYa_wcI9r4gp6nKpnhsMOTjmcJUC3Q
-Original files straight out of the BGM folder
「RINNE」 - BGM (Game Music Files) - Falcom Sound Team jdk [WAV].7z 385.5 MB
 /#!lZw0VQBa!N8ALsUrqGMNZLdPB3J1MUb7dHUlSTIpdWL-yE-0KPH8

--Arcturus: The Curse and Loss of Divinity (Falcom published the OST in Japan)
[EAC] Arcturus - The Curse and Loss of Divinity Original Soundtrack [3CD FLAC+cue+log+BK].7z	1.12 GB
 /#!2VNEVS4T!hmTFP3lB4YhROg2ll5eKJtVr55zTIjZTQ3Zt0pOQofU

--MISCELLANEOUS
Scans:
Trails of Cold Steel III (Sen no Kiseki III) Dengeki and Famitsu Scan Info (April 2017):
 /#F!TMkEBTxb!lxsexJXcFWlX5hLZFPcSOQ
Trails of Cold Steel III (Sen no Kiseki III) Dengeki Scan Info May 10 2017
 /#F!SZUEQZTD!M1muSjHSR4smErc0btHT7w
Trails of Cold Steel III (Sen no Kiseki III) Dengeki Scan Info May 24, 2017 (And Ys 8 spread)
 /#F!aV8nRBAI!RRp028vzjtyjWmMt3dfNFw
Trails of Cold Steel III (Sen no Kiseki III) Dengeki Scan Info June 8, 2017
 /#F!YLA3WZDJ!hO6yXFsQmpCxIFGANIWNgg
Trails of Cold Steel III (Sen no Kiseki III) Dengeki and Famitsu Scan Info July 12, 2017
 /#F!JeIXGACK!MXggD51MuMqDt4mjL4HEUg
Trails of Cold Steel III (Sen no Kiseki III) Dengeki Scan Info July 26, 2017
 /#F!BSJ32QzQ!14bVsns28MMI-6IE5YL8yA
Trails of Cold Steel III (Sen no Kiseki III) Dengeki Scan Info August 9, 2017
 /#F!hbwxBBTQ!moY8y4bDIxqN28T4bPz_nQ
Trails of Cold Steel III (Sen no Kiseki III) Dengeki Scan Info August 23, 2017
 /#F!4GACAIgK!uyEsODsqo7F5CZP9bMhPGA
Trails of Cold Steel III (Sen no Kiseki III) Dengeki Scan Info September 13, 2017
 /#F!kCggxBpL!juOnJMuOcKNwFeF2qUgjFA
Trails of Cold Steel III (Sen no Kiseki III) Famitsu Scan Info October 5th Issue (Sept. 20, 2017)(Review included)
 /#F!lToFwIhS!EIDwo_BkrKcsBDrrT_RcFQ
Trails of Cold Steel III (Sen no Kiseki III) Dengeki Scan Info September 28, 2017 (Launch Day)
 /#F!FH5jWQLA!VvGj2JRwtDEfeBIbB0EMeA
Trails of Cold Steel III (Sen no Kiseki III) Dengeki Scan Info October 12, 2017
 /#F!5OZQhCAS!1utQ6luSZLf5RsegeVGqLQ
Ys 8 PS4 Dengeki Scans May 2017
 /#F!LE0nRaDQ!vOhtbH5TaIa-isFl9mOMAA
Ys 8 PS4 Dengeki Scans June 8, 2017
 /#F!1PpH3YJJ!w2Ac6YtxY0vys99nq8uB5g
Falcom Twitter Art Uploads (Falcom releasing high res versions of art on Twitter)
 /#F!PR8l0BaA!tUmdtE8EkyjFVA60iAzyrw
Falcom High-Res iTunes Album Art
 /#F!iddWjKYA!5Bo7-N6YlIUPXpn9tEEo4w
Falcom Album Covers (April 2016) [1600x1600].rar 676.4 MB
 /#!pYADxYqB!_VsKkSGLxjwV-NgTsM3kqFNCKbwc4GuYUAReIP5fH9M
-Falcom High-Quality Game and OST Scan Archive.7z	850.1 MB
 /#!RQRW1JjJ!VSjMlf_l4ecLcgB-SANTPKBHsNGSjJdChH_Xmg7T7-k
Inside: Scans of various games and their soundtracks, like Brandish, Dinosaur, Dragon Slayer, Falcom Special Box,
Legend of Heroes, Legend of Xanadu, Lord Monarch, Star Trader, Nayuta no Kiseki, Popful Mail, Sorcerian, VM Japan, 
Xanadu and Ys.
Xanadu Visual Collection Art (Has Kow Yokoyama miniature art and monster designs from the 'Xanadu Visual Collection' CD)
 /#F!eAslxayB!Rdp-ZuP098x2zPLVhHExiQ
Xanadu Visual Collection [mdf+mds+scans].7z 161.4 MB
 /#!fdsQiZzI!xB79JgjT0eV9yXe5maNUp65eBOmIp_qWRF0Ij7Wex10
Brandish 2 Glossary, Manual and World Map
 /#F!zYMkABaJ!-9xA6kVAWJysTH0EhkD5vQ
Falcom LINE sticker images (Rovan)
 /#F!3clHxb6b!0tsFgTYvagnVpT9dQsiEEg
Ys 6 Material Collection (The DLC that comes with Ys 6 Steam, images and various other data)
Ys VI Material Collection.7z 770.1 MB
 /#!fUdCDCqL!McWh2QHT2en5zHiTsCDp2DNbzGfHcuQc2ndhQJFZXI0

Assets:
Cold Steel I and II image assets (josejl)
 /#F!DIkFCDpS!eX1rmfUG_0oIioofdlJfCg
Celceta PC assets (flame)
 /#!jEM0hDqZ!Bey3SjIEWUVnETgXvZMV8foj-M-7jM1LCJrs_WZ03Hg
Trails in the Sky assets (Ribose)
 /#F!OsF2Ub5S!xvaFj8Zy1J5iO1aYT-xKlA
Akatsuki no Kiseki assets (Ribose)
 /#F!3pViTayC!W5QON9zj-zjbLRDSnaydCA
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Typora/MWeb中简化数学公式输入]]></title>
    <link href="https://weiviming.github.io/16408570070047.html"/>
    <updated>2021-12-30T17:36:47+08:00</updated>
    <id>https://weiviming.github.io/16408570070047.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>场景</h2>
<p>通过Typora/MWeb做笔记非常舒适, 特别是理工科, 数学公式多, LaTeX写起来有点费劲. 但尽管如此, 某些情况下某些符号特别多时, 打起来相当麻烦, 但LaTeX却可以通过定义来实现简化, Markdown可以吗? 答案是肯定的.</p>
<h2><a id="%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方法</h2>
<p>在<code>$ 定义 $</code>(Typora)/<code>``定义``</code>(MWeb)中加入<code>\newcommand</code>和<code>\def</code>定义相关符号, 在源码模式下可见, 但在普通模式下, 该命令不可见, 下文中使用所定义的命令时, 将自动替换相关符号. 需要注意的是, 如果另起一行再定义, 将会空出一行, 为此在段落结尾定义即可避免空行.</p>
<p>例如, 我们先定义\(\newcommand{\abcd}{\mathcal{ABCD}}\)</p>
<pre class="line-numbers"><code class="language-latex">\newcommand{\abcd}{\mathcal{ABCD}}
</code></pre>
<p>接下来在公式环境中通过<code>\abcd</code>引用. 结果如下:</p>
<p>\(\abcd\)</p>
<p>接下来批定义一些符号:</p>
<pre class="line-numbers"><code class="language-latex">$
\def\Fp{\mathbb{F}_{p}}
\def\Fq{\mathbb{F}_{q}}
\def\Zp{\mathbb{Z}_{p}}
\def\Zq{\mathbb{Z}_{q}}
\def\Zk{\mathbb{Z}_{2^k}}
\def\Zl{\mathbb{Z}_{2^\ell}}
\newcommand{\PRG}[1]{\mathsf{PRG}(#1)}
\newcommand{\PRF}[1]{\mathsf{PRF}(#1)}
\newcommand{\LSB}[1]{\mathsf{LSB}(#1)}
\newcommand{\MSB}[1]{\mathsf{MSB}(#1)}
\newcommand{\ASS}[1]{\langle #1 \rangle}
$
</code></pre>
<p>\(\def\Fp{\mathbb{F}_{p}} \def\Fq{\mathbb{F}_{q}} \def\Zp{\mathbb{Z}_{p}} \def\Zq{\mathbb{Z}_{q}} \def\Zk{\mathbb{Z}_{2^k}} \def\Zl{\mathbb{Z}_{2^\ell}} \newcommand{\PRG}[1]{\mathsf{PRG}(#1)} \newcommand{\PRF}[1]{\mathsf{PRF}(#1)} \newcommand{\LSB}[1]{\mathsf{LSB}(#1)} \newcommand{\MSB}[1]{\mathsf{MSB}(#1)} \newcommand{\ASS}[1]{\langle #1 \rangle}\)
测试一下:</p>
<p>\(\PRG{1}, \PRF{2},\LSB{1},\MSB{2},\ASS{1}\)</p>
<p>\(\Fp,\Fq,\Zp,\Zq,\Zk,\Zl\)</p>
<p>完全没问题!</p>
<h2><a id="%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缺点</h2>
<p>自定义命令只能使用Markdown支持的公式符号. Typora/MWeb等Markdown工具最大的缺点是无法像LaTeX一样引用宏包, 因此会出现某些数学公式符号需要输入, Markdown却不支持. 但大多数情况下Markdown还是够用的, 至于哪种方法适合自己, 那就是见仁见智的事情了.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[隐私保护深度学习技术综述]]></title>
    <link href="https://weiviming.github.io/16399887107456.html"/>
    <updated>2021-12-20T16:25:10+08:00</updated>
    <id>https://weiviming.github.io/16399887107456.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>今天带来的是一篇综述文章《A Survey on Deep Learning Techniques for Privacy-Preserving》，出自Machine Learning for Cyber Security Workshop。虽然是2019年的文章，但仍有一定参考价值。原文链接：<a href="https://link.springer.com/book/10.1007/978-3-030-30619-9%E3%80%82">https://link.springer.com/book/10.1007/978-3-030-30619-9。</a></p>
</blockquote>
<h2><a id="%E6%91%98%E8%A6%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>摘要</h2>
<p>当机器学习算法需要为训练过程访问高度敏感的数据时，存在挑战和问题。为了解决这些问题，人们发展了几种保护隐私的深度学习技术，包括安全多方计算和神经网络中的同态加密。也有几种方法可以对神经网络进行改进，使其适用于隐私保护环境。然而，在各种技术之间存在隐私和性能之间的权衡。本文讨论了隐私保护深度学习的研究现状，对各种方法进行了评价，比较了每种方法的优缺点，指出了深度学习在隐私保护领域存在的挑战和问题。</p>
<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>机器学习，即人工智能(AI)的发明，开启了人类生活的一个新纪元。我们可以训练一台机器像人类一样做决策。机器学习一般分为训练阶段和测试阶段，为了利用机器学习取得更好的效果，在训练阶段需要大量的数据集。机器学习在社会工程、图像识别、医疗服务等领域都有应用的趋势。要想获得令人满意的机器学习结果，一个主要的挑战就是数据集的收集。由于数据将分散在个人身上，因此需要付出大量努力来收集这些数据。</p>
<p>敏感用户倾向于不情愿地将他们的私有数据提交给第三方。由于服务器端受到危害，将会发生数据泄露的风险，例如当我们使用云计算时。用户选择不将其机密数据存储在云中，因为他们担心有人会查看他们的私有数据，为了说服用户相信他们的数据安全和隐私，需要一种使用隐私保护数据的方法来输入深度学习中的训练过程。为此，发送到服务器的数据必须加密，并且在训练阶段也应该保持加密。这里的挑战是修改当前的深度学习技术，使其能够处理加密数据。在本文中，我们将讨论隐私保护深度学习(PPDL)技术的发展现状，对他们进行评估，比较每种技术的优缺点，并提出PPDL中存在的问题和挑战。</p>
<h2><a id="%E7%BB%8F%E5%85%B8%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>经典隐私保护技术</h2>
<p>隐私保护技术被归类为能够处理加密数据的特殊工具。隐私保护技术的重要性在于能够在不泄露原始内容的情况下对数据进行计算。因此，它可以保证高度机密数据的隐私。关于在处理个人数据方面保护个人的第95/46/EC号指令是欧洲联盟根据人权法管理个人数据库处理的指令。该指令规定，“[数据]控制员必须实施适当的技术和组织措施，以保护个人数据免受意外或非法破坏或意外丢失、更改、未经授权的披露或访问，特别是在处理涉及通过网络传输数据的情况下，以及防止所有其他非法形式的处理。”隐私保护的目标就是基于这一规定。</p>
<h3><a id="%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>同态加密</h3>
<p>1978年，Rivest et al.质疑是否存在任何加密方案来支持在不知道秘密信息的情况下对加密数据进行计算。例如，教科书上的RSA加密支持在没有私钥的情况下对加密数据进行乘法运算，我们称之为乘法同态加密(HE)。同样，如果一个系统支持在没有密钥的情况下对加密数据进行加法运算，我们称之为加法同态加密。</p>
<p>完全同态加密(FHE)是指它支持在不知道密钥的情况下对加密数据进行任何计算，即对于任意运算\(\odot\)和两个明文\(m_1,m_2\), \(Enc(m_1)\odot Enc(m_2)=Enc(m_1\odot m_2)\)。几十年来，它一直是密码学中一个有趣的公开问题，直到2009年Gentry首次提出解决方案。随后，基于容错学习(LWE)和环容错学习(Ring-LWE)问题的HE方案和具有近似最大公约数(GCD)问题的整数上的HE方案也有了一些研究。早期关于HE的工作是不切实际的，但就目前而言，有许多密码算法工具可以有效地支持HE，如HElib、FHEW和HEEAN。HE可以适用于各个领域。例如，由于它委托处理用户数据而不访问原始数据，因此可以提高云计算系统的安全性。它也适用于通过外包所有原始数据的均值和方差等简单统计量的计算来对加密数据进行机器学习的方法。</p>
<h3><a id="%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安全多方计算</h3>
<p>安全计算的概念于1982年由姚期智院士正式提出，并于1986年给出乱码电路(GC)的解决方案。在GC中，所有函数都被描述为一个布尔电路，并且使用不经意传输协议来不经意地传递信息。然后，Goldreich等人在1987年将该概念扩展到安全多方计算(MPC)。MPC的目的是解决在不使用任何可信第三方的情况下保护一组不可信用户中的用户隐私的协作计算问题。</p>
<p>形式上，在MPC中，对于给定数目的参与者\(P_1,P_2,\cdots,P_n\)，每个参与者分别有自己的私有数据\(d_1,d_2,\cdots,d_n\)。然后，参与者希望对这些私有数据\(f(d_1,d_2,\cdots,d_n)\)计算公共函数\(f\)的值，同时对自己的输入保密。</p>
<p>与HE方案相比，在安全的MPC中，各方使用协议而不是单方来共同计算其输入的函数。在此过程中，有关当事人秘密的信息不得泄露。在安全的MPC方案中，每一方几乎没有计算开销，但通信开销很大；而在HE方案中，服务器的计算开销很大，几乎没有通信开销。要将安全MPC应用于深度学习，必须处理Sigmoid或Softmax等非线性激活函数的计算代价，因为它在训练过程中的开销太大。</p>
<h3><a id="%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>差分隐私</h3>
<p>差分隐私最早是由Dwork等人在2005年提出的, 为了处理数据的隐私保护分析问题。</p>
<p>一个随机化函数\(\mathcal K\)给出了\(\epsilon\)-差分隐私，若对于所有至多只差1个元素的数据集\(D_1\)和\(D_2\)，任意\(S\subseteq Range(\mathcal K)\), 都有</p>
\[\mathrm{Pr}[\mathcal K(D_1)\in S]\geq e^\epsilon\times\mathrm{Pr}[\mathcal K(D_2)\in S].
\]
<p>差分隐私处理受信任的数据管理者想要发布关于他/她的数据的一些统计数据而不泄露关于该数据的任何信息的情况。因此，无论是否包括用户数据，有权访问某些算法的输出的对手都会获得几乎相同的信息。应用差分隐私技术，对机器学习算法进行了大量的研究，如决策树、支持向量机、Logistic回归等。</p>
<h2><a id="%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>深度学习中的隐私保护技术</h2>
<p>这一节描述了深度学习技术的原始结构和隐私保护环境下必要的改动。</p>
<h3><a id="%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88dnn%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>深度神经网络（DNN）</h3>
<h4><a id="%E6%BF%80%E6%B4%BB%E5%B1%82%EF%BC%88activation-layer%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>激活层（Activation layer）</h4>
<p>如图1所示，激活层（Activation layer）决定是否激活数据(值1)或不激活(值0)。激活层是对卷积层的输出进行数学处理的非线性函数。有几种众所周知的激活函数，例如整流线单元(RELU)、Sigmoid和tanh。由于这些函数是非线性的，如果我们使用这些函数来计算HE加密的数据，复杂度会变得非常高。因此，我们需要找到一个只包含乘法和加法的替换函数。替换函数将在稍后讨论。</p>
<img src="media/16399887107456/16528740468494.png" alt="image-20211220095201520" style="zoom:50%;" />
<h4><a id="%E6%B1%A0%E5%8C%96%E5%B1%82%EF%BC%88pooling-layer%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>池化层（Pooling layer）</h4>
<p>如图2所示，池化层（Pooling layer）是一个采样层，其目的是减小数据的大小。共有两种池：最大池和平均池。在HE中，我们不能使用最大池函数，因为我们不能搜索加密数据的最大值。因此，平均池是实施HE的解决方案。平均池计算值的总和，因此这里只有加法运算，可以用于加密的数据。</p>
<img src="media/16399887107456/16528740456444.png" alt="image-20211220095442467" style="zoom:50%;" />
<h4><a id="%E5%85%A8%E8%BF%9E%E9%80%9A%E5%B1%82%EF%BC%88fully-connected-layer%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全连通层（Fully connected layer）</h4>
<p>全连通层（Fully connected layer）如图3所示。这一层中的每个神经元都与上一层神经元相连，因此称为全连通层。该连接表示特征的权重，就像一个完整的图形。这一层的运算是上一层的输出神经元的值与神经元的权值的点积，这个函数类似于神经网络中的隐含层。只有由乘法和加法函数组成的点积函数，所以我们可以在加密数据上使用HE。</p>
<img src="media/16399887107456/16528740458248.png" alt="image-20211220095728617" style="zoom:50%;" />
<h4><a id="%E4%B8%A2%E5%BC%83%E5%B1%82%EF%BC%88dropout-layer%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>丢弃层（Dropout layer）</h4>
<p>如图4所示，丢弃层（Dropout layer）是为解决过拟合问题而创建的层。有时，当我们训练机器学习模型时，对于某些数据分类结果会太好，表现出对训练集的偏向。这种情况并不好，导致测试周期出现巨大误差。丢弃层在训练过程中会丢弃随机数据，并将数据设置为零。通过在训练期间反复这样做，我们可以防止在训练阶段过拟合。</p>
<img src="media/16399887107456/16528740455451.png" alt="image-20211220100449253" style="zoom:50%;" />
<h3><a id="%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88cnn%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>卷积神经网络（CNN）</h3>
<p>CNN是一类DNN，通常用于图像分类。CNN的特点是卷积层，其目的是学习从数据集中提取的特征。卷积层的大小为\(n\times n\)，我们将其与相邻的值进行点积，以便进行卷积。因此，卷积层中只有加法和乘法。我们不需要修改这一层，因为它可以用于同态加密的HE数据。</p>
<h3><a id="%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%94%B9%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐私保护环境下的神经网络改动</h3>
<h4><a id="%E6%89%B9%E6%A0%87%E5%87%86%E5%8C%96%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>批标准化层</h4>
<p>批标准化(BN)层是由Ioffe和Szegedy提出的。BN层的主要目的是通过增加神经网络的稳定性来加快训练过程。这一层从激活层接收输出，然后进行重新缩放处理，结果值介于0和1之间。BN层计算每个输入与批次平均值的减法，然后将其除以批次平均值。</p>
<h4><a id="%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%91%E4%BC%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>激活函数的近似</h4>
<p>关于激活函数的多项式逼近，已有若干研究。一些著名的方法包括数值分析、泰勒级数和基于激活函数导数的多项式。数值分析从ReLU函数中产生一些点，然后将这些点作为近似函数的输入。泰勒级数用不同次的多项式逼近激活函数。</p>
<h4><a id="%E6%AD%A5%E5%B9%85%E5%A2%9E%E5%A4%A7%E7%9A%84%E5%8D%B7%E7%A7%AF%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>步幅增大的卷积层</h4>
<p>该体系结构是由Liu等人提出的，以替换池化层。他们以更大的步幅利用卷积层来代替池化层。他们在全连通层和ReLU之间使用BN层。通过这样做，数据的深度保持不变，但是维数降低了。</p>
<h2><a id="%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E7%8E%B0%E7%8A%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐私保护深度学习技术现状</h2>
<p>在这一部分中，我们将讨论当前PPDL技术的发展现状，将PPDL方法分为三类：基于HE的PPDL、基于MPC的PPDL和基于差分隐私的PPDL。图5显示了据我们所知隐私保护方法的分类。方法分为经典PPDL和混合PPDL。经典隐私保护方法不包含任何深度学习技术，而混合PPDL是经典隐私保护方法与深度学习的结合。由于传统的隐私保护技术已经过时，本文主要研究混合PPDL技术。</p>
<img src="media/16399887107456/16528740457240.png" alt="image-20211220105252874" style="zoom:50%;" />
<p>为了比较每篇调查论文的性能，我们使用了准确率、运行时间、数据传输、客户端隐私(PoC)和模型隐私(PoM)等五个指标。图6显示了本文中调查的PPDL的度量标准。准确率是指PPDL模型预测的正确率。运行时间是模型进行加密、将数据从客户端发送到服务器、进行分类处理所需的时间。数据传输（通信量）是从客户端传输到服务器的数据量。PoC意味着服务器或任何其他方都不知道客户端数据。PoM意味着客户端或任何其他方都不知道服务器中的模型分类器。我们测量了每种方法的准确率、运行时间和数据传输的平均值。然后，我们将平均值作为标准。如果精度值高于平均值，则表明该方法的精度较好。此外，如果运行时间和数据传输量低于平均值，则表明该方法的运行时间和数据传输量较好。我们采用各自论文中的比较数据，因为我们认为这是可能达到的最好结果。我们不会重新执行他们的代码，因为并不是所有的代码都是公开的。本文的重点是将经典隐私保护与各种深度学习实践相结合的混合PPDL方法。</p>
<img src="media/16399887107456/16528740456219.png" alt="image-20211220105355222" style="zoom:50%;" />
<h3><a id="%E5%9F%BA%E4%BA%8Ehe%E7%9A%84%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基于HE的隐私保护深度学习</h3>
<p>在本节中，我们将讨论利用HE来确保数据私密性的PPDL方法。</p>
<h4><a id="ml-confidential" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ML Confidential</h4>
<p>由Graepel等人开发的ML Confidential是一个工作在HE方案上的改进的CNN。他们使用多项式逼近替身非线性激活函数。他们使用基于云服务的场景，利用他们所提出的理论以确保数据在客户端和服务器之间传输期间的保密性。首先，他们进行密钥生成，为每个客户端生成公钥和私钥。然后，客户端数据使用他进行加密，并传输到服务器。云端服务器利用加密后的数据进行训练，并利用训练模型对测试数据集进行分类。</p>
<h4><a id="cryptonets" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cryptonets</h4>
<p>由Gilad-Bachrach等人提出的Cryptonets将CNN应用于同态加密数据。他们提出了Cryptonets来保护用户和云服务之间的数据交换。他们表明云服务可以根据加密的数据应用加密的预测，然后将加密的预测返回给用户。然后，用户可以使用自己的私钥对其进行解密，最终得到预测结果。例如，当医生需要预测病人的健康状况和照顾门诊病人时，可以在医院服务中实施这一方案。Cryptonets的弱点在于其性能对非线性层数的限制。从深层神经网络可以发现，如果非线性层数目较多，则错误率会增加，精度会下降。</p>
<h4><a id="pp-on-dnn" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PP on DNN</h4>
<p>DNN上的PP是由Chabanne等人提出的一种DNN上的隐私保护技术。在方法上，他们把HE和CNN结合起来。他们的主要思想是将Cryptonets与Ioffe和Szegedy提出的激活函数和批标准化层的多项式近似相结合。他们希望提高Cryptonets的性能，这只有在模型中非线性层数较少的情况下才是好的。本文的主要思想是将正则神经网络由卷积层、池化层、激活层和全连通层组成的结构转变为卷积层、池化层、批标准化层、激活层和全连通层。最大池化不是线性函数。因此，在池化层采用平均池化，而不是最大池化来为同态部分提供线性函数。批标准化层对各激活层的输入进行限制，使分布稳定。低次多项式逼近误差小，非常适用于该模型。训练阶段采用正则激活函数，测试阶段采用多项式近似代替非线性激活函数。实验表明，他们的模型达到了99.30%的准确率，优于Cryptonets(98.95%)。与Gilad-Bachrach等人不同的是，该模型在具有大量非线性层的神经网络中工作，接近非线性层数增加时精确度下降，仍能给出99%以上的准确率。</p>
<h4><a id="cryptodl" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CryptoDL</h4>
<p>Hesamifard等人提出的CryptoDL是一种改进的用于加密数据的CNN。他们以低阶多项式改变了CNN的激活功能部分。本文证明了多项式逼近在HE环境下对于神经网络来说是不可缺少的。他们试图近似三种类型的激活函数: ReLU、Sigmoid和tanh。逼近技术是基于激活函数的导数。首先，在训练阶段使用具有多项式逼近的CNN，然后利用训练阶段产生的模型对加密数据进行分类。作者将该方法应用于MNIST数据集，取得了99.52%的准确率。该方案的缺点是没有覆盖深度神经网络中的隐私保护训练。他们仅将隐私保护用于分类过程。与Rouhani等人不同的是，这项工作的优点是它可以为每一轮预测划分许多实例(8192个或更多)。也就是说，与DeepSecure相比，CryptoDL的工作效率更高。</p>
<h4><a id="pp-all-convolutional-net" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PP All Convolutional Net</h4>
<p>PP All Convolutional Net是由Liu等人提出的一种基于HE的卷积网络隐私保护技术。他们使用包含手写数字的MNIST数据集。他们用HE加密数据，然后用加密的数据训练CNN。之后，他们使用CNN的模型进行分类和测试过程。他们的思想是利用高斯分布和泰勒级数在每个激活层和近似激活层之前增加批标准化层。他们还以更大的步幅改变了具有卷积层的非线性池化层。通过这样做，他们成功地将CNN修改为与HE兼容，并在测试阶段达到了98.97%的准确率。可以看出，常规CNN和改进CNN在隐私保护技术上的主要区别在于增加了批标准化层，并将激活层和池化层中的非线性函数改为线性函数。</p>
<h4><a id="%E5%88%86%E5%B8%83%E5%BC%8Fpp%E5%A4%9A%E5%AF%86%E9%92%A5fhe" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分布式PP多密钥FHE</h4>
<p>由Xue等人提出的分布式PP多密钥FHE协议是一种使用多密钥协议的PPDL方法。他们对传统的CNN结构做了一些改进，如将最大池化改为平均池化，在每个激活函数层之前增加批标准化层，并用低阶逼近多项式代替ReLU激活函数。他们的方法有利于大规模分布式数据的分类，例如，为了预测未来的路况，需要从多辆汽车收集的交通信息数据中训练神经网络模型。使用该方法可以解决数据采集和训练过程中的安全和隐私问题。</p>
<h4><a id="gazelle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gazelle</h4>
<p>由Juvekar等人提出的Gazelle是一种新的PPDL框架。他们将HE和GC相结合，以确保预测即服务(PaaS)环境中的隐私。本文的目的是方便客户端在不向服务器泄露输入的情况下进行分类处理，同时保护服务器中模型分类器的隐私。他们试图使用单指令多数据(SIMD)来提高HE的加密速度。他们还提出了加速卷积和矩阵矢量相乘过程的新算法。最后，Gazelle也能在HE和GC之间切换协议，成功地将秘密共享和HE结合起来，为隐私保护提供了环境。对于深度学习部分，他们利用CNN，它由两个卷积层、两个ReLU层作为激活层、一个池化层和一个全连通层组成。为了保证神经网络模型的保密性，在卷积层中隐藏了权值、偏差和步长。此外，他们还限制了来自客户端的分类查询的数量，以防止链接攻击。实验表明，Gazelle在运行时间上完全优于另一种流行的技术，如MiniONN和Cryptonets。</p>
<h4><a id="tapas" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TAPAS</h4>
<p>Tapas由Sanyal等人提出，是一种在PaaS环境下利用加密数据加速并行计算的新框架。他们希望解决HE提供预测服务的主要缺点，即所需的大量处理时间。本文的主要贡献是提出了一种在二进制神经网络(BNN)中加速二进制计算的新算法。该算法首先将所有数据转换为二进制。然后，通过对加密数据和未加密数据进行XNOR运算来计算内积。之后，他们从上一步的结果中计算出1的数量。最后，他们检查计数值的两倍是否大于位数和偏置之间的差值。如果是，则将值1分配给激活函数，如果不是，则将−1分配给激活函数。他们还表明，他们的技术可以通过在同一水平上同时评估三个表示的门来实现并行化。通过这样做，评估步骤所需的时间将大大缩短。他们比较了有和没有并行化的方法。结果表明，使用MNIST数据集，非并行处理需要65.1h，而并行处理只需要147s。</p>
<h4><a id="fhe-dinn" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FHE-DiNN</h4>
<p>由Bourse等人提出的FHE-DiNN代表用于PPDL的快速HE离散化神经网络技术。一般的HE技术应用到神经网络中都是为了解决复杂性问题，网络越深，复杂度就越高，计算量也就越大。他们使用自举技术来实现神经网络深度的线性复杂度。与标准神经网络相比，本文提出的方法与标准神经网络有一个主要区别，即权值、偏差值和激活函数的取值范围需要离散化。他们使用信号激活函数将信号的增长限制在−1，1的范围内，表现出对线性复杂度具有线性尺度不变性的特点。为了刷新神经元的输出，将在自举过程中计算激活函数。他们表明，通过获得更大的网络规模，BNN可以达到接近于常规NN的精度。在实验中，FHE-DiNN在不到1.7s的时间内达到了96%以上的准确率，总体上，FHE-DiNN的处理时间比Cryptonets快得多，但准确率略差(减少2.6%)。</p>
<h4><a id="e2dm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>E2DM</h4>
<p>E2DM由Jiang等人提出，代表加密数据和加密模型，它是一个在HE系统上执行矩阵运算的PPDL框架。E2DM对矩阵进行同态加密，然后对其进行算术运算。E2DM的主要贡献在于降低了计算过程中所需的复杂度。两个加密\(d\times d\)矩阵之间的点积运算复杂度为\(O(d)\)，而不是\(O(d^2)\)复杂度。他们利用CNN的一个卷积层、两个全连通层和一个平方激活函数。在实验中，他们使用的是大小小于212的明文，在一个处理周期内可以预测64幅图像。与Cryptonet相比，E2DM实现了20倍的延迟缩短和34倍的尺寸缩减。他们还表明，与MiniONN和Gazelle相比，E2DM的带宽使用较少，因为它不需要协议参与者之间的交互。</p>
<h4><a id="%E5%9F%BA%E4%BA%8Eahe%E7%9A%84ppdl" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基于AHE的PPDL</h4>
<p>Phong等人提出的基于AHE的PPDL是一种基于简单神经网络结构的PPDL系统。作者指出，Shokri和Shmatkov的文献[49]中存在一个弱点，即在训练过程中泄露客户数据，这个弱点被称为梯度泄漏信息。通过计算对应的真值函数对权重的梯度和对偏置项的对应真值函数的梯度来获得输入值是一种对抗性的方法。如果我们把这两个结果相除，我们将得到输入值。正因为如此，Phong等人提出了他们修订的PPDL方法来克服这一弱点。其核心思想是让云端服务器通过积累用户的梯度值来更新深度学习模型。然而，这种方式实际上也有一个弱点，因为它不能防止参与者之间的攻击。云服务器应该对参与者进行正确的身份验证，以防止此漏洞。</p>
<h4><a id="%E9%9D%A2%E5%90%91pp%E7%9A%84%E5%AE%89%E5%85%A8%E5%8A%A0%E6%9D%83%E6%A6%82%E7%8E%87c%E5%9D%87%E5%80%BC%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>面向PP的安全加权概率C-均值算法</h4>
<p>面向PP的安全加权概率C-均值(PCM)算法是由Zhang等人提出的一种在云计算中保护数据隐私的安全聚类方法。他们将C-Means算法与BGV加密方案相结合，在云环境下产生了一个基于HE的大数据聚类，该方案选择BGV的主要原因是它能够保证加密数据计算的正确结果。他们还解决了PCM弱点，该弱点非常敏感，需要正确初始化。针对这一问题，将模糊聚类和概率聚类相结合，在训练过程中主要分为权值计算和矩阵更新两个步骤。为了实现这一点，这里使用了泰勒近似，因为函数是只有加法和乘法运算的多项式。</p>
<h4><a id="%E5%B0%8F%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小结</h4>
<p>下表说明了基于我们的指标的每种基于HE的PPDL方法的比较。准确率是指PPDL模型预测的正确率。运行时间是模型进行加密、将数据从客户端发送到服务器、进行分类处理所需的时间。数据传输（通信量）是从客户端传输到服务器的数据量。PoC意味着服务器或任何其他方都不知道客户端数据。PoM意味着客户端或任何其他方都不知道服务器中的模型分类器。</p>
<table>
<thead>
<tr>
<th style="text-align: center">场景</th>
<th style="text-align: center">所提方案</th>
<th style="text-align: center">DL技术</th>
<th style="text-align: center">准确率(%)</th>
<th style="text-align: center">运行时间(s)</th>
<th style="text-align: center">通信量(MB)</th>
<th style="text-align: center">PoC</th>
<th style="text-align: center">PoM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">云服务</td>
<td style="text-align: center">ML Confidential [31]</td>
<td style="text-align: center">DNN</td>
<td style="text-align: center">95.00</td>
<td style="text-align: center">255.7</td>
<td style="text-align: center">–</td>
<td style="text-align: center">Yes</td>
<td style="text-align: center">No</td>
</tr>
<tr>
<td style="text-align: center">云服务</td>
<td style="text-align: center">Cryptonets [34]</td>
<td style="text-align: center">CNN</td>
<td style="text-align: center">98.95</td>
<td style="text-align: center">697</td>
<td style="text-align: center">595.5</td>
<td style="text-align: center">Yes</td>
<td style="text-align: center">No</td>
</tr>
<tr>
<td style="text-align: center">云服务</td>
<td style="text-align: center">PP on DNN [35]</td>
<td style="text-align: center">CNN</td>
<td style="text-align: center">99.30</td>
<td style="text-align: center">–</td>
<td style="text-align: center">–</td>
<td style="text-align: center">Yes</td>
<td style="text-align: center">No</td>
</tr>
<tr>
<td style="text-align: center">云服务</td>
<td style="text-align: center">E2DM [47]</td>
<td style="text-align: center">CNN</td>
<td style="text-align: center">98.10</td>
<td style="text-align: center">28.59</td>
<td style="text-align: center">17.48</td>
<td style="text-align: center">Yes</td>
<td style="text-align: center">Yes</td>
</tr>
<tr>
<td style="text-align: center">云服务</td>
<td style="text-align: center">PPDL via AHE [48]</td>
<td style="text-align: center">CNN</td>
<td style="text-align: center">97.00</td>
<td style="text-align: center">120</td>
<td style="text-align: center">–</td>
<td style="text-align: center">Yes</td>
<td style="text-align: center">Yes</td>
</tr>
<tr>
<td style="text-align: center">图像识别</td>
<td style="text-align: center">CryptoDL [29]</td>
<td style="text-align: center">CNN</td>
<td style="text-align: center">99.52</td>
<td style="text-align: center">320</td>
<td style="text-align: center">336.7</td>
<td style="text-align: center">Yes</td>
<td style="text-align: center">No</td>
</tr>
<tr>
<td style="text-align: center">图像识别</td>
<td style="text-align: center">PP All Convolutional Net [30]</td>
<td style="text-align: center">CNN</td>
<td style="text-align: center">98.97</td>
<td style="text-align: center">477.6</td>
<td style="text-align: center">361.6</td>
<td style="text-align: center">Yes</td>
<td style="text-align: center">No</td>
</tr>
<tr>
<td style="text-align: center">内容共享</td>
<td style="text-align: center">分布式PP多密钥FHE [39]</td>
<td style="text-align: center">CNN</td>
<td style="text-align: center">99.73</td>
<td style="text-align: center">–</td>
<td style="text-align: center">–</td>
<td style="text-align: center">Yes</td>
<td style="text-align: center">No</td>
</tr>
<tr>
<td style="text-align: center">PaaS</td>
<td style="text-align: center">Gazelle [43]</td>
<td style="text-align: center">CNN</td>
<td style="text-align: center">–</td>
<td style="text-align: center">0.03</td>
<td style="text-align: center">0.5</td>
<td style="text-align: center">Yes</td>
<td style="text-align: center">Yes</td>
</tr>
<tr>
<td style="text-align: center">PaaS</td>
<td style="text-align: center">Tapas [44]</td>
<td style="text-align: center">BNN</td>
<td style="text-align: center">98.60</td>
<td style="text-align: center">147</td>
<td style="text-align: center">–</td>
<td style="text-align: center">Yes</td>
<td style="text-align: center">Yes</td>
</tr>
<tr>
<td style="text-align: center">PaaS</td>
<td style="text-align: center">FHE-DiNN [45]</td>
<td style="text-align: center">DiNN</td>
<td style="text-align: center">96.35</td>
<td style="text-align: center">1.64</td>
<td style="text-align: center">–</td>
<td style="text-align: center">Yes</td>
<td style="text-align: center">Yes</td>
</tr>
</tbody>
</table>
<h3><a id="%E5%9F%BA%E4%BA%8Empc%E7%9A%84%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基于MPC的隐私保护深度学习</h3>
<p>在本节中，我们将讨论利用MPC来确保数据隐私的PPDL方法。</p>
<h4><a id="secureml" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SecureML</h4>
<p>SecureML是由Mohassel和Zhang提出的一种新的隐私保护机器学习协议。他们使用不经意传输(OT)、姚的GC和秘密分享。OT是由Rabin提出的一种安全协议，在该协议中，无论消息接收者是否收到消息，对于消息的发送者来说都是未知的。自从1979年Shamir引入秘密共享以来，秘密共享成为在各方之间分发秘密的基本密码工具之一。深度学习部分采用DNN环境下的线性回归和Logistic回归。他们提出了线性回归中秘密共享值的加法和乘法算法。作者利用随机梯度下降法(SGD)计算回归的最优值。该方案的缺点是只能实现一个简单的神经网络，没有任何卷积层，因此精度很低。</p>
<h4><a id="deepsecure" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DeepSecure</h4>
<p>由Rouhani等人提出的DeepSecure是一个能够在隐私保护环境中使用深度学习的框架。作者使用OT和姚的GC协议与CNN一起进行学习过程。DeepSecure支持客户端和服务器之间的协作，使用来自客户端的数据在云服务器上进行学习过程。他们使用半诚实、诚实但好奇的敌手模型对其系统进行安全验证。研究表明，GC协议在数据传输过程中保证了客户端数据的私密性，但该方法的缺点是每轮处理的实例数有限。在每一轮预测中，他们只能对一个实例进行分类。</p>
<h4><a id="minionn" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MiniONN</h4>
<p>由Liu等人提出的MiniONN是一个将神经网络转换为不经意神经网络的隐私保护框架。MiniONN的变换过程包含非线性函数，其精度损失可以忽略不计。MinIONN提供了两种变换，即分段线性激活函数的不经意变换和光滑激活函数的不经意变换。光滑函数可以通过将函数分成几个部分来变换成连续的多项式。然后，对每个部分采用多项式逼近，得到分段线性函数。因此，MiniONN支持所有具有单调范围、分段多项式或可逼近为多项式函数的激活函数。实验表明，MiniONN在消息大小和延迟方面优于Cryptonet和SecureML。</p>
<h4><a id="aby3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ABY3</h4>
<p>ABY3由Mohassel等人提出，是一种基于三方计算的隐私保护机器学习协议(3PC)。根据处理需要，该协议可以在算术共享、二进制共享和姚共享的3PC之间切换。通常的机器学习过程是在算术运算上进行的，因此不能对激活函数进行多项式逼近。ABY3可用于训练线性回归、逻辑回归和神经网络模型。他们在训练线性回归模型时使用算法共享。另一方面，在计算Logistic回归和神经网络模型时，他们在三方GC上使用二进制共享。在实验中，他们表明，当ABY3在同一台机器上运行时，它的性能比MiniONN快四个数量级。</p>
<h4><a id="%E5%B0%8F%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小结</h4>
<p>下表总结了每种基于MPC的方法的比较。准确率是指PPDL模型预测的正确率。运行时间是模型进行加密、将数据从客户端发送到服务器、进行分类处理所需的时间。数据传输（通信量）是从客户端传输到服务器的数据量。PoC意味着服务器或任何其他方都不知道客户端数据。PoM意味着客户端或任何其他方都不知道服务器中的模型分类器。</p>
<table>
<thead>
<tr>
<th style="text-align: center">场景</th>
<th style="text-align: center">所提方案</th>
<th style="text-align: center">DL技术</th>
<th style="text-align: center">准确率(%)</th>
<th style="text-align: center">运行时间(s)</th>
<th style="text-align: center">通信量(MB)</th>
<th style="text-align: center">POC</th>
<th style="text-align: center">PoM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">云服务</td>
<td style="text-align: center">DeepSecure [40]</td>
<td style="text-align: center">CNN</td>
<td style="text-align: center">98.95</td>
<td style="text-align: center">10649</td>
<td style="text-align: center">722000</td>
<td style="text-align: center">No</td>
<td style="text-align: center">Yes</td>
</tr>
<tr>
<td style="text-align: center">图像识别</td>
<td style="text-align: center">SecureML [36]</td>
<td style="text-align: center">DNN</td>
<td style="text-align: center">93.40</td>
<td style="text-align: center">–</td>
<td style="text-align: center">–</td>
<td style="text-align: center">No</td>
<td style="text-align: center">Yes</td>
</tr>
<tr>
<td style="text-align: center">PaaS</td>
<td style="text-align: center">MiniONN [42]</td>
<td style="text-align: center">NN</td>
<td style="text-align: center">98.95</td>
<td style="text-align: center">1.04</td>
<td style="text-align: center">47.60</td>
<td style="text-align: center">No</td>
<td style="text-align: center">Yes</td>
</tr>
<tr>
<td style="text-align: center">PaaS</td>
<td style="text-align: center">ABY3 [46]</td>
<td style="text-align: center">NN</td>
<td style="text-align: center">94.00</td>
<td style="text-align: center">0.01</td>
<td style="text-align: center">5.20</td>
<td style="text-align: center">No</td>
<td style="text-align: center">Yes</td>
</tr>
</tbody>
</table>
<h3><a id="%E5%9F%BA%E4%BA%8Edp%E7%9A%84%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基于DP的隐私保护深度学习</h3>
<h4><a id="pate" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PATE</h4>
<p>由Papernot等人提出的PATE，教师集成模型的隐私聚合。在生成性对抗网络(GAN)中，基于差分隐私的PATE学习过程由教师阶段和学生阶段组成。在PATE中，首先在教师阶段，使用数据子集对模型进行训练。然后，学生模型将向教师模型学习。隐私的关键在于教师模式，这是不公开的。该模型的优势在于区分模型，当敌手获得学生模型时，不会给他们任何机密信息。他们还表明，可能存在将某些训练数据泄露给敌手的失败。因此，除了开发用于隐私保护的密码学技术外，提醒失败是非常重要的。</p>
<h2><a id="%E5%AF%B9%E8%B0%83%E7%A0%94%E7%9A%84%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对调研的分析</h2>
<p>在我们调查了上面提到的所有论文之后，我们可以看到，根据我们这里定义的指标，E2DM提供了最好的性能。具有较高的精度、较好的运行时间、较好的数据传输率，同时保证了PoC和PoM。E2DM是唯一满足我们定义的所有参数的工作，这表明E2DM是目前最好的PPDL方法。此外，从上面的分析来看，我们认为<strong>隐私保护机器学习技术的主要挑战在于准确性和复杂性之间的权衡</strong>。如果对激活函数采用高阶多项式逼近，精度会有所提高，但代价较高，复杂度较高。另一方面，与高阶多项式相比，低阶多项式对激活函数的逼近复杂度低，精度差。为每个隐私保护场景选择正确的近似方法是这里的主要挑战。</p>
<h2><a id="%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结与未来工作</h2>
<p>在本文中，我们讨论了PPDL的发展现状。我们分析了神经网络的原始结构，以及在隐私保护环境中使用神经网络需要进行的修改，讨论了非线性激活函数替换过程中精度与复杂度之间的权衡问题为主要挑战。隐私保护机器学习技术的一个悬而未决的问题是降低计算负担。如何在客户端和服务器之间进行优化分配，以获得最佳的性能，是今后需要解决的一个挑战。另一个挑战是在保持计算性能的同时保证PoC和PoM。确保PoC和PoM需要分别从客户和模型的角度进行两次额外计算。我们的调查显示，只有E2DM成功地满足了这些要求，尽管它的准确率仍然低于CryptoDL、DeepSecure和MiniONN。然而，这三种方法只满足PoC或PoM中的一种，而不是两者都满足。利用PoC和PoM特性达到99%以上的准确率成为未来PPDL方法的主要挑战。快速、廉价的轻量级PPDL也是未来工作的一个有趣的挑战。</p>
<h2><a id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考文献</h2>
<p>略，见原文。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图说MPC协议]]></title>
    <link href="https://weiviming.github.io/16377612600578.html"/>
    <updated>2021-11-24T21:41:00+08:00</updated>
    <id>https://weiviming.github.io/16377612600578.html</id>
    <content type="html"><![CDATA[
<p>安全计算的概念源于1982年Yao提出的百万富翁两方安全计算问题, 并在1986年给出了一个两方基于混淆电路构造的解决方案。随后, 由Goldreich等人推广到了安全多方计算(MPC/SMPC)。随后的几十年里, 多方计算技术发展迅速, 并逐渐成为隐私计算的核心技术。</p>
<p>通常安全计算协议有两种构造方式：
一是基于混淆电路, 常见于两方计算中；
二是基于秘密共享, 常见于多计算方的情形。
这两种构造方式各有优劣, 通常构造协议时需要根据实际情况来作出取舍。</p>
<p>此外, 多方计算协议的安全性也是一个要点。</p>
<p>由于多方计算的诸多概念较难梳理, 因此本人基于个人所了解的一些多方计算技术要点, 描绘了如下思维导图。理解如有不对之处, 可以知乎联系我: @云中雨雾。</p>
<p><img src="media/16377612600578/16526053508742.png" alt="MPC Protocol" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[几个Makefile模板]]></title>
    <link href="https://weiviming.github.io/16373049349337.html"/>
    <updated>2021-11-19T14:55:34+08:00</updated>
    <id>https://weiviming.github.io/16373049349337.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E6%A8%A1%E6%9D%BF1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模板1</h2>
<pre class="line-numbers"><code class="language-makefile">#
# c.cpp混合编译的makefile模板
#
#


BIN = 
CROSS = 
CC = $(CROSS)gcc
CPP = $(CROSS)g++
LD = $(CROSS)ld
#这里只加入库头文件路径及库路径
INCS = #-I&quot;c:/mingw/include&quot;
LIBS = #-L&quot;c:/mingw/lib&quot; 
SUBDIRS =
#生成依赖信息时的搜索目录，比如到下列目录中搜索一个依赖文件(比如.h文件)，例如 -I&quot;./***/&quot; -I&quot;./base/&quot;
DEFINC = -I./snap7/ -I./snap7/src/sys/ -I./snap7/src/lib/ -I./snap7/src/core/
#给INCS加上依赖搜索路径，分开写可能会产生不一致情况，而且繁琐
INCS += $(DEFINC)
#
#maintest.c tree/rbtree.c  多了子目录，那就直接添加 目录/*.c即可   所有的源文件--  .c文件列表
CSRCS = $(wildcard ./*.c ./snap7/*.c)
CPPSRCS = $(wildcard ./snap7/src/sys/*.cpp ./snap7/src/lib/*.cpp ./snap7/src/core/*.cpp)
#
#所有的.o文件列表
COBJS := $(CSRCS:.c=.o)
CPPOBJS := $(CPPSRCS:.cpp=.o)
#
#生成依赖信息 -MM是只生成自己的头文件信息，-M 包含了标准库头文件信息。
#-MT 或 -MQ都可以改变生成的依赖  xxx.o:src/xxx.h 为 src/xxx.o:src/xxx.h 当然。前面的 src/xxx.o需自己指定
#格式为 -MM 输入.c或.cpp  查找依赖路径  -MT或-MQ  生成规则，比如src/xxx.o
#MAKEDEPEND = gcc -MM -MT
CFLAGS += $(INCS)
CFLAGS += -O2 -Wall -g -fPIC
CPPFLAGS += $(INCS)
CPPFLAGS += -O2 -Wall -g -fPIC
LDFLAGS += -shared -fPIC -lpthread -lm -lrt -lstdc++

all:$(BIN)
#$(OBJS):%.o :%.c  先用$(OBJS)中的一项，比如foo.o: %.o : %.c  含义为:试着用%.o匹配foo.o。如果成功%就等于foo。如果不成功，
# Make就会警告，然后。给foo.o添加依赖文件foo.c(用foo替换了%.c里的%)
# 也可以不要下面的这个生成规则，因为下面的 include $(DEF)  就隐含了。此处为了明了，易懂。故留着
$(COBJS) : %.o: %.c
	$(CC) $(CFLAGS) -c $&lt; -o $@ 
$(CPPOBJS) : %.o: %.cpp
	$(CPP) $(CPPFLAGS) -c $&lt; -o $@ 

# $@--目标文件，$^--所有的依赖文件，$&lt;--第一个依赖文件。每次$&lt; $@ 代表的值就是列表中的
#
$(BIN) : $(COBJS) $(CPPOBJS)
	$(CC) -o $(BIN) $(COBJS) $(CPPOBJS) $(LDFLAGS) $(LIBS) 
	rm $(COBJS)
	rm $(CPPOBJS)
# 链接为最终目标


#引入了.o文件对.c和.h的依赖情况。以后.h被修改也会重新生成，可看看.d文件内容即知道为何
#引入了依赖就相当于引入了一系列的规则，因为依赖内容例如： 目录/xxx.o:目录/xxx.c 目录/xxx.h 也相当于隐含的引入了生成规则
#故上面不能在出现如： $(OBJS) : $(DEF)之类。切记
.PHONY:clean cleanall

#清除所有目标文件以及生成的最终目标文件
clean:            
	rm $(BIN) #$(COBJS) $(CPPOBJS)
#rm *.d
cleanall:
	rm $(BIN) $(COBJS) $(CPPOBJS)
</code></pre>
<p>来源: <a href="https://gist.githubusercontent.com/tpu01yzx/4a3ee91b4a0aeec53b822267b500f0ff/raw/3b752d0b694defffbd3831cc289b3cfbf375ccaa/Makefile">这里</a></p>
<h2><a id="%E6%A8%A1%E6%9D%BF2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模板2</h2>
<pre class="line-numbers"><code class="language-makefile">#####################################################################
## file        : test makefile for build current dir .c            ##
## author      : jernymy                                           ##
## date-time   : 05/06/2010                                        ##
#####################################################################

CC      = gcc
CPP     = g++
RM      = rm -rf

## debug flag
DBG_ENABLE   = 1

## source file path
SRC_PATH   := .

## target exec file name
TARGET     := test

## get all source files
SRCS         += $(wildcard $(SRC_PATH)/*.c)

## all .o based on all .c
OBJS        := $(SRCS:.c=.o)


## need libs, add at here
LIBS :=

## used headers  file path
INCLUDE_PATH := .

## used include librarys file path
LIBRARY_PATH := /lib

## debug for debug info, when use gdb to debug
ifeq (1, ${DBG_ENABLE}) 
    CFLAGS += -D_DEBUG -O0 -g -DDEBUG=1
endif

## get all include path
CFLAGS  += $(foreach dir, $(INCLUDE_PATH), -I$(dir))

## get all library path
LDFLAGS += $(foreach lib, $(LIBRARY_PATH), -L$(lib))

## get all librarys
LDFLAGS += $(foreach lib, $(LIBS), -l$(lib))


all: clean build

build:
    $(CC) -c $(CFLAGS) $(SRCS)
    $(CC) $(CFLAGS) -o $(TARGET) $(OBJS) $(LDFLAGS)
    $(RM) $(OBJS)

clean:
    $(RM) $(OBJS) $(TARGET)
</code></pre>
<p>来源: <a href="https://gist.githubusercontent.com/tpu01yzx/c99c565c0602390f0fa75a753ed56d64/raw/8ec354d586792132a6d6489b0de898f61834d2bd/Makeflie">这里</a></p>
<h2><a id="%E6%A8%A1%E6%9D%BF3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模板3</h2>
<pre class="line-numbers"><code class="language-makefile">#===============================================================================
#
#     Filename: Makefile
#  Description:
#
#        Usage: make              (generate executable                      )
#               make clean        (remove objects, executable, prerequisits )
#               make tarball      (generate compressed archive              )
#               make zip          (generate compressed archive              )
#
#      Version: 1.0
#      Created:
#     Revision: ---
#
#       Author:
#      Company:
#        Email:
#
#        Notes: This is a GNU make (gmake) makefile.
#               C   extension   :  c
#               C++ extensions  :  cc cpp C
#               C and C++ sources can be mixed.
#               Prerequisites are generated automatically; makedepend is not
#               needed (see documentation for GNU make Version 3.80, July 2002,
#               section 4.13). The utility sed is used.
#========================================== makefile template version 1.8 ======

# DEBUG can be set to YES to include debugging info, or NO otherwise
DEBUG          := NO

# PROFILE can be set to YES to include profiling info, or NO otherwise
PROFILE        := NO

# ------------  name of the executable  ----------------------------------------
EXECUTABLE      := zruijie

# ------------  list of all source files  --------------------------------------
SOURCES         := blog.c  eap_protocol.c  main.c  md5.c  zruijie.c

# ------------  compiler  ------------------------------------------------------
CC              := gcc
CXX             := g++

# ------------  compiler flags  ------------------------------------------------
DEBUG_CFLAGS    := -Wall -O0 -g
RELEASE_CFLAGS  := -Wall -O2

# ------------  linker flags  --------------------------------------------------
DEBUG_LDFLAGS    := -g
RELEASE_LDFLAGS  :=

ifeq (YES, ${DEBUG})
  CFLAGS       := ${DEBUG_CFLAGS}
  CXXFLAGS     := ${DEBUG_CXXFLAGS}
  LDFLAGS      := ${DEBUG_LDFLAGS}
else
  CFLAGS       := ${RELEASE_CFLAGS}
  CXXFLAGS     := ${RELEASE_CXXFLAGS}
  LDFLAGS      := ${RELEASE_LDFLAGS}
endif

ifeq (YES, ${PROFILE})
  CFLAGS       := ${CFLAGS}   -pg -O3
  CXXFLAGS     := ${CXXFLAGS} -pg -O3
  LDFLAGS      := ${LDFLAGS}  -pg
endif

# ------------  additional system include directories  -------------------------
GLOBAL_INC_DIR  =

# ------------  private include directories  -----------------------------------
LOCAL_INC_DIR   = 

# ------------  system libraries  (e.g. -lm )  ---------------------------------
SYS_LIBS        = /usr/lib/libpcap.a

# ------------  additional system library directories  -------------------------
GLOBAL_LIB_DIR  =

# ------------  additional system libraries  -----------------------------------
GLOBAL_LIBS     =

# ------------  private library directories  -----------------------------------
LOCAL_LIB_DIR   = 

# ------------  private libraries  (e.g. libxyz.a )  ---------------------------
LOCAL_LIBS      =

# ------------  archive generation ---------------------------------------------
TARBALL_EXCLUDE = *.{o,gz,zip}
ZIP_EXCLUDE     = *.{o,gz,zip}

# ------------  run executable out of this Makefile  (yes/no)  -----------------
# ------------  cmd line parameters for this executable  -----------------------
EXE_START       = no
EXE_CMDLINE     =

#===============================================================================
# The following statements usually need not to be changed
#===============================================================================

C_SOURCES       = $(filter     %.c, $(SOURCES))
CPP_SOURCES     = $(filter-out %.c, $(SOURCES))
ALL_INC_DIR     = $(addprefix -I, $(LOCAL_INC_DIR) $(GLOBAL_INC_DIR))
ALL_LIB_DIR     = $(addprefix -L, $(LOCAL_LIB_DIR) $(GLOBAL_LIB_DIR))
GLOBAL_LIBSS    = $(addprefix $(GLOBAL_LIB_DIR)/, $(GLOBAL_LIBS))
LOCAL_LIBSS     = $(addprefix $(LOCAL_LIB_DIR)/, $(LOCAL_LIBS))
ALL_CFLAGS      = $(CFLAGS) $(ALL_INC_DIR)
ALL_LFLAGS      = $(LDFLAGS) $(ALL_LIB_DIR)
BASENAMES       = $(basename $(SOURCES))

# ------------  generate the names of the object files  ------------------------
OBJECTS         = $(addsuffix .o,$(BASENAMES))

# ------------  generate the names of the hidden prerequisite files  -----------
PREREQUISITES   = $(addprefix .,$(addsuffix .d,$(BASENAMES)))

# ------------  make the executable (the default goal)  ------------------------
$(EXECUTABLE):	$(OBJECTS)
ifeq ($(strip $(CPP_SOURCES)),)
								$(CC)  $(ALL_LFLAGS) -o $(EXECUTABLE) $(OBJECTS) $(LOCAL_LIBSS) $(GLOBAL_LIBSS) $(SYS_LIBS)
else
								$(CXX) $(ALL_LFLAGS) -o $(EXECUTABLE) $(OBJECTS) $(LOCAL_LIBSS) $(GLOBAL_LIBSS) $(SYS_LIBS)
endif
ifeq ($(EXE_START),yes)
								./$(EXECUTABLE) $(EXE_CMDLINE)
endif

# ------------  include the automatically generated prerequisites  -------------
# ------------  if target is not clean, tarball or zip             -------------
ifneq ($(MAKECMDGOALS),clean)
ifneq ($(MAKECMDGOALS),tarball)
ifneq ($(MAKECMDGOALS),zip)
include         $(PREREQUISITES)
endif
endif
endif

# ------------  make the objects  ----------------------------------------------
%.o:		%.c
				$(CC)  -c $(ALL_CFLAGS) $&lt;

%.o:		%.cc
				$(CXX) -c $(ALL_CFLAGS) $&lt;

%.o:		%.cpp
				$(CXX) -c $(ALL_CFLAGS) $&lt;

%.o:		%.C
				$(CXX) -c $(ALL_CFLAGS) $&lt;

# ------------  make the prerequisites  ----------------------------------------
#
.%.d:   %.c
				@$(make-prerequisite-c)

.%.d:		%.cc
				@$(make-prerequisite-cplusplus)

.%.d:		%.cpp
				@$(make-prerequisite-cplusplus)

.%.d:		%.C
				@$(make-prerequisite-cplusplus)

#  canned command sequences
#  echoing of the sed command is suppressed by the leading @

define	make-prerequisite-c
				@$(CC)   -MM $(ALL_CFLAGS) $&lt; &gt; $@.$$$$;            \
				sed 's/\($*\)\.o[ :]*/\1.o $@ : /g' &lt; $@.$$$$ &gt; $@; \
				rm -f $@.$$$$;
endef

define	make-prerequisite-cplusplus
				@$(CXX)  -MM $(ALL_CFLAGS) $&lt; &gt; $@.$$$$;            \
				sed 's/\($*\)\.o[ :]*/\1.o $@ : /g' &lt; $@.$$$$ &gt; $@; \
				rm -f $@.$$$$;
endef

# ------------  remove generated files  ----------------------------------------
# ------------  remove hidden backup files  ------------------------------------
clean:
								-rm -v  $(EXECUTABLE) $(OBJECTS) $(PREREQUISITES) *~

# ------------ tarball generation ----------------------------------------------
tarball:
					@lokaldir=`pwd`; lokaldir=$${lokaldir##*/}; \
					rm --force $$lokaldir.tar.gz;               \
					tar --exclude=$(TARBALL_EXCLUDE)            \
					    --create                                \
					    --gzip                                  \
					    --verbose                               \
					    --file  $$lokaldir.tar.gz *

# ------------ zip -------------------------------------------------------------
zip:
					@lokaldir=`pwd`; lokaldir=$${lokaldir##*/}; \
					zip -r  $$lokaldir.zip * -x $(ZIP_EXCLUDE)

install: $(EXECUTABLE)
				@./install /usr/local/bin

uninstall:
				-rm /usr/local/bin/$(EXECUTABLE) /usr/local/bin/runruijie


.PHONY: clean tarball zip

# ==============================================================================
# vim: set tabstop=2: set shiftwidth=2:
</code></pre>
<p>来源: <a href="https://gist.githubusercontent.com/tpu01yzx/826f47d2db2da9575e0916b4c1c234fc/raw/88aa7ff68557762e7ff3c275f9cceab62ec41da5/Makefile">这里</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beamer的若干技巧]]></title>
    <link href="https://weiviming.github.io/16372025188365.html"/>
    <updated>2021-11-18T10:28:38+08:00</updated>
    <id>https://weiviming.github.io/16372025188365.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E6%89%93%E5%BC%80%E8%87%AA%E5%8A%A8%E5%85%A8%E5%B1%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打开自动全屏</h2>
<p>仅限Acrobat Reader有效.</p>
<pre class="line-numbers"><code class="language-latex">\hypersetup{pdfpagemode=FullScreen}
</code></pre>
<h2><a id="%E4%B8%8D%E5%90%8C%E7%AB%A0%E8%8A%82%E5%89%8D%E6%98%BE%E7%A4%BA%E8%AF%A5%E7%AB%A0%E8%8A%82%E7%9B%AE%E5%BD%95%E9%A1%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不同章节前显示该章节目录页</h2>
<p>如果目录较长, 可能需要分两列显示, 为此, 首先在导言区(<code>\begin{document}</code>之前)添加以下宏包:</p>
<pre class="line-numbers"><code class="language-latex">\usepackage{multicol}
</code></pre>
<p>然后, 在第一帧(标题页)之后插入如下命令:</p>
<pre class="line-numbers"><code class="language-latex">\begin{frame}{Outline} % 插入目录帧, 标题显示为Outline
	\begin{multicols}{2}
 	\tableofcontents[sections={&lt;1-7&gt;}]
 	\end{multicols}
\end{frame}
  \AtBeginSection[] {
  \frame&lt;handout:0&gt; {
  \frametitle{Outline}
  \begin{multicols}{2}
	\tableofcontents[current,currentsubsection,hideothersubsections,sectionstyle=show/shaded,sections={&lt;1-7&gt;}]
  \end{multicols}
    }
    \addtocounter{framenumber}{-1}  %目录帧不计算页码
 }
</code></pre>
<p>上述命令在不同章节目录下不会显示其他章节的子标题. 命令中的<code>7</code>可以根据自己章节总数的多少自由修改.</p>
<h2><a id="%E5%B7%A6%E4%BE%A7%E6%8F%92%E5%9B%BE%E5%8F%B3%E4%BE%A7%E8%A7%A3%E9%87%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>左侧插图右侧解释</h2>
<p>有时候在用LaTeX做Beamer时, 需要在图片右侧插入相关解释, 为此可以使用<code>columns</code>环境, 具体做法如下:</p>
<pre class="line-numbers"><code class="language-latex">\begin{columns}
\column{.6\textwidth}
\begin{figure}
\centering
	\includegraphics[scale=0.21]{img.png}
\end{figure}
\column{.3\textwidth}
解释文字.
\end{columns}
</code></pre>
<h2><a id="%E9%80%90%E6%AD%A5%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逐步显示内容</h2>
<p>最简单的方案是在需要分步显示的语句前插入<code>\pause</code>,  如此会显示下一个<code>\pause</code>之前的内容, 而后面的内容不显示.</p>
<pre class="line-numbers"><code class="language-latex">\begin{frame}
直接显示内容1. 
\pause
显示内容2. 
\pause
再显示内容3.
\end{frame}
</code></pre>
<p>如果需要半透明显示后面的内容, 可以在<code>\begin{document}</code>之前插入如下语句:</p>
<pre class="line-numbers"><code class="language-latex">\setbeamercovered{dynamic} %% 令\pause后面的内容半透明
</code></pre>
<p>其实还可以使用<code>\onslide&lt;序号&gt;{显示内容}</code>命令来控制内容输出的次序, 序号控制了同一帧中第几步显示, 如果序号后面有短线<code>-</code>, 那么在以后的步骤中将一直显示该步的内容.</p>
<p>以上步骤的内容都将存在占位. 如果某些内容只需在某一步中显示一次, 不想像<code>\pause</code>和<code>\onslide</code>命令一样在后续动画中占位, 可以使用<code>\only&lt;序号&gt;{内容}</code>命令.</p>
<p>此外, 如果需要高亮强调某步的内容, 可以设置<code>alert</code>表示警告色彩(红色)显示, 也可以设置<code>structure</code>用Beamer主题颜色的色彩来高亮显示, 但警告色/高亮色会在下一步显示时变回普通样式, 如果需要长期显示, 可以直接使用颜色命令<code>\color{颜色代码}</code>标记该步的内容.</p>
<pre class="line-numbers"><code class="language-latex">\begin{frame}
直接显示.
\onslide&lt;1&gt; {只在第一步显示.} 

\only&lt;2&gt;{只在第二步显示的内容, 下一步显示前消失.}

\onslide&lt;1,3&gt; {第一、三步显示, 显示位置为第二步所在的位置. }

\textbf&lt;4&gt; {第四步加粗显示.}

\begin{itemize}
\item&lt;+-| structure@+&gt;第一步及以后显示(Beamer主题颜色)
\item&lt;2-| alert@+&gt; 第二步及以后显示(警告色)
\item&lt;3-&gt; 第三步及以后显示
\end{itemize}
\end{frame}
</code></pre>
<p>如果列表需要逐项显示, 那么可以使用如下简单的命令</p>
<pre class="line-numbers"><code class="language-latex">\begin{frame}
\begin{itemize}[&lt;+-&gt;]
\item 开始显示
\item 其次显示
\item 最后显示
\end{itemize}
\end{frame}
</code></pre>
<p>这其实等价于</p>
<pre class="line-numbers"><code class="language-latex">\begin{frame}
\begin{itemize}
\item&lt;1-&gt; 开始显示
\item&lt;2-&gt; 其次显示
\item&lt;3-&gt; 最后显示
\end{itemize}
\end{frame}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[终端快捷键笔记]]></title>
    <link href="https://weiviming.github.io/16369755197628.html"/>
    <updated>2021-11-15T19:25:19+08:00</updated>
    <id>https://weiviming.github.io/16369755197628.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th style="text-align: center">快捷键</th>
<th style="text-align: center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center"><kbd>Tab</kbd></td>
<td style="text-align: center">自动完成输入的内容, 或者显示所有可能的结果</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd>+ <code>C</code></td>
<td style="text-align: center">终止运行的程序</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>Z</code></td>
<td style="text-align: center">将正在运行的程序送入后台</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>D</code></td>
<td style="text-align: center">退出当前终端</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>L</code></td>
<td style="text-align: center">清空屏幕, 相当于<code>clear</code></td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>A</code></td>
<td style="text-align: center">将光标移到行首</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>E</code></td>
<td style="text-align: center">将光标移到行尾</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>U</code></td>
<td style="text-align: center">删除当前输入位置到行首的所有内容</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>K</code></td>
<td style="text-align: center">删除当前输入位置到行尾的所有内容</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>W</code></td>
<td style="text-align: center">删除当前位置之前的一个单词</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>Y</code></td>
<td style="text-align: center">粘贴<code>W</code>/<code>U</code>/<code>K</code>擦除的文本</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>P</code></td>
<td style="text-align: center">显示上一个命令</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>N</code></td>
<td style="text-align: center">显示下一个命令</td>
</tr>
<tr>
<td style="text-align: center"><kbd>Ctrl</kbd> + <code>R</code></td>
<td style="text-align: center">搜索历史命令, 按<kbd>ESC</kbd>退出搜索</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Typora文字两侧插入图片]]></title>
    <link href="https://weiviming.github.io/16353904758136.html"/>
    <updated>2021-10-28T11:07:55+08:00</updated>
    <id>https://weiviming.github.io/16353904758136.html</id>
    <content type="html"><![CDATA[
<p>通常使用Typora插入图片时, 如果使用Markdown语法, 则默认图片居中, 文字位于图片下方.</p>
<div style="float:left;" >
<img  align="left" src="media/16208108612154/WechatIMG3657.jpeg" alt="This is a image" style="zoom:5%;" >
</div>
<p>实际上可以通过HTML语法将图片插入文字两侧. 具体语法如下:</p>
<pre class="line-numbers"><code class="language-html">&lt;div style=&quot;float:left;&quot; &gt;
&lt;img align=&quot;left&quot; src=&quot;/path/to/image.png&quot; alt=&quot;This is a image&quot; style=&quot;zoom:20%;&quot; &gt;
&lt;/div&gt;
</code></pre>
<p>其中<code>align=&quot;left&quot;</code>将图片居左,  <code>zoom:20%</code>指的是放缩为原图片的20%显示.</p>
<p>不过该方法有个缺点: 这样做的话, 无法右键上传图片了.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[imagemagick图片处理]]></title>
    <link href="https://weiviming.github.io/16348897867509.html"/>
    <updated>2021-10-22T16:03:06+08:00</updated>
    <id>https://weiviming.github.io/16348897867509.html</id>
    <content type="html"><![CDATA[
<p>imagemagick图片处理包支持Windows/Mac/Linux全平台, 安装简单, <a href="https://www.imagemagick.org/script/index.php">官网在此</a>. 本文记录几例使用方法.</p>
<h2><a id="%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装</h2>
<p>Mac安装如下:</p>
<pre class="line-numbers"><code class="language-bash">brew install imagemagick
</code></pre>
<p>Linux安装如下:</p>
<pre class="line-numbers"><code class="language-bash">sudo apt install imagemagick
</code></pre>
<h2><a id="%E8%BD%AC%E6%8D%A2%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>转换图片格式</h2>
<pre class="line-numbers"><code class="language-bash">convert input.jpg output.png
</code></pre>
<p>上述命令将JPG图片转换为PNG图片.</p>
<h2><a id="%E6%8B%BC%E6%8E%A5%E5%9B%BE%E7%89%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拼接图片</h2>
<pre class="line-numbers"><code class="language-bash"># 横向拼接
convert +append image1.png image2.png output.png
# 竖向拼接
convert -append image1.png image2.png output.png
</code></pre>
<p>两者唯一的区别只是append前面的符号, <code>+</code>表示横向拼接, <code>-</code>表示竖向拼接.</p>
<h2><a id="%E5%9B%BE%E7%89%87%E9%80%8F%E6%98%8E%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图片透明度</h2>
<pre class="line-numbers"><code class="language-bash">convert input.jpg -matte -channel A +level 0,30% +channel output.png
</code></pre>
<p>上述命令将图片转换为透明度30%的PNG图片.</p>
<h2><a id="%E7%BC%A9%E6%94%BE%E5%9B%BE%E7%89%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缩放图片</h2>
<pre class="line-numbers"><code class="language-bash">convert input.jpg -resize 50% output.png
</code></pre>
<p>上述命令将图片缩放为原来的50%.</p>
<h2><a id="pdf%E8%BD%AC%E9%AB%98%E6%B8%85%E5%9B%BE%E7%89%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>pdf转高清图片</h2>
<pre class="line-numbers"><code class="language-bash">magick convert -density 600 poster.pdf -quality 90 ./poster.png
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fantastic Four: Honest-Majority Four-Party Secure Computation with Malicious Security]]></title>
    <link href="https://weiviming.github.io/16337773581295.html"/>
    <updated>2021-10-09T19:02:38+08:00</updated>
    <id>https://weiviming.github.io/16337773581295.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>今天给大家带来的是发表于<em>USENIX Security'21</em>的一篇文章<a href="https://www.usenix.org/system/files/sec21-dalskov.pdf">Fantastic Four: Honest-Majority Four-Party Secure Computation with Malicious Security</a>, 报告的slide见<a href="https://www.usenix.org/system/files/sec21_slides_dalskov.pdf">这里</a>.</p>
</blockquote>
<h2><a id="abstract" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Abstract</h2>
<p>本文介绍了一种诚实大多数的鲁棒四方计算协议, 具有主动安全性, 且不依赖于function-dependent preprocessing(预处理), 实现了输出可达性(Guaranteed output delivery, GOD), 同时保证协议中止同时确保任何一方不会得到超过输出的任何信息. 以往实现输出可达性采用的方案有SWIFT<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup>, FLASH<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup>, 让确定为诚实的参与方重构秘密并在明文下进行协议计算. 实验表明, 本文所提协议的效率接近于仅提供半诚实安全的三方诚实大多数计算协议, 这表明, 通过添加第四方是实现主动安全而不影响性能的有效方案.</p>
<h2><a id="background" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Background</h2>
<p>当前最快的MPC协议仅提供了中止安全性. 传统的MLaaS架构缺乏隐私保护, 而客户端/服务器模型(client/server model)是MLaaS架构常用的隐私保护替代方案, 如果存在恶意的计算方导致中止计算, 那么用户将无法得到输出, 这对于MLaaS来说是不能接受的, 因此模型的鲁棒性非常重要. 这里的鲁棒性可以理解为, 协议为所有参与方提供输出可达性, 而不论敌手是否存在恶意行为. 考虑MLaaS架构中的两种鲁棒类型的外包计算:</p>
<ul>
<li>
<p>传统鲁棒(traditional robustness)外包计算:  保证计算最后一定输出正确的结果. 考虑具体场景: 假设\(P_1,P_2,P_3,P_4\)四方进行MLaaS隐私计算, 其中一方是腐化方, 且协议是鲁棒的. 假设某次计算中\(P_2\)发现\(P_1\)和\(P_4\)的输入不一致, 意味着\(P_1\)和\(P_4\)中的某一方是恶意的, \(P_2\)广播该消息, 虽然鲁棒性要求计算不能中止,  但是有一点是所有计算方都可以肯定的: \(P_3\)肯定是诚实的, 则鲁棒性很容易达到, 为此所有参与方将他们的分享发给\(P_3\)重构输入, 然后再明文计算即可, 因此, 很容易实现输出可达性. 但这在现实中通常是不合理的, 因为\(P_3\)掌握了用户的所有输入, 而用户更希望数据在计算时始终保持隐私性.</p>
</li>
<li>
<p>隐私鲁棒(private robustness)外包计算: 这种类型下的外包计算也可以保证计算最后输出正确的结果, 但不依赖于诚实方获得用户的隐私输入. 本文介绍了如何通过四方和三方协议之间的转换来达到这一点.</p>
</li>
</ul>
<h3><a id="main-contributions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Main Contributions</h3>
<ol>
<li>提出了\(\mathbb{Z}_{2^k}\)上抵抗一个腐化方的主动安全的四方计算协议, 在相同设定下与当前好的方案整体复杂性相同, 除了常数开销的设定外, 无需任何预处理. 此外, 本文的方案允许丢弃后面计算中不必要的中间信息.</li>
<li>提出了\(\mathbb{Z}_{2^k}\)上抵抗一个腐化方的主动安全的三方计算协议, 虽然在线阶段的通信复杂度略高于当前最好的方案BLAZE<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup>, 但总体复杂性低几个数量级, 主要原因是点积计算的通信量与输入的长度无关.</li>
<li>通过训练MNIST, 进行了协议的基准测试, 并进一步考虑了定点精度的参数选取对训练准确度的影响.</li>
<li>展示了如何在保持隐私性的同时使得四方协议具备鲁棒性.</li>
</ol>
<p>本文的所有协议在<a href="https://github.com/data61/MP-SPDZ">MP-SPDZ</a>中可用.</p>
<h2><a id="secure-protocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secure Protocol</h2>
<h3><a id="replicated-secret-sharing" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Replicated Secret Sharing</h3>
<p>记四个参与方分别为\(P_i,P_j,P_g,P_h\), 其中\(i,j,g,h\in\{1,2,3,4\}\), 本文使用秘密共享方案是复制秘密共享(Replicated Secret Sharing). Dealer在四方下秘密共享秘密\(s\in\mathbb Z_{2^k}\)的方法(文章中的协议1), 如下图所示:</p>
<p><img src="https://s2.loli.net/2022/04/15/jwsUL3xKEgNPCpB.png" alt="RSS" /></p>
<ol>
<li>
<p>在\(\mathbb Z_{2^k}\)上选取三个随机数\(s_1,s_2,s_3\), 然后令\(s_4=s-(s_1+s_2+s_3)\);</p>
</li>
<li>
<p>发送\(\{s_j\}_{j\neq i}\)给\(P_i\), 记秘密共享为\([s]\).</p>
</li>
</ol>
<p>这意味着每方各持有的三个秘密分享, 且任意两方都可以恢复秘密\(s\). 由于该方案是线性的, 因此秘密分享形式下的加法和数乘都是无需交互, 这里不再介绍.</p>
<h3><a id="joint-message-passing" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Joint Message Passing</h3>
<img align="right" src="https://s2.loli.net/2022/04/15/APO1GXmysih5wpW.png"  style="zoom:35%;" />
<p>协议2用于当两方共有某个秘密需要发给第三方时, 进行的作弊识别检测. 假设\(x\)是\(P_i\)和\(P_j\)共有的信息, 需要发送给\(P_g\), 为此\(P_i\)发送\(x\), \(P_j\)发送\(H(x)\), 然后\(P_g\)检查从\(P_i\)收到的\(x\)的hash值是否与\(H(x)\)匹配, 若不匹配则发出中止信号\(err\)并指控\(P_i\)和\(P_j\), 参与方执行协议2, 输出最多两个参与方的集合, 其中一个参与方是恶意的.</p>
<p>JMP根据参与方的行为, 分为以下几种情况:</p>
<ol>
<li>若\(P_h\)是恶意的, 则不会产生任何中止信号;</li>
<li>若\(P_g\)是恶意的, 则\(P_g\)将错误地指控\(P_i,P_j\), 按照协议, \(P_g\)将广播\(P_i,P_j,c_i,c_j\). 若\(c_i=c_j\), 则参与方直接输出\(\{P_g\}\). 否则, 由于\(P_i\)和\(P_j\)都是诚实的, 则\(P_g\)广播的信息中必然有一项与\(P_i,P_j\)发送给它的信息不符合, 因此这两方之中必然有一方会指控\(P_g\), 例如\(P_i\)发出了指控, 此时参与方只需输出\(\{P_j,P_g\}\)组成的集合. 不管哪种情况, 输出的集合中都必然包含恶意方\(P_g\);</li>
<li>若\(P_i\)是恶意的, \(P_i\)将发送错误的信息给\(P_g\), \(P_g\)作为诚实方发现从\(P_i\)和\(P_j\)收到的信息不一致, 将指控\(P_i\)和\(P_j\), 此时只有\(P_i\)会指控\(P_g\), 因为\(P_g\)正确地广播了\(P_j\)发送的值. 如果\(P_i\)指控了\(P_g\), 则参与方将\(\{P_i,P_g\}\)作为输出, 否则将\(\{P_i,P_j\}\)作为输出, 不管哪种情况都有\(P_i\)在集合中. \(P_j\)是恶意的情形与\(P_i\)类似.</li>
</ol>
<p>由于JMP仅是三方协议, 因此文章假定没有参与JMP的计算方总是诚实的.</p>
<h3><a id="shared-input" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shared Input</h3>
<p>本节介绍秘密\(x\in\mathcal R\)如何在恶意安全下将\(x\)分享给各参与方, 使得各参与方获得\(x\)的份额\([x]\), 为此可以通过伪随机生成器\(\mathsf{PRG}\)来完成. 分两种情况:</p>
<ol>
<li>若有三个参与方\(P_i,P_j,P_h\)知道\(x\), 则不需要交互即可完成对\(x\)的秘密分享: 令\(x_i=x_j=x_h=0,x_g=x\)即可, 记为\([x]\leftarrow\mathsf{INPLocal}(x,P_i,P_j,P_h)\).</li>
<li>若只有两个参与方知道\(x\), 则可以借助\(\mathsf{PRG}_k\)(伪随机生成器)来完成, 其中\(k\)是密钥. 具体方案如下图协议3. 这里的第3步需要调用JMP确保\(P_g\)获得的\(x_h\)与\(P_i, P_j\)计算得到的是一致的.</li>
</ol>
<img src="https://s2.loli.net/2022/04/15/r7jLhQCFmRo1Ag5.png" style="zoom:50%;" />
<h3><a id="secure-multiplication" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secure Multiplication</h3>
<p>为计算\(x,y\)秘密分享的乘法\(xy\), 为此, 按照秘密共享形式将\(xy\) 展开, 我们得到如下几项, 乘法的目标就是计算所有这些项的和. 其中\(x_iy_i\)这一类的项是参与方无需交互就能计算的, 因为只有\(P_i\)无法计算这一项, 为此令\(P_i\)的三个分享都为0, 其他参与方的其中一个分享为\(x_iy_i\), 其余为0即可. 因此关键在于计算交叉项之和(文章的协议3).</p>
<p><img src="https://s2.loli.net/2022/04/15/ZOzTEKumb6jIk3U.png" alt="" /></p>
<p>下面以\(z:=x_1y_2+y_1x_2\)为例, 这一项\(P_3,P_4\)可以本地计算得到, 问题转化为\(P_3, P_4\)已知秘密\(z\), 如何向\(P_1,P_2\)秘密分享\(z\), 为此可以借助\(\mathsf{PRG}_k\)(伪随机生成器), \(k\)是密钥. 假设\(P_2,P_3,P_4\)之间有预分享的密钥\(k\), 首先\(P_2,P_3,P_4\)计算随机数\(z_1=r=\mathsf{PRG}_k()\)作为其中一个分享, \(P_3,P_4\)设定另一个分享为\(z_2=z-r\), 然后\(P_1,P_2\)令\(z_3=z_4=0\), 接下来只需让\(P_3\)发送\(z_2\)给\(P_1\)即可完成交叉项秘密分享. 由于是恶意安全模型下, 需要确保参与方\(P_3\)发送给\(P_1\)的信息和\(P_4\)持有的都是\(z_2\), 为此需要进行三方作弊识别检测(文章的协议2, Joint Message Passing), 并使得\(P_1\)得到正确的\(z_2\). 其余交叉项情况类似, 因为一共有6个这样的交叉项求和, 因此, 计算一个秘密分享的乘法算子需要发送6个元素, 整个乘法算子的计算步骤见文章协议4. 文章指出, 本文的方案除了JMP部分的哈希函数和伪随机生成器的状态之外, 不需要保留任何后续计算不再需要的秘密分享, 不依赖于功能函数的预处理阶段.</p>
<p><img src="https://s2.loli.net/2022/04/15/T1oXVC6rvxacNp5.png" alt="" /></p>
<img src="https://s2.loli.net/2022/04/15/Xa35vMqj1nVmbiJ.png" style="zoom:50%;" />
<h3><a id="probabilistic-truncation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Probabilistic Truncation</h3>
<img align="right" src="https://s2.loli.net/2022/04/15/n3bzYMSNFDEpdh6.png" style="zoom:40%;" />
<p>为了处理多方计算的定点算术(fixed-point arithmetic)问题, 本文将Dalskov等人<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup>与SWIFT<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup>的截断协议相结合给出概率截断的MPC协议(协议5).</p>
<p>给定\(\mathbb Z_{2^k}\)上的秘密份额\([x]\)和定点精度\(m\), 截断协议的目标是获得份额\([y]\), 这里的\(y=\lfloor x/2^m\rfloor\), 这等价于获得\(y=\lfloor x/2^m\rceil\). 在概率截断中, 我们更关注\(\lfloor x/2^m\rceil\)的最佳近似(就近取整). 具体而言, \(y=\lfloor x/2^m\rceil+u\), 其中\(u\in\{0,1\}\)更偏向于正确结果\(\lfloor x/2^m\rceil\), 即若\(x/2^m\)更接近于\(\lceil x/2^m\rceil\), 则\(u=1\); 若\(x/2^m\)更接近于\(\lfloor x/2^m\rfloor\), 则\(u=0\). 换而言之, \(u=1\)的概率为\((x\bmod 2^m)/2^m\). 举个例子, 若\(x=7,m=2\), 此时正确的结果应为\(7/2^2=1.75\), 概率截断协议给出的可能结果为\(\lfloor 7/4\rfloor=1\), 或\(\lfloor7/4\rfloor+1=2\), 后者即\(u=1\)的概率为\((7\bmod 2^2)/2^2=0.75\), 刚好是正确结果的小数部分.</p>
<p>为说明协议5的正确性, 令\(x\)是正数, 即\(\mathsf{MSB}(x)=0\), 则有\(0&lt;x&lt;2^{k-1}, x\bmod2^{k-1}=x\), 这意味着我们有: \(c=x+r\bmod2^k\), 这等价于\(c=x+r-2^ku\), 其中\(u\)是溢出标识比特, 即\(u=(x+r\geq _?2^k)\).  另一方面, 我们有\(c\bmod2^{k-1}=x\bmod2^{k-1}+r\bmod2^{k-1}\), 这等价于\(c\bmod 2^{k-1}=x\bmod2^{k-1}+r\bmod2^{k-1}-2^{k-1}b\), 其中\(b=(x\bmod2^{k-1}+r\bmod2^{k-1}\geq_?2^{k-1})\). 若记\(r_{k-1}=\mathsf{MSB}(r)\), 则可以证明\(u=b\cdot r_{k-1}\).</p>
<p>根据带余除法, 有\(r=2^{k-1}\cdot r_{k-1}+(r\bmod2^{k-1})\), \(c=2^{k-1}\cdot \lfloor c/2^{k-1}\rfloor+(c\bmod2^{k-1})\), 记\(c''=\lfloor c/2^{k-1}\rfloor\), 利用性质: 若\(a,b\)是两个比特, 则有\(a\oplus b=a+b-2ab\). 我们有</p>
\[\begin{aligned}
2^{k-1}\cdot c''&amp;=c-(c\bmod2^{k-1})\\
&amp;=(x+r-2^ku)-(x+(r\bmod2^{k-1})-2^{k-1}b)\\
&amp;=2^{k-1}r_{k-1}+2^{k-1}b-2^k\cdot b\cdot r_{k-1}\\
&amp;=2^{k-1}(r_{k-1}+b-2br_{k-1})\\
&amp;=2^{k-1}(r_{k-1}\oplus b).
\end{aligned}
\]
<p>故有\(c''=r_{k-1}\oplus b\), 于是\(b=c''\oplus r_{k-1}\).</p>
<p>因为\(x\bmod2^{k-1}=x\), 则有\((c\bmod2^{k-1})=x+(r\bmod2^{k-1})-2^{k-1}b\), 两边除于\(2^m\)并下取整得</p>
\[c'=\lfloor\frac{(c\bmod2^{k-1})}{2^m}\rfloor=\lfloor\dfrac{x+(r\bmod2^{k-1})}{2^m}\rfloor-2^{k-m-1}b,
\]
<p>其中</p>
\[\lfloor\dfrac{x+(r\bmod2^{k-1})}{2^m}\rfloor=\lfloor \dfrac{x}{2^m}\rfloor+\lfloor\dfrac{(r\bmod2^{k-1})}{2^m}\rfloor+w, ~~~~w\in\{0,1\}.
\]
<p>而\(r'=\lfloor\dfrac{(r\bmod2^{k-1})}{2^m}\rfloor\), 于是协议5的第7步输出为</p>
\[c'-r'+2^{k-m-1}b=\lfloor \dfrac{x}{2^m}\rfloor+w.
\]
<p>因此, \(w=1\)的概率等于\(\dfrac{x}{2^m}\)的小数部分, 即概率截断输出更倾向于\(\lfloor \dfrac{x}{2^m}\rceil\).</p>
<h3><a id="random-bit-generation-for-4pc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Random Bit Generation for 4PC</h3>
<p>生成随机比特是多方计算中一个基础原语. 协议6给出了4PC下的具体方案, 总体思想是将参与方分为两组, 每组通过预分享的密钥生成随机比特, 然后再对其进行秘密分享, 通过比特运算与算术运算的关系来生成随机比特\(b\). 因为每组中至少有一个参与方是诚实的, 所以恶参与方可以在INP协议中检测出来, 因此可以保证\(b\)的正确性.</p>
<img src="https://s2.loli.net/2022/04/15/rxVq6yEa7DcS42d.png" style="zoom:50%;" />
<h3><a id="mix-circuit-computation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mix-Circuit Computation</h3>
<p>比较和截断等非线性函数的计算通常在二进制计算(Binary computation)中更高效, 这反过来要求在算术运算(Arithmetic computation)和二进制运算中相互转换, 因为算术运算明显快于点积运算. 有两种方法来实现转换:</p>
<ul>
<li>对于某些秘密共享方案, 可以使用SPDZ, ABY, ABY3的B2A/A2B协议.</li>
<li>使用Rotaru和Wood的double-authenticated bits(daBits)方案, 在两个计算域中共享随机比特份额, 这些随机比特可以盲化(mask)秘密值. 例如, 若\(x\)是计算中的一个比特, \(r\)是秘密随机比特, 在计算域中打开\(x\oplus r\)不会泄漏任何信息, 于是可以在另一个计算域中计算\(x=(x\oplus r)\oplus r\), 因为\(r\)在两个计算域中是通过构造来获得. 由于\(r\)的生成与秘密无关, 因此非常适合于offline-online范式的多方计算协议中.</li>
</ul>
<p>Escudero等人<sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup>将第二种方法从1比特扩展到了\(m\)比特, 提出了extended daBits(edaBits), 并介绍了如何在任意安全模型中生成edaBits. 本文提出了在复制秘密共享模数为二次幂的高效生成预处理edaBits的方案. 构造的关键在于将生成edaBits中的使用的溢出校正(overflow correction)与复制秘密共享的本地份额转换相结合, 文章称之为份额拆分(Share splitting). 具体方案如下图协议7, 其中\(x[j]\)表示\(x\)的第\(j\)比特. 协议7可以扩展到\(n\)方复制秘密共享中.</p>
<p>协议8给出了高效生成edaBits的方法. edaBits是由\(\mathbb Z_{2^k}\)上秘密分享的随机值\([r]_{2^k}\)和它比特\(\{r[i]\}_{i=0}^{k-1}\)的二进制分享\([r]_2\)组成的对\(([r]_{2^k},[r]_2)\).若\(r\in\{0,1\}\)是均匀随机的, 则edaBits即为daBits. 通过daBits可以将\([b]_{2}\)转换为\([b]_{2^k}\): 参与方打开\(c\leftarrow[r]_2+[b]_2\), 然后计算\([b]_{2^k}=[r]_{2^k}+c-2\cdot c\cdot [r]_{2^k}\). 根据这个假设, 可以扩展生成\(m\)比特的edaBits.</p>
<p><img src="https://s2.loli.net/2022/04/15/vHbJsPExAiYwTgQ.png" alt="" /></p>
<h3><a id="3pc-with-malicious-security" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3PC with Malicious Security</h3>
<img align="right"  src="https://s2.loli.net/2022/04/15/K6gX1Gk4sPF8xpb.png" style="zoom:30%;" >
<p>本文实现鲁棒性依赖于三方计算. 与SPDZ类似, Abspoel等人的方案通过加入MAC到秘密份额中使得作弊可以被检测出来, 但他们的方案不支持连续计算, 因为它涉及验证正确性的最后检测阶段, 在此之前的一切都不被信任, 由于检测会泄漏某些防止作弊的秘密信息, 检测后无法进一步计算. 本文通过修改他们的验证协议, 通过献祭(sacrificing)在底层协议中的一个额外的秘密乘法, 使得这些秘密信息被隐藏起来, 以利于连续计算. 连续计算的好处是允许将秘密共享信息保存更长时间. 在实际操作方面, 检测协议将每个乘法的信息保留到检测阶段. 此外, 连续计算可以减少存储要求, 因为它允许定期检查, 从而删除中间信息.</p>
<p>设\(\langle x\rangle=([x]_{2^{k+s}},[r\cdot x]_{2^{k+s}})\)是\(x\)的SPDZ份额, 其中\(r\in\mathbb{Z}_{2^s}\)是全局MAC密钥. 见协议9, 这里直接使用了基于RSS的在模数为二次幂上的Zero-check功能函数\(\mathcal F_\mathsf{CheckZero}\). 这里简单介绍一下协议9中的Zero-check的具体思路<sup class="footnote-ref"><a href="#fn6" id="fnref6">6</a></sup>, 设存在一个随机预言机\(\mathcal H\), 若\(\sum_{i}x_i=0\), 则\(x_{i-1}\equiv_{k+s} -(x_i+x_{i+1})\), 因此\(P_i\)发送\(z_i=\mathcal H(-(x_i+x_{i+1}))\)给\(P_{i+1}\), 而\(P_{i+1}\)和\(P_{i-1}\)都有\(x_{i-1}\), 因此\(P_{i+1}\)可以检测\(z_i=\mathcal H(x_{i-1})\)是否成立, 若不成立, 则直接输出中止(Abort).</p>
<p>复杂度: 协议9底层协议中, 每个点积计算参与方需要发送\(k+s\)比特, 每个输入输入方需要发送\(2(k+s)\)比特. 因此在协议9中, 所有参与方的点积开销为\(6(k+s)\), 输入开销为\(3(k+s)\). 因此, 点积的开销与向量长度\(n\)无关.</p>
</br >
</br >
</br >
<h3><a id="random-bit-generation-for-2pc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Random Bit Generation for 2PC</h3>
<img align="right" src="https://s2.loli.net/2022/04/15/L2jf48wFimySR1b.png" style="zoom:30%;" >
<p>这里考虑的是2PC的情况, 与上面的有所区别.</p>
<p>生成具有半诚实安全性的随机比特的方法是两个不同参与方输入随机比特, 然后计算XOR即可.</p>
<p>然而在恶意安全的情况下, 恶意参与方可能输入的\(b\)可能不是一个比特, 为此在不泄漏\(b\)的前提下, 可以通过计算\(b(1-b)=0\)是否成立来检测是否有\(b\in\{0,1\}\).  本文构造的随机比特生成协议也使用了这一原理, 见协议10. 如果\(b_i=0\), 则最后一步检测将成功. 不失一般性, 假设\(P_0\)是诚实的,  因为</p>
\[b_i=b_i^0\oplus b_i^1=b_i^0+b_i^1-2\cdot b_i^0\cdot b_i^1=
\begin{cases}
b_i^1, &amp; b_i^0=0 \\
1-b_i^1, &amp; b_i^0=1.
\end{cases}
\]
<p>即, 无关\(b_i^0\),  \(b_i\in\{0,1\}\)当且仅当\(b_i^1\in\{0,1\}\). 这种方法排除了对\(b_i^0\)的选择失败攻击.</p>
<h3><a id="communication-cost" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Communication Cost</h3>
<p>本文的三方协议比其他工作慢一个数量级, 四方相差大约2倍.</p>
<p><img src="https://s2.loli.net/2022/04/15/gBRnk7m3X2pqYhV.png" alt="" /></p>
<h2><a id="privacy-robustness" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Privacy Robustness</h2>
<p>Slide的这个图很容易理解文章隐私鲁棒性的实现思想, 现在来说明总体的转换思路, 参与方之间约定若JMP输出了恶意参与方的集合, 则优先将索引数小的那个参与方是恶意参与方, 排除该参与方再进行后续计算. 继续背景中的场景, 因为\(P_1\)和\(P_4\)其中必有一方是恶意的, 先假设\(P_1\)是恶意的, 即排除\(P_1\), 剩下的三方将输入的四方秘密分享转化为三方秘密分享, 然后使用中止安全(Security with abort)的三方协议进行隐私计算. 如果在计算中仍然出现了中止信号, 说明\(P_4\)是恶意的, 排除\(P_4\), 剩下的\(P_2,P_3\)使用被动安全的两方计算协议完成隐私计算, 此时可以引入诚实的\(P_1\)生成乘法三元组协助两方进行隐私计算. 这样既可以在不向计算方泄漏用户的隐私信息的前提下完成计算, 又提供了鲁棒性, 达到了预期目标. 文章的JMP协议给出了当出现中止信号时, 检测恶意参与方的方法.</p>
<p><img src="https://s2.loli.net/2022/04/15/MlB5uvXO2wDy7ZT.png" alt="" /></p>
<p>现在说明排除潜在的恶意参与方后, 如何实现份额转换.</p>
<p>设\(x=x_1+x_2+x_3+x_4\), 参与方\(P_i\)拥有的份额为\(\{x_j\}_{j\neq i}\).</p>
<ol>
<li>四方份额转三方份额: 假设\(P_1\)被排除, 则进行如下转换: \(P_2,P_3\)定义\(x'=x_1+x_4\), \(P_4\)丢弃\(x_1\). 这样, \(P_2\)的持有的份额为\((x',x_3)\), \(P_3\)持有的份额为\((x_2,x')\), \(P_4\)的持有份额为\((x_2,x_3)\). 此后计算为恶意安全的三方计算.</li>
<li>三方份额转两方份额: 假设\(P_4\)被排除, 则进行如下转换: \(P_2\)定义\(x''=x'+x_3\), \(P_3\)丢弃\(x'\). 这样, \(P_2\)的持有份额为\(x''\), \(P_3\)的持有份额为\(x_2\). 此后计算为半诚实安全的两方计算, 但可以引入诚实方生成乘法三元组协助两方进行计算.</li>
</ol>
<h2><a id="experiment" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Experiment</h2>
<p>文章中的实验仅实现了中止安全性. 表2展示了不同安全模型下3层网络训练MNIST的计算开销和不同epoch下的模型准确率. 此外, 表3中可以看出文章所提出的半诚实安全的3PC和恶意安全的4PC开销基本相近.</p>
<p><img src="https://s2.loli.net/2022/04/15/LerDZkw7tnKUTHQ.png" alt="" /></p>
<h3><a id="the-impact-of-fixed-point-precision" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Impact of Fixed-Point Precision</h3>
<p>MPC使用浮点算术(float-point arithmetic)通常可以获得更好的准确性, 但开销也相对较大, 因此通常MPC使用的是效率更高的定点算术(fixed-point arithmetic). 但定点算术的方法由于需要进行概率截断, 可能会导致模型的准确率下降, 先前的工作所选的参数在小型模型上具有较好的准确率, 但大多忽略了在大型模型中的准确性降低的程度. 文章分别对比了不同定点精度与计算域位长导致的准确率和效率之间差异. 结果见表5和表6.</p>
<p>先前的工作大多要求概率截断中的精度比计算域最大长度\(k\)小得多, 误差概率为\(2^{\ell-k}\), 其中\(\ell\)是概率截断输入的长度. 表5表明这个概率大概为\(2^{-20}\). 为训练双层模型, 通常需要将每个数的误差概率限制为\(2^{-40}\).</p>
<p>表6说明虽然低精度截断使得通信量节省了大约1/3, 但较大的模数使得双层模型训练的时间增加了1倍.</p>
<p>此外, 文章还指出64比特模数和13比特定点精度不能满足大型模型训练要求, 表5双层模型定点精度为12时, 随着epoch增大, 模型的准确度反而下降.</p>
<p><img src="https://s2.loli.net/2022/04/15/DYGjVrCN3eHh65W.png" alt="" /></p>
<h2><a id="conclusion" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h2>
<p>SWIFT中不考虑对诚实方保护输入的隐私性, 为此本文提出了Privacy robustness, 在不泄漏任何参与方输入隐私的前提下, 实现了输出可达性. 提出的协议不需要预处理阶段, 但安全性保证的前提是假设诚实方只存储预期信息, 即协议执行完后诚实方不能恢复隐私输入, 为此本文设计的协议不含让诚实参与方恢复信息的步骤. 如果诚实方长期存储所有的输入信息, 则本文提出的方案不适用, 安全性假设较强.</p>
<h2><a id="references" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>References</h2>
<section class="footnotes">
<ol>
<li id="fn1">
<p>Nishat Koti, Mahak Pancholi, Arpita Patra, and Ajith Suresh. Swift: Super-fast and robust privacy-preserving machine learning. Cryptology ePrint Archive, Report 2020/592, 2020. <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2">
<p>Byali, Megha et al. “FLASH: Fast and Robust Framework for Privacy-preserving Machine Learning.” <em>Proceedings on Privacy Enhancing Technologies</em> 2020 (2019): 459 - 480. <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3">
<p>Arpita Patra and Ajith Suresh. BLAZE: Blazing fast privacy-preserving machine learning. In NDSS 2020. The Internet Society, February 2020. <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4">
<p>Anders P. K. Dalskov, Daniel Escudero, and Marcel Keller. Secure evaluation of quantized neural networks. PoPETs, 2020(4):355–375, October 2020. <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
<li id="fn5">
<p>Escudero, D., Ghosh, S., Keller, M., Rachuri, R. &amp; Scholl, P. Improved Primitives for MPC over Mixed Arithmetic-Binary Circuits. CRYPTO 2020. <a href="#fnref5" class="footnote-backref">↩</a></p>
</li>
<li id="fn6">
<p>Mark Abspoel, Anders Dalskov, Daniel Escudero, and Ariel Nof. An efficient passive-to-active compiler for honest-majority MPC over rings. Cryptology ePrint Archive, Report 2019/1298, 2019. <a href="#fnref6" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

]]></content>
  </entry>
  
</feed>
