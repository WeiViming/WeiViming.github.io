<!DOCTYPE html>

<html lang="zh" class="default-style layout-fixed layout-footer-fixed">

<head>
    <title>
        
        Fantastic Four: 具有恶意安全的诚实大多数四方安全计算 - 云中雨雾
        
    </title>

    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="IE=edge,chrome=1">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="icon" type="image/x-icon" href="https://s2.loli.net/2022/02/15/mLCBgAT7DSbj8iQ.jpg">
    
    <meta name="description" content="云中小屋, 岁月静好~">
    
    
    
    <link href="atom.xml" rel="alternate" title="云中雨雾" type="application/atom+xml">

    <!-- <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,500,500i,700,700i,900" rel="stylesheet"> -->

    <script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
    <script src="asset/vendor/js/bootstrap.js"></script>

    <!-- Icon fonts -->
    <link rel="stylesheet" href="asset/vendor/fonts/ionicons.css">

    <!-- Core stylesheets -->
    <link rel="stylesheet" href="asset/vendor/css/rtl/bootstrap.css" class="theme-settings-bootstrap-css">

    <link rel="stylesheet" href="asset/vendor/css/rtl/appwork.css" class="theme-settings-appwork-css">
    <link rel="stylesheet" href="asset/vendor/css/rtl/theme-corporate.css" class="theme-settings-theme-css">
    <link rel="stylesheet" href="asset/vendor/css/rtl/colors.css" class="theme-settings-colors-css">
    <link rel="stylesheet" href="asset/vendor/css/rtl/uikit.css">
    <link rel="stylesheet" href="asset/css/demo.css">
    <link rel="stylesheet" href="asset/css/docs.css">
    <link rel="stylesheet" href="asset/css/prism.css">

    <!-- Load polyfills -->
    <script src="asset/vendor/js/layout-helpers.js"></script>

    <!-- Core scripts -->
    <script src="asset/vendor/js/pace.js"></script>
    <script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    <script src="asset/jquery.toc.js"></script>

    <!-- Libs -->
    <link rel="stylesheet" href="asset/vendor/libs/perfect-scrollbar/perfect-scrollbar.css">

    	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: bold;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>

    <style>
        body, html {
            /* font-family: 'Nunito', PingFangSC-light, Helvetica, Arial, sans-serif; */
            /* font-family: Optima, PingFangSC-light, 'PingFang SC', sans-serif; */
        }
        #toc_container ul {
            list-style: none;
            padding-left: 10px;
        }
        p, ul, ol, li, table{
            /* font-family: Optima, PingFangSC-light, 'PingFang SC', sans-serif; */
        }
        table{
            width: auto;
        }
    </style>

</head>

<body>
<!-- Layout wrapper -->
<div class="layout-wrapper layout-2">
    <div class="layout-inner">


        <!-- Layout sidenav -->
        <div id="layout-sidenav" class="layout-sidenav sidenav sidenav-vertical bg-dark">

            <div class="app-brand demo">
          <span class="app-brand-logo demo" style="background-color: whitesmoke;">
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1"
                 id="Layer_1" x="0px" y="0px" width="57px" height="57px" viewBox="0 0 57 57"
                 enable-background="new 0 0 57 57" xml:space="preserve">  <image id="image0" width="57" height="57"
                                                                                 x="0" y="0"
                                                                                 href="https://s2.loli.net/2022/02/15/mLCBgAT7DSbj8iQ.jpg"/></svg>
          </span>
                <a href="index.html" class="app-brand-text demo sidenav-text font-weight-normal ml-2">云中雨雾</a>
                <a href="javascript:void(0)" class="layout-sidenav-toggle sidenav-link text-large ml-auto">
                    <i class="ion ion-md-menu align-middle"></i>
                </a>
            </div>

            <div class="sidenav-divider mt-0"></div>


            <!-- Links -->
            <ul id="sidenav-inner" class="sidenav-inner py-1">
            </ul>

            <script>
              $(function () {
                let innerHt = `
                    <li class="sidenav-item">
                        <a href="javascript:;" data-url="index.html" class="sidenav-link"><i class="sidenav-icon ion ion-md-speedometer"></i>
                            <div>主页</div>
                        </a>
                    </li>

                    <li class="sidenav-item">
                        <a href="javascript:;" data-url="archives.html" class="sidenav-link"><i class="sidenav-icon ion ion-ios-archive"></i>
                            <div>分类</div>
                        </a>
                    </li>


                    <li class="sidenav-item">
                        <a href="javascript:void(0)" class="sidenav-link sidenav-toggle"><i class="sidenav-icon ion ion-ios-bookmarks"></i>
                            <div>标签</div>
                        </a>

                        <ul class="sidenav-menu">
                            
                            <li class="sidenav-item">
                                <a href="javascript:void(0)" data-url="tag_%E5%85%B6%E4%BB%96.html" class="sidenav-link">
                                    <i class="sidenav-icon ion ion-ios-bookmark"></i>
                                    <div>其他(1)</div>
                                </a>
                            </li>
                            
                            <li class="sidenav-item">
                                <a href="javascript:void(0)" data-url="tag_%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA.html" class="sidenav-link">
                                    <i class="sidenav-icon ion ion-ios-bookmark"></i>
                                    <div>密码学理论(9)</div>
                                </a>
                            </li>
                            
                            <li class="sidenav-item">
                                <a href="javascript:void(0)" data-url="tag_%E5%B0%8F%E6%8A%80%E5%B7%A7.html" class="sidenav-link">
                                    <i class="sidenav-icon ion ion-ios-bookmark"></i>
                                    <div>小技巧(8)</div>
                                </a>
                            </li>
                            
                            <li class="sidenav-item">
                                <a href="javascript:void(0)" data-url="tag_%E7%BC%96%E7%A8%8B.html" class="sidenav-link">
                                    <i class="sidenav-icon ion ion-ios-bookmark"></i>
                                    <div>编程(5)</div>
                                </a>
                            </li>
                            
                            <li class="sidenav-item">
                                <a href="javascript:void(0)" data-url="tag_%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html" class="sidenav-link">
                                    <i class="sidenav-icon ion ion-ios-bookmark"></i>
                                    <div>隐私保护机器学习(7)</div>
                                </a>
                            </li>
                            
                        </ul>

                    </li>

                    <li class="sidenav-item">
                        <a href="javascript:;" data-url="about.html" class="sidenav-link"><i class="sidenav-icon ion ion-ios-leaf"></i>
                            <div>关于</div>
                        </a>
                    </li>


                                        

                        <li class="sidenav-divider mb-1"></li>
                        <li class="sidenav-header small font-weight-semibold">编程之路</li>


                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16373049349337.html" title="几个Makefile模板" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>几个Makefile模板</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16369755197628.html" title="终端快捷键笔记" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>终端快捷键笔记</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16307992850154.html" title="Windows下不关机重启WSL的方案" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>Windows下不关机重启WSL的方案</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16292930037213.html" title="Eigen3使用教程" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>Eigen3使用教程</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16209081474314.html" title="C++中的数据类型及其范围" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>C++中的数据类型及其范围</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16208091105804.html" title="NTL函数库的CMakeLists.txt书写方式" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>NTL函数库的CMakeLists.txt书写方式</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16208089129999.html" title="MacOS下cmake解决找不到链接库的问题" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>MacOS下cmake解决找不到链接库的问题</div>
                            </a>
                        </li>
                        

                        
                            </ul>

                        </li>
                        

                    

                        <li class="sidenav-divider mb-1"></li>
                        <li class="sidenav-header small font-weight-semibold">密码之路</li>


                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16477900515975.html" title="BLAZE: 快速隐私保护机器学习" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>BLAZE: 快速隐私保护机器学习</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16460999786637.html" title="安全计算协议的不同安全性区别" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>安全计算协议的不同安全性区别</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16460285618722.html" title="Cheetah: 精简快速安全两方深度神经网络推理" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>Cheetah: 精简快速安全两方深度神经网络推理</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16449265418549.html" title="SWIFT: 超快速鲁棒隐私保护机器学习" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>SWIFT: 超快速鲁棒隐私保护机器学习</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16434684624710.html" title="Privacy Preserving Machine Learning Resources" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>Privacy Preserving Machine Learning Resources</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16425853998520.html" title="安全与密码会议排名" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>安全与密码会议排名</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16414786119962.html" title="隐私计算技术路线" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>隐私计算技术路线</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16399887107456.html" title="隐私保护深度学习技术综述" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>隐私保护深度学习技术综述</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16377612600578.html" title="图说MPC协议" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>图说MPC协议</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16337773581295.html" title="Fantastic Four: 具有恶意安全的诚实大多数四方安全计算" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>Fantastic Four: 具有恶意安全的诚实大多数四方安全计算</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16237676401097.html" title="不经意传输及其优化方案" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>不经意传输及其优化方案</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16222891373334.html" title="混淆电路及其优化方案" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>混淆电路及其优化方案</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16208088340765.html" title="语义安全性" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>语义安全性</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16206453366291.html" title="基于秘密共享的安全计算" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>基于秘密共享的安全计算</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16205685385445.html" title="安全多方计算与混淆电路" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>安全多方计算与混淆电路</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16092286702660.html" title="安全多方计算" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>安全多方计算</div>
                            </a>
                        </li>
                        

                        
                            </ul>

                        </li>
                        

                    

                        <li class="sidenav-divider mb-1"></li>
                        <li class="sidenav-header small font-weight-semibold">应用技巧</li>


                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16408570070047.html" title="Typora/MWeb中简化数学公式输入" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>Typora/MWeb中简化数学公式输入</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16372025188365.html" title="Beamer的若干技巧" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>Beamer的若干技巧</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16353904758136.html" title="Typora文字两侧插入图片" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>Typora文字两侧插入图片</div>
                            </a>
                        </li>
                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16348897867509.html" title="imagemagick图片处理" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>imagemagick图片处理</div>
                            </a>
                        </li>
                        

                        
                            </ul>

                        </li>
                        

                    

                        <li class="sidenav-divider mb-1"></li>
                        <li class="sidenav-header small font-weight-semibold">奇闻轶事</li>


                        
                        <li class="sidenav-item">
                            <a href="javascript:void(0)" data-url="16410231259573.html" title="Falcom Pastebin Link" class="sidenav-link"><i class="sidenav-icon ion ion-md-document"></i>
                                <div>Falcom Pastebin Link</div>
                            </a>
                        </li>
                        

                        
                            </ul>

                        </li>
                        

                    



                `;
                $("#sidenav-inner").html(innerHt)



              });

            </script>
        </div>
        <!-- / Layout sidenav -->
 <!-- Layout container -->
<div class="layout-container">
    <!-- include _ (layout-navbar.html) -->

    <!-- Layout content -->
    <div class="layout-content   h-100" id="layout-content">

        <!-- Content -->
        <div class="container-fluid flex-grow-1 container-p-y  h-100">

            <!-- include    _  (post-title.html) -->

<!--            <div class="card p-3">-->

<!--                <article class="markdown-body single-content">-->
<!--                    <blockquote>
<p>今天给大家带来的是发表于<em>USENIX Security'21</em>的一篇文章<a href="https://www.usenix.org/system/files/sec21-dalskov.pdf">Fantastic Four: Honest-Majority Four-Party Secure Computation With Malicious Security</a>, 报告的slide见<a href="https://www.usenix.org/system/files/sec21_slides_dalskov.pdf">这里</a>.</p>
</blockquote>
<h2><a id="%E6%91%98%E8%A6%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>摘要</h2>
<p>本文介绍了一种诚实大多数的鲁棒四方计算协议, 具有主动安全性, 且不依赖于function-dependent preprocessing(预处理), 实现了输出可达性(Guaranteed output delivery, GOD), 同时保证协议中止同时确保任何一方不会得到超过输出的任何信息. 以往实现输出可达性采用的方案有SWIFT<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup>, FLASH<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup>, 让确定为诚实的参与方重构秘密并在明文下进行协议计算. 实验表明, 本文所提协议的效率接近于仅提供半诚实安全的三方诚实大多数计算协议, 这表明, 通过添加第四方是实现主动安全而不影响性能的有效方案.</p>
<h2><a id="%E8%83%8C%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>背景</h2>
<p>当前最快的MPC协议仅提供了中止安全性. 传统的MLaaS架构缺乏隐私保护, 而客户端/服务器模型(client/server model)是MLaaS架构常用的隐私保护替代方案, 如果存在恶意的计算方导致中止计算, 那么用户将无法得到输出, 这对于MLaaS来说是不能接受的, 因此模型的鲁棒性非常重要. 这里的鲁棒性可以理解为, 协议为所有参与方提供输出可达性, 而不论敌手是否存在恶意行为. 考虑MLaaS架构中的两种鲁棒类型的外包计算:</p>
<ul>
<li>
<p>传统鲁棒(traditional robustness)外包计算:  保证计算最后一定输出正确的结果. 考虑具体场景: 假设\(P_1,P_2,P_3,P_4\)四方进行MLaaS隐私计算, 其中一方是腐化方, 且协议是鲁棒的. 假设某次计算中\(P_2\)发现\(P_1\)和\(P_4\)的输入不一致, 意味着\(P_1\)和\(P_4\)中的某一方是恶意的, \(P_2\)广播该消息, 虽然鲁棒性要求计算不能中止,  但是有一点是所有计算方都可以肯定的: \(P_3\)肯定是诚实的, 则鲁棒性很容易达到, 为此所有参与方将他们的分享发给\(P_3\)重构输入, 然后再明文计算即可, 因此, 很容易实现输出可达性. 但这在现实中通常是不合理的, 因为\(P_3\)掌握了用户的所有输入, 而用户更希望数据在计算时始终保持隐私性.</p>
</li>
<li>
<p>隐私鲁棒(private robustness)外包计算: 这种类型下的外包计算也可以保证计算最后输出正确的结果, 但不依赖于诚实方获得用户的隐私输入. 本文介绍了如何通过四方和三方协议之间的转换来达到这一点.</p>
</li>
</ul>
<h3><a id="%E4%B8%BB%E8%A6%81%E8%B4%A1%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主要贡献</h3>
<ol>
<li>提出了\(\mathbb{Z}_{2^k}\)上抵抗一个腐化方的主动安全的四方计算协议, 在相同设定下与当前好的方案整体复杂性相同, 除了常数开销的设定外, 无需任何预处理. 此外, 本文的方案允许丢弃后面计算中不必要的中间信息.</li>
<li>提出了\(\mathbb{Z}_{2^k}\)上抵抗一个腐化方的主动安全的三方计算协议, 虽然在线阶段的通信复杂度略高于当前最好的方案BLAZE<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup>, 但总体复杂性低几个数量级, 主要原因是点积计算的通信量与输入的长度无关.</li>
<li>通过训练MNIST, 进行了协议的基准测试, 并进一步考虑了定点精度的参数选取对训练准确度的影响.</li>
<li>展示了如何在保持隐私性的同时使得四方协议具备鲁棒性.</li>
</ol>
<p>本文的所有协议在<a href="https://github.com/data61/MP-SPDZ">MP-SPDZ</a>中可用.</p>
<h2><a id="%E5%AE%89%E5%85%A8%E8%AE%A1%E7%AE%97%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安全计算协议</h2>
<h3><a id="%E5%A4%8D%E5%88%B6%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复制秘密共享方案</h3>
<p>记四个参与方分别为\(P_i,P_j,P_g,P_h\), 其中\(i,j,g,h\in\{1,2,3,4\}\), 本文使用秘密共享方案是复制秘密共享(Replicated Secret Sharing). Dealer在四方下秘密共享秘密\(s\in\mathbb Z_{2^k}\)的方法(文章中的协议1), 如下图所示:</p>
<p><img src="https://s2.loli.net/2022/04/15/jwsUL3xKEgNPCpB.png" alt="" /></p>
<ol>
<li>
<p>在\(\mathbb Z_{2^k}\)上选取三个随机数\(s_1,s_2,s_3\), 然后令\(s_4=s-(s_1+s_2+s_3)\);</p>
</li>
<li>
<p>发送\(\{s_j\}_{j\neq i}\)给\(P_i\), 记秘密共享为\([s]\).</p>
</li>
</ol>
<p>这意味着每方各持有的三个秘密分享, 且任意两方都可以恢复秘密\(s\). 由于该方案是线性的, 因此秘密分享形式下的加法和数乘都是无需交互, 这里不再介绍.</p>
<h3><a id="joint-message-passing" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Joint Message Passing</h3>
<img align="right" src="https://s2.loli.net/2022/04/15/APO1GXmysih5wpW.png"  style="zoom:35%;" />
<p>协议2用于当两方共有某个秘密需要发给第三方时, 进行的作弊识别检测. 假设\(x\)是\(P_i\)和\(P_j\)共有的信息, 需要发送给\(P_g\), 为此\(P_i\)发送\(x\), \(P_j\)发送\(H(x)\), 然后\(P_g\)检查从\(P_i\)收到的\(x\)的hash值是否与\(H(x)\)匹配, 若不匹配则发出中止信号\(err\)并指控\(P_i\)和\(P_j\), 参与方执行协议2, 输出最多两个参与方的集合, 其中一个参与方是恶意的.</p>
<p>JMP根据参与方的行为, 分为以下几种情况:</p>
<ol>
<li>若\(P_h\)是恶意的, 则不会产生任何中止信号;</li>
<li>若\(P_g\)是恶意的, 则\(P_g\)将错误地指控\(P_i,P_j\), 按照协议, \(P_g\)将广播\(P_i,P_j,c_i,c_j\). 若\(c_i=c_j\), 则参与方直接输出\(\{P_g\}\). 否则, 由于\(P_i\)和\(P_j\)都是诚实的, 则\(P_g\)广播的信息中必然有一项与\(P_i,P_j\)发送给它的信息不符合, 因此这两方之中必然有一方会指控\(P_g\), 例如\(P_i\)发出了指控, 此时参与方只需输出\(\{P_j,P_g\}\)组成的集合. 不管哪种情况, 输出的集合中都必然包含恶意方\(P_g\);</li>
<li>若\(P_i\)是恶意的, \(P_i\)将发送错误的信息给\(P_g\), \(P_g\)作为诚实方发现从\(P_i\)和\(P_j\)收到的信息不一致, 将指控\(P_i\)和\(P_j\), 此时只有\(P_i\)会指控\(P_g\), 因为\(P_g\)正确地广播了\(P_j\)发送的值. 如果\(P_i\)指控了\(P_g\), 则参与方将\(\{P_i,P_g\}\)作为输出, 否则将\(\{P_i,P_j\}\)作为输出, 不管哪种情况都有\(P_i\)在集合中. \(P_j\)是恶意的情形与\(P_i\)类似.</li>
</ol>
<p>由于JMP仅是三方协议, 因此文章假定没有参与JMP的计算方总是诚实的.</p>
<h3><a id="shared-input" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shared Input</h3>
<p>本节介绍秘密\(x\in\mathcal R\)如何在恶意安全下将\(x\)分享给各参与方, 使得各参与方获得\(x\)的份额\([x]\), 为此可以通过伪随机生成器\(\mathsf{PRG}\)来完成. 分两种情况:</p>
<ol>
<li>若有三个参与方\(P_i,P_j,P_h\)知道\(x\), 则不需要交互即可完成对\(x\)的秘密分享: 令\(x_i=x_j=x_h=0,x_g=x\)即可, 记为\([x]\leftarrow\mathsf{INPLocal}(x,P_i,P_j,P_h)\).</li>
<li>若只有两个参与方知道\(x\), 则可以借助\(\mathsf{PRG}_k\)(伪随机生成器)来完成, 其中\(k\)是密钥. 具体方案如下图协议3. 这里的第3步需要调用JMP确保\(P_g\)获得的\(x_h\)与\(P_i, P_j\)计算得到的是一致的.</li>
</ol>
<img src="https://s2.loli.net/2022/04/15/r7jLhQCFmRo1Ag5.png" style="zoom:50%;" />
<h3><a id="%E5%AE%89%E5%85%A8%E4%B9%98%E6%B3%95%E7%AE%97%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安全乘法算子</h3>
<p>为计算\(x,y\)秘密分享的乘法\(xy\), 为此, 按照秘密共享形式将\(xy\) 展开, 我们得到如下几项, 乘法的目标就是计算所有这些项的和. 其中\(x_iy_i\)这一类的项是参与方无需交互就能计算的, 因为只有\(P_i\)无法计算这一项, 为此令\(P_i\)的三个分享都为0, 其他参与方的其中一个分享为\(x_iy_i\), 其余为0即可. 因此关键在于计算交叉项之和(文章的协议3).</p>
<p><img src="https://s2.loli.net/2022/04/15/ZOzTEKumb6jIk3U.png" alt="" /></p>
<p>下面以\(z:=x_1y_2+y_1x_2\)为例, 这一项\(P_3,P_4\)可以本地计算得到, 问题转化为\(P_3, P_4\)已知秘密\(z\), 如何向\(P_1,P_2\)秘密分享\(z\), 为此可以借助\(\mathsf{PRG}_k\)(伪随机生成器), \(k\)是密钥. 假设\(P_2,P_3,P_4\)之间有预分享的密钥\(k\), 首先\(P_2,P_3,P_4\)计算随机数\(z_1=r=\mathsf{PRG}_k()\)作为其中一个分享, \(P_3,P_4\)设定另一个分享为\(z_2=z-r\), 然后\(P_1,P_2\)令\(z_3=z_4=0\), 接下来只需让\(P_3\)发送\(z_2\)给\(P_1\)即可完成交叉项秘密分享. 由于是恶意安全模型下, 需要确保参与方\(P_3\)发送给\(P_1\)的信息和\(P_4\)持有的都是\(z_2\), 为此需要进行三方作弊识别检测(文章的协议2, Joint Message Passing), 并使得\(P_1\)得到正确的\(z_2\). 其余交叉项情况类似, 因为一共有6个这样的交叉项求和, 因此, 计算一个秘密分享的乘法算子需要发送6个元素, 整个乘法算子的计算步骤见文章协议4. 文章指出, 本文的方案除了JMP部分的哈希函数和伪随机生成器的状态之外, 不需要保留任何后续计算不再需要的秘密分享, 不依赖于功能函数的预处理阶段.</p>
<p><img src="https://s2.loli.net/2022/04/15/T1oXVC6rvxacNp5.png" alt="" /></p>
<img src="https://s2.loli.net/2022/04/15/Xa35vMqj1nVmbiJ.png" style="zoom:50%;" />
<h3><a id="probabilistic-truncation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Probabilistic Truncation</h3>
<img align="right" src="https://s2.loli.net/2022/04/15/n3bzYMSNFDEpdh6.png" style="zoom:40%;" />
<p>为了处理多方计算的定点算术(fixed-point arithmetic)问题, 本文将Dalskov等人<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup>与SWIFT<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup>的截断协议相结合给出概率截断的MPC协议(协议5).</p>
<p>给定\(\mathbb Z_{2^k}\)上的秘密份额\([x]\)和定点精度\(m\), 截断协议的目标是获得份额\([y]\), 这里的\(y=\lfloor x/2^m\rfloor\), 这等价于获得\(y=\lfloor x/2^m\rceil\). 在概率截断中, 我们更关注\(\lfloor x/2^m\rceil\)的最佳近似(就近取整). 具体而言, \(y=\lfloor x/2^m\rceil+u\), 其中\(u\in\{0,1\}\)更偏向于正确结果\(\lfloor x/2^m\rceil\), 即若\(x/2^m\)更接近于\(\lceil x/2^m\rceil\), 则\(u=1\); 若\(x/2^m\)更接近于\(\lfloor x/2^m\rfloor\), 则\(u=0\). 换而言之, \(u=1\)的概率为\((x\bmod 2^m)/2^m\). 举个例子, 若\(x=7,m=2\), 此时正确的结果应为\(7/2^2=1.75\), 概率截断协议给出的可能结果为\(\lfloor 7/4\rfloor=1\), 或\(\lfloor7/4\rfloor+1=2\), 后者即\(u=1\)的概率为\((7\bmod 2^2)/2^2=0.75\), 刚好是正确结果的小数部分.</p>
<p>为说明协议5的正确性, 令\(x\)是正数, 即\(\mathsf{MSB}(x)=0\), 则有\(0&lt;x&lt;2^{k-1}, x\bmod2^{k-1}=x\), 这意味着我们有: \(c=x+r\bmod2^k, c=x+r\bmod2^{k-1}\)成立.  这等价于\(c=x+r-2^ku\), 其中\(u\)是溢出标识比特, 即\(u=(x+r\geq _?2^k)\).  类似地有\(c\bmod 2^{k-1}=x\bmod2^{k-1}+r\bmod2^{k-1}-2^{k-1}v\), 其中\(v=(x+r\geq_?2^{k-1})\). 若记\(r_{k-1}=\mathsf{MSB}(r)\), 则通过分类讨论容易证明\(u=v\cdot r_{k-1}\).</p>
<p>又因为\(c=2^{k-1}\cdot \lfloor c/2^{k-1}\rfloor+(c\bmod2^{k-1})\), 记\(c''=\lfloor c/2^{k-1}\rfloor\). 则有</p>
\[\begin{aligned}
2^{k-1}\cdot c''&amp;=c-(c\bmod2^{k-1})\\
&amp;=(x+r-2^ku)-(x+(r\bmod2^{k-1})-2^{k-1}v)\\
&amp;=2^{k-1}r_{k-1}+2^{k-1}v-2^k\cdot v\cdot r_{k-1}\\
&amp;=2^{k-1}(r_{k-1}\oplus v).
\end{aligned}
\]
<p>有\(c''=r_{k-1}\oplus v\), 或\(v=c''\oplus r_{k-1}\), \(v\)即协议中的\(b\). 这里的最后一步利用了比特运算与算术运算之间的性质: 若\(a,b\)是两个比特, 则有\(a\oplus b=a+b-2ab\). 协议5的第6步也利用了这一性质.</p>
<p>因为\(x\bmod2^{k-1}=x\), 则有\((c\bmod2^{k-1})=x+(r\bmod2^{k-1})-2^{k-1}v\), 因此</p>
\[\lfloor(c\bmod2^{k-1})/2^m\rfloor=\lfloor\dfrac{x+(r\bmod2^{k-1})}{2^m}\rfloor-2^{k-m-1}v.
\]
<p>另一方面, 因为</p>
\[c'=\lfloor(x+(r\bmod2^{k-1}))/2^m\rfloor=\lfloor x/2^m\rfloor+\lfloor(r\bmod2^{k-1})/2^m\rfloor+w, ~~~~w\in\{0,1\}.
\]
<p>而协议中的\(r'=\lfloor(r\bmod2^{k-1})/2^m\rfloor\), 于是协议5的第7步输出为</p>
\[c'-r'+2^{k-m-1}b=\lfloor x/2^m\rfloor+w.
\]
<p>因此, \(w=1\)的概率等于\(\dfrac{x}{2^m}\)的小数部分, 即概率截断输出更倾向于\(\lfloor x/2^m\rceil\).</p>
<h3><a id="random-bit-generation-for-4pc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Random Bit Generation for 4PC</h3>
<p>生成随机比特是多方计算中一个基础原语. 协议6给出了4PC下的具体方案, 总体思想是将参与方分为两组, 每组通过预分享的密钥生成随机比特, 然后再对其进行秘密分享, 通过比特运算与算术运算的关系来生成随机比特\(b\). 因为每组中至少有一个参与方是诚实的, 所以恶参与方可以在INP协议中检测出来, 因此可以保证\(b\)的正确性.</p>
<img src="https://s2.loli.net/2022/04/15/rxVq6yEa7DcS42d.png" style="zoom:50%;" />
<h3><a id="mix-circuit-computation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mix-Circuit Computation</h3>
<p>比较和截断等非线性函数的计算通常在二进制计算(Binary computation)中更高效, 这反过来要求在算术运算(Arithmetic computation)和二进制运算中相互转换, 因为算术运算明显快于点积运算. 有两种方法来实现转换:</p>
<ul>
<li>对于某些秘密共享方案, 可以使用SPDZ, ABY, ABY3的B2A/A2B协议.</li>
<li>使用Rotaru和Wood的double-authenticated bits(daBits)方案, 在两个计算域中共享随机比特份额, 这些随机比特可以盲化(mask)秘密值. 例如, 若\(x\)是计算中的一个比特, \(r\)是秘密随机比特, 在计算域中打开\(x\oplus r\)不会泄漏任何信息, 于是可以在另一个计算域中计算\(x=(x\oplus r)\oplus r\), 因为\(r\)在两个计算域中是通过构造来获得. 由于\(r\)的生成与秘密无关, 因此非常适合于offline-online范式的多方计算协议中.</li>
</ul>
<p>Escudero等人<sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup>将第二种方法从1比特扩展到了\(m\)比特, 提出了extended daBits(edaBits), 并介绍了如何在任意安全模型中生成edaBits. 本文提出了在复制秘密共享模数为二次幂的高效生成预处理edaBits的方案. 构造的关键在于将生成edaBits中的使用的溢出校正(overflow correction)与复制秘密共享的本地份额转换相结合, 文章称之为份额拆分(Share splitting). 具体方案如下图协议7, 其中\(x[j]\)表示\(x\)的第\(j\)比特. 协议7可以扩展到\(n\)方复制秘密共享中.</p>
<p>协议8给出了高效生成edaBits的方法. edaBits是由\(\mathbb Z_{2^k}\)上秘密分享的随机值\([r]_{2^k}\)和它比特\(\{r[i]\}_{i=0}^{k-1}\)的二进制分享\([r]_2\)组成的对\(([r]_{2^k},[r]_2)\).若\(r\in\{0,1\}\)是均匀随机的, 则edaBits即为daBits. 通过daBits可以将\([b]_{2}\)转换为\([b]_{2^k}\): 参与方打开\(c\leftarrow[r]_2+[b]_2\), 然后计算\([b]_{2^k}=[r]_{2^k}+c-2\cdot c\cdot [r]_{2^k}\). 根据这个假设, 可以扩展生成\(m\)比特的edaBits.</p>
<p><img src="https://s2.loli.net/2022/04/15/vHbJsPExAiYwTgQ.png" alt="" /></p>
<h2><a id="%E6%81%B6%E6%84%8F%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%89%E6%96%B9%E8%AE%A1%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>恶意安全的三方计算</h2>
<img align="right"  src="https://s2.loli.net/2022/04/15/K6gX1Gk4sPF8xpb.png" style="zoom:30%;" >
<p>本文实现鲁棒性依赖于三方计算. 与SPDZ类似, Abspoel等人的方案通过加入MAC到秘密份额中使得作弊可以被检测出来, 但他们的方案不支持连续计算, 因为它涉及验证正确性的最后检测阶段, 在此之前的一切都不被信任, 由于检测会泄漏某些防止作弊的秘密信息, 检测后无法进一步计算. 本文通过修改他们的验证协议, 通过献祭(sacrificing)在底层协议中的一个额外的秘密乘法, 使得这些秘密信息被隐藏起来, 以利于连续计算. 连续计算的好处是允许将秘密共享信息保存更长时间. 在实际操作方面, 检测协议将每个乘法的信息保留到检测阶段. 此外, 连续计算可以减少存储要求, 因为它允许定期检查, 从而删除中间信息.</p>
<p>设\(\langle x\rangle=([x]_{2^{k+s}},[r\cdot x]_{2^{k+s}})\)是\(x\)的SPDZ份额, 其中\(r\in\mathbb{Z}_{2^s}\)是全局MAC密钥. 见协议9, 这里直接使用了基于RSS的在模数为二次幂上的Zero-check功能函数\(\mathcal F_\mathsf{CheckZero}\). 这里简单介绍一下协议9中的Zero-check的具体思路<sup class="footnote-ref"><a href="#fn6" id="fnref6">6</a></sup>, 设存在一个随机预言机\(\mathcal H\), 若\(\sum_{i}x_i=0\), 则\(x_{i-1}\equiv_{k+s} -(x_i+x_{i+1})\), 因此\(P_i\)发送\(z_i=\mathcal H(-(x_i+x_{i+1}))\)给\(P_{i+1}\), 而\(P_{i+1}\)和\(P_{i-1}\)都有\(x_{i-1}\), 因此\(P_{i+1}\)可以检测\(z_i=\mathcal H(x_{i-1})\)是否成立, 若不成立, 则直接输出中止(Abort).</p>
<p>复杂度: 协议9底层协议中, 每个点积计算参与方需要发送\(k+s\)比特, 每个输入输入方需要发送\(2(k+s)\)比特. 因此在协议9中, 所有参与方的点积开销为\(6(k+s)\), 输入开销为\(3(k+s)\). 因此, 点积的开销与向量长度\(n\)无关.</p>
</br >
</br >
</br >
<h3><a id="random-bit-generation-for-2pc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Random Bit Generation for 2PC</h3>
<img align="right" src="https://s2.loli.net/2022/04/15/L2jf48wFimySR1b.png" style="zoom:30%;" >
<p>这里考虑的是2PC的情况, 与上面的有所区别.</p>
<p>生成具有半诚实安全性的随机比特的方法是两个不同参与方输入随机比特, 然后计算XOR即可.</p>
<p>然而在恶意安全的情况下, 恶意参与方可能输入的\(b\)可能不是一个比特, 为此在不泄漏\(b\)的前提下, 可以通过计算\(b(1-b)=0\)是否成立来检测是否有\(b\in\{0,1\}\).  本文构造的随机比特生成协议也使用了这一原理, 见协议10. 如果\(b_i=0\), 则最后一步检测将成功. 不失一般性, 假设\(P_0\)是诚实的,  因为</p>
\[b_i=b_i^0\oplus b_i^1=b_i^0+b_i^1-2\cdot b_i^0\cdot b_i^1=
\begin{cases}
b_i^1, &amp; b_i^0=0 \\
1-b_i^1, &amp; b_i^0=1.
\end{cases}
\]
<p>即, 无关\(b_i^0\),  \(b_i\in\{0,1\}\)当且仅当\(b_i^1\in\{0,1\}\). 这种方法排除了对\(b_i^0\)的选择失败攻击.</p>
<h2><a id="%E9%80%9A%E4%BF%A1%E5%A4%8D%E6%9D%82%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通信复杂度</h2>
<p>本文的三方协议比其他工作慢一个数量级, 四方相差大约2倍.</p>
<p><img src="https://s2.loli.net/2022/04/15/gBRnk7m3X2pqYhV.png" alt="" /></p>
<h2><a id="privacy-robustness" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Privacy Robustness</h2>
<p>Slide的这个图很容易理解文章隐私鲁棒性的实现思想, 现在来说明总体的转换思路, 参与方之间约定若JMP输出了恶意参与方的集合, 则优先将索引数小的那个参与方是恶意参与方, 排除该参与方再进行后续计算. 继续背景中的场景, 因为\(P_1\)和\(P_4\)其中必有一方是恶意的, 先假设\(P_1\)是恶意的, 即排除\(P_1\), 剩下的三方将输入的四方秘密分享转化为三方秘密分享, 然后使用中止安全(Security with abort)的三方协议进行隐私计算. 如果在计算中仍然出现了中止信号, 说明\(P_4\)是恶意的, 排除\(P_4\), 剩下的\(P_2,P_3\)使用被动安全的两方计算协议完成隐私计算, 此时可以引入诚实的\(P_1\)生成乘法三元组协助两方进行隐私计算. 这样既可以在不向计算方泄漏用户的隐私信息的前提下完成计算, 又提供了鲁棒性, 达到了预期目标. 文章的JMP协议给出了当出现中止信号时, 检测恶意参与方的方法.</p>
<p><img src="https://s2.loli.net/2022/04/15/MlB5uvXO2wDy7ZT.png" alt="" /></p>
<p>现在说明排除潜在的恶意参与方后, 如何实现份额转换.</p>
<p>设\(x=x_1+x_2+x_3+x_4\), 参与方\(P_i\)拥有的份额为\(\{x_j\}_{j\neq i}\).</p>
<ol>
<li>四方份额转三方份额: 假设\(P_0\)被排除, 则进行如下转换: \(P_1,P_2\)定义\(x'=x_0+x_3\), \(P_3\)丢弃\(x_0\). 这样, \(P_1\)的持有的份额为\((x',x_2)\), \(P_2\)持有的份额为\((x_1,x')\), \(P_3\)的持有份额为\((x_1,x_2)\). 此后计算为恶意安全的三方计算.</li>
<li>三方份额转两方份额: 假设\(P_3\)被排除, 则进行如下转换: \(P_1\)定义\(x''=x'+x_2\), \(P_2\)丢弃\(x'\). 这样\(P_1\)的持有份额为\(x''\), \(P_2\)的持有份额为\(x_1\). 此后计算为半诚实安全的两方计算, 但可以引入诚实方生成乘法三元组协助两方进行计算.</li>
</ol>
<h2><a id="%E5%AE%9E%E9%AA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实验</h2>
<p>文章中的实验仅实现了中止安全性. 表2展示了不同安全模型下3层网络训练MNIST的计算开销和不同epoch下的模型准确率. 此外, 表3中可以看出文章所提出的半诚实安全的3PC和恶意安全的4PC开销基本相近.</p>
<p><img src="https://s2.loli.net/2022/04/15/LerDZkw7tnKUTHQ.png" alt="" /></p>
<h3><a id="%E5%AE%9A%E7%82%B9%E7%B2%BE%E5%BA%A6%E7%9A%84%E5%BD%B1%E5%93%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定点精度的影响</h3>
<p>MPC使用浮点算术(float-point arithmetic)通常可以获得更好的准确性, 但开销也相对较大, 因此通常MPC使用的是效率更高的定点算术(fixed-point arithmetic). 但定点算术的方法由于需要进行概率截断, 可能会导致模型的准确率下降, 先前的工作所选的参数在小型模型上具有较好的准确率, 但大多忽略了在大型模型中的准确性降低的程度. 文章分别对比了不同定点精度与计算域位长导致的准确率和效率之间差异. 结果见表5和表6.</p>
<p>先前的工作大多要求概率截断中的精度比计算域最大长度\(k\)小得多, 误差概率为\(2^{\ell-k}\), 其中\(\ell\)是概率截断输入的长度. 表5表明这个概率大概为\(2^{-20}\). 为训练双层模型, 通常需要将每个数的误差概率限制为\(2^{-40}\).</p>
<p>表6说明虽然低精度截断使得通信量节省了大约1/3, 但较大的模数使得双层模型训练的时间增加了1倍.</p>
<p>此外, 文章还指出64比特模数和13比特定点精度不能满足大型模型训练要求, 表5双层模型定点精度为12时, 随着epoch增大, 模型的准确度反而下降.</p>
<p><img src="https://s2.loli.net/2022/04/15/DYGjVrCN3eHh65W.png" alt="" /></p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>本文提出了Privacy robustness, 在不泄漏任何参与方输入隐私的前提下, 实现了输出可达性. 提出的协议不需要预处理阶段, 但安全性保证的前提是假设诚实方只存储预期信息, 即协议执行完后诚实方不能恢复隐私输入, 为此本文设计的协议不含让诚实参与方恢复信息的步骤. 如果诚实方长期存储所有的输入信息, 则本文提出的方案不适用, 安全性假设较强.</p>
<h2><a id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考文献</h2>
<section class="footnotes">
<ol>
<li id="fn1">
<p>Nishat Koti, Mahak Pancholi, Arpita Patra, and Ajith Suresh. Swift: Super-fast and robust privacy-preserving machine learning. Cryptology ePrint Archive, Report 2020/592, 2020. <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2">
<p>Byali, Megha et al. “FLASH: Fast and Robust Framework for Privacy-preserving Machine Learning.” <em>Proceedings on Privacy Enhancing Technologies</em> 2020 (2019): 459 - 480. <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3">
<p>Arpita Patra and Ajith Suresh. BLAZE: Blazing fast privacy-preserving machine learning. In NDSS 2020. The Internet Society, February 2020. <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4">
<p>Anders P. K. Dalskov, Daniel Escudero, and Marcel Keller. Secure evaluation of quantized neural networks. PoPETs, 2020(4):355–375, October 2020. <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
<li id="fn5">
<p>Escudero, D., Ghosh, S., Keller, M., Rachuri, R. &amp; Scholl, P. Improved Primitives for MPC over Mixed Arithmetic-Binary Circuits. CRYPTO 2020. <a href="#fnref5" class="footnote-backref">↩</a></p>
</li>
<li id="fn6">
<p>Mark Abspoel, Anders Dalskov, Daniel Escudero, and Ariel Nof. An efficient passive-to-active compiler for honest-majority MPC over rings. Cryptology ePrint Archive, Report 2019/1298, 2019. <a href="#fnref6" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>
-->
<!--                </article>-->


<!--            </div>-->


            <div class="chat-wrapper  h-100">

                <!-- Make card full height of `.chat-wrapper` -->
                <div class="card flex-grow-1 position-relative overflow-hidden ">

                    <!-- Make row full height of `.card` -->
                    <div class="row no-gutters h-100">
                        <div class="chat-sidebox col">

                            <!-- Chat contacts header -->
                            <!-- <div class="flex-grow-0 px-4">
                                <div class="media align-items-center">
                                    <div class="media-body">
                                        <input type="text" class="form-control chat-search my-3" placeholder="Search...">
                                    </div>
                                    <a href="javascript:void(0)" class="chat-sidebox-toggler d-lg-none d-block text-muted text-large font-weight-light pl-3">&times;</a>
                                </div>
                                <hr class="border-light m-0">
                            </div> -->
                            <!-- / Chat contacts header -->

                            <!-- Wrap `.chat-scroll` to properly position scroll area. Remove this wtapper if you don't need scroll -->
                            <div class="flex-grow-1 position-relative">
                                <div class="chat-contacts list-group chat-scroll py-3" style="padding: 10px;" >




                                    <!-- <ul id="toc_container" class="py-1" style="list-style: none; padding-left: 0;"></ul> -->

                                    <ul id="toc_container" style="list-style: none; padding-left: 0;"></ul>

                                </div><!-- / .chat-contacts -->
                            </div>

                        </div>
                        <div class="d-flex col flex-column">

                            <!-- Chat header -->
                            <div class="flex-grow-0 py-3 pr-4 pl-lg-4">

                                <div class="media align-items-center">
                                    <a href="javascript:void(0)" class="chat-sidebox-toggler d-lg-none d-block text-muted text-large px-4 mr-2"><i class="ion ion-md-more"></i></a>


<!--                                    <div class="media-body pl-3">-->
<!--                                        <h1>Kenneth Frazier</h1>-->
<!--                                        <div class="text-muted small"><em>Typing...</em></div>-->
<!--                                    </div>-->

                                    <!--<h2 id="post-header" class="font-weight-bold py-0">-->
<!--    Fantastic Four: 具有恶意安全的诚实大多数四方安全计算-->
<!--    <div class="text-muted text-tiny mt-1"><small class="font-weight-normal">2021/10/09 19:02 下午</small></div>-->
<!--</h2>-->

<div class="media-body pl-3">
    <h1 id="post-header">Fantastic Four: 具有恶意安全的诚实大多数四方安全计算</h1>
    <div class="text-muted small"><em>2021/10/09 19:02 下午</em>
        
        <span class="ml-2">标签:</span>
        
        <a href="tag_%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html" class="badge badge-default align-text-bottom ml-1 text-muted">#隐私保护机器学习</a>
        
        
    </div>
</div>

<link rel="stylesheet" href="asset/chat.css">

<script type="text/javascript">
    jQuery(document).ready(function($) {
        // add toc to article element
        $("#article_with_toc").toc(
          {
              strip: true,
              stripAfter: 100,
              container: "#toc_container",
              scrollSpeed: 1,
              scrollOffset: 135
          });
    });
</script>



                                    <!-- <div>
                                      <button type="button" class="btn btn-primary rounded-pill icon-btn mr-1"><i class="ion ion-ios-call"></i></button>
                                      <button type="button" class="btn btn-secondary rounded-pill icon-btn mr-1"><i class="ion ion-md-videocam"></i></button>
                                      <button type="button" class="btn btn-default rounded-pill icon-btn"><i class="ion ion-ios-more"></i></button>
                                    </div> -->
                                </div>

                            </div>
                            <hr class="flex-grow-0 border-light m-0">
                            <!-- / Chat header -->

                            <!-- Wrap `.chat-scroll` to properly position scroll area. Remove this wtapper if you don't need scroll -->
                            <div class="flex-grow-1 position-relative">

                                <!-- Remove `.chat-scroll` and add `.flex-grow-1` if you don't need scroll -->
                                <div class="chat-scroll p-4 v-scroll-spy markdown-body" id="article_with_toc">

                                    <blockquote>
<p>今天给大家带来的是发表于<em>USENIX Security'21</em>的一篇文章<a href="https://www.usenix.org/system/files/sec21-dalskov.pdf">Fantastic Four: Honest-Majority Four-Party Secure Computation With Malicious Security</a>, 报告的slide见<a href="https://www.usenix.org/system/files/sec21_slides_dalskov.pdf">这里</a>.</p>
</blockquote>
<h2><a id="%E6%91%98%E8%A6%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>摘要</h2>
<p>本文介绍了一种诚实大多数的鲁棒四方计算协议, 具有主动安全性, 且不依赖于function-dependent preprocessing(预处理), 实现了输出可达性(Guaranteed output delivery, GOD), 同时保证协议中止同时确保任何一方不会得到超过输出的任何信息. 以往实现输出可达性采用的方案有SWIFT<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup>, FLASH<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup>, 让确定为诚实的参与方重构秘密并在明文下进行协议计算. 实验表明, 本文所提协议的效率接近于仅提供半诚实安全的三方诚实大多数计算协议, 这表明, 通过添加第四方是实现主动安全而不影响性能的有效方案.</p>
<h2><a id="%E8%83%8C%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>背景</h2>
<p>当前最快的MPC协议仅提供了中止安全性. 传统的MLaaS架构缺乏隐私保护, 而客户端/服务器模型(client/server model)是MLaaS架构常用的隐私保护替代方案, 如果存在恶意的计算方导致中止计算, 那么用户将无法得到输出, 这对于MLaaS来说是不能接受的, 因此模型的鲁棒性非常重要. 这里的鲁棒性可以理解为, 协议为所有参与方提供输出可达性, 而不论敌手是否存在恶意行为. 考虑MLaaS架构中的两种鲁棒类型的外包计算:</p>
<ul>
<li>
<p>传统鲁棒(traditional robustness)外包计算:  保证计算最后一定输出正确的结果. 考虑具体场景: 假设\(P_1,P_2,P_3,P_4\)四方进行MLaaS隐私计算, 其中一方是腐化方, 且协议是鲁棒的. 假设某次计算中\(P_2\)发现\(P_1\)和\(P_4\)的输入不一致, 意味着\(P_1\)和\(P_4\)中的某一方是恶意的, \(P_2\)广播该消息, 虽然鲁棒性要求计算不能中止,  但是有一点是所有计算方都可以肯定的: \(P_3\)肯定是诚实的, 则鲁棒性很容易达到, 为此所有参与方将他们的分享发给\(P_3\)重构输入, 然后再明文计算即可, 因此, 很容易实现输出可达性. 但这在现实中通常是不合理的, 因为\(P_3\)掌握了用户的所有输入, 而用户更希望数据在计算时始终保持隐私性.</p>
</li>
<li>
<p>隐私鲁棒(private robustness)外包计算: 这种类型下的外包计算也可以保证计算最后输出正确的结果, 但不依赖于诚实方获得用户的隐私输入. 本文介绍了如何通过四方和三方协议之间的转换来达到这一点.</p>
</li>
</ul>
<h3><a id="%E4%B8%BB%E8%A6%81%E8%B4%A1%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主要贡献</h3>
<ol>
<li>提出了\(\mathbb{Z}_{2^k}\)上抵抗一个腐化方的主动安全的四方计算协议, 在相同设定下与当前好的方案整体复杂性相同, 除了常数开销的设定外, 无需任何预处理. 此外, 本文的方案允许丢弃后面计算中不必要的中间信息.</li>
<li>提出了\(\mathbb{Z}_{2^k}\)上抵抗一个腐化方的主动安全的三方计算协议, 虽然在线阶段的通信复杂度略高于当前最好的方案BLAZE<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup>, 但总体复杂性低几个数量级, 主要原因是点积计算的通信量与输入的长度无关.</li>
<li>通过训练MNIST, 进行了协议的基准测试, 并进一步考虑了定点精度的参数选取对训练准确度的影响.</li>
<li>展示了如何在保持隐私性的同时使得四方协议具备鲁棒性.</li>
</ol>
<p>本文的所有协议在<a href="https://github.com/data61/MP-SPDZ">MP-SPDZ</a>中可用.</p>
<h2><a id="%E5%AE%89%E5%85%A8%E8%AE%A1%E7%AE%97%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安全计算协议</h2>
<h3><a id="%E5%A4%8D%E5%88%B6%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复制秘密共享方案</h3>
<p>记四个参与方分别为\(P_i,P_j,P_g,P_h\), 其中\(i,j,g,h\in\{1,2,3,4\}\), 本文使用秘密共享方案是复制秘密共享(Replicated Secret Sharing). Dealer在四方下秘密共享秘密\(s\in\mathbb Z_{2^k}\)的方法(文章中的协议1), 如下图所示:</p>
<p><img src="https://s2.loli.net/2022/04/15/jwsUL3xKEgNPCpB.png" alt="" /></p>
<ol>
<li>
<p>在\(\mathbb Z_{2^k}\)上选取三个随机数\(s_1,s_2,s_3\), 然后令\(s_4=s-(s_1+s_2+s_3)\);</p>
</li>
<li>
<p>发送\(\{s_j\}_{j\neq i}\)给\(P_i\), 记秘密共享为\([s]\).</p>
</li>
</ol>
<p>这意味着每方各持有的三个秘密分享, 且任意两方都可以恢复秘密\(s\). 由于该方案是线性的, 因此秘密分享形式下的加法和数乘都是无需交互, 这里不再介绍.</p>
<h3><a id="joint-message-passing" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Joint Message Passing</h3>
<img align="right" src="https://s2.loli.net/2022/04/15/APO1GXmysih5wpW.png"  style="zoom:35%;" />
<p>协议2用于当两方共有某个秘密需要发给第三方时, 进行的作弊识别检测. 假设\(x\)是\(P_i\)和\(P_j\)共有的信息, 需要发送给\(P_g\), 为此\(P_i\)发送\(x\), \(P_j\)发送\(H(x)\), 然后\(P_g\)检查从\(P_i\)收到的\(x\)的hash值是否与\(H(x)\)匹配, 若不匹配则发出中止信号\(err\)并指控\(P_i\)和\(P_j\), 参与方执行协议2, 输出最多两个参与方的集合, 其中一个参与方是恶意的.</p>
<p>JMP根据参与方的行为, 分为以下几种情况:</p>
<ol>
<li>若\(P_h\)是恶意的, 则不会产生任何中止信号;</li>
<li>若\(P_g\)是恶意的, 则\(P_g\)将错误地指控\(P_i,P_j\), 按照协议, \(P_g\)将广播\(P_i,P_j,c_i,c_j\). 若\(c_i=c_j\), 则参与方直接输出\(\{P_g\}\). 否则, 由于\(P_i\)和\(P_j\)都是诚实的, 则\(P_g\)广播的信息中必然有一项与\(P_i,P_j\)发送给它的信息不符合, 因此这两方之中必然有一方会指控\(P_g\), 例如\(P_i\)发出了指控, 此时参与方只需输出\(\{P_j,P_g\}\)组成的集合. 不管哪种情况, 输出的集合中都必然包含恶意方\(P_g\);</li>
<li>若\(P_i\)是恶意的, \(P_i\)将发送错误的信息给\(P_g\), \(P_g\)作为诚实方发现从\(P_i\)和\(P_j\)收到的信息不一致, 将指控\(P_i\)和\(P_j\), 此时只有\(P_i\)会指控\(P_g\), 因为\(P_g\)正确地广播了\(P_j\)发送的值. 如果\(P_i\)指控了\(P_g\), 则参与方将\(\{P_i,P_g\}\)作为输出, 否则将\(\{P_i,P_j\}\)作为输出, 不管哪种情况都有\(P_i\)在集合中. \(P_j\)是恶意的情形与\(P_i\)类似.</li>
</ol>
<p>由于JMP仅是三方协议, 因此文章假定没有参与JMP的计算方总是诚实的.</p>
<h3><a id="shared-input" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shared Input</h3>
<p>本节介绍秘密\(x\in\mathcal R\)如何在恶意安全下将\(x\)分享给各参与方, 使得各参与方获得\(x\)的份额\([x]\), 为此可以通过伪随机生成器\(\mathsf{PRG}\)来完成. 分两种情况:</p>
<ol>
<li>若有三个参与方\(P_i,P_j,P_h\)知道\(x\), 则不需要交互即可完成对\(x\)的秘密分享: 令\(x_i=x_j=x_h=0,x_g=x\)即可, 记为\([x]\leftarrow\mathsf{INPLocal}(x,P_i,P_j,P_h)\).</li>
<li>若只有两个参与方知道\(x\), 则可以借助\(\mathsf{PRG}_k\)(伪随机生成器)来完成, 其中\(k\)是密钥. 具体方案如下图协议3. 这里的第3步需要调用JMP确保\(P_g\)获得的\(x_h\)与\(P_i, P_j\)计算得到的是一致的.</li>
</ol>
<img src="https://s2.loli.net/2022/04/15/r7jLhQCFmRo1Ag5.png" style="zoom:50%;" />
<h3><a id="%E5%AE%89%E5%85%A8%E4%B9%98%E6%B3%95%E7%AE%97%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安全乘法算子</h3>
<p>为计算\(x,y\)秘密分享的乘法\(xy\), 为此, 按照秘密共享形式将\(xy\) 展开, 我们得到如下几项, 乘法的目标就是计算所有这些项的和. 其中\(x_iy_i\)这一类的项是参与方无需交互就能计算的, 因为只有\(P_i\)无法计算这一项, 为此令\(P_i\)的三个分享都为0, 其他参与方的其中一个分享为\(x_iy_i\), 其余为0即可. 因此关键在于计算交叉项之和(文章的协议3).</p>
<p><img src="https://s2.loli.net/2022/04/15/ZOzTEKumb6jIk3U.png" alt="" /></p>
<p>下面以\(z:=x_1y_2+y_1x_2\)为例, 这一项\(P_3,P_4\)可以本地计算得到, 问题转化为\(P_3, P_4\)已知秘密\(z\), 如何向\(P_1,P_2\)秘密分享\(z\), 为此可以借助\(\mathsf{PRG}_k\)(伪随机生成器), \(k\)是密钥. 假设\(P_2,P_3,P_4\)之间有预分享的密钥\(k\), 首先\(P_2,P_3,P_4\)计算随机数\(z_1=r=\mathsf{PRG}_k()\)作为其中一个分享, \(P_3,P_4\)设定另一个分享为\(z_2=z-r\), 然后\(P_1,P_2\)令\(z_3=z_4=0\), 接下来只需让\(P_3\)发送\(z_2\)给\(P_1\)即可完成交叉项秘密分享. 由于是恶意安全模型下, 需要确保参与方\(P_3\)发送给\(P_1\)的信息和\(P_4\)持有的都是\(z_2\), 为此需要进行三方作弊识别检测(文章的协议2, Joint Message Passing), 并使得\(P_1\)得到正确的\(z_2\). 其余交叉项情况类似, 因为一共有6个这样的交叉项求和, 因此, 计算一个秘密分享的乘法算子需要发送6个元素, 整个乘法算子的计算步骤见文章协议4. 文章指出, 本文的方案除了JMP部分的哈希函数和伪随机生成器的状态之外, 不需要保留任何后续计算不再需要的秘密分享, 不依赖于功能函数的预处理阶段.</p>
<p><img src="https://s2.loli.net/2022/04/15/T1oXVC6rvxacNp5.png" alt="" /></p>
<img src="https://s2.loli.net/2022/04/15/Xa35vMqj1nVmbiJ.png" style="zoom:50%;" />
<h3><a id="probabilistic-truncation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Probabilistic Truncation</h3>
<img align="right" src="https://s2.loli.net/2022/04/15/n3bzYMSNFDEpdh6.png" style="zoom:40%;" />
<p>为了处理多方计算的定点算术(fixed-point arithmetic)问题, 本文将Dalskov等人<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup>与SWIFT<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup>的截断协议相结合给出概率截断的MPC协议(协议5).</p>
<p>给定\(\mathbb Z_{2^k}\)上的秘密份额\([x]\)和定点精度\(m\), 截断协议的目标是获得份额\([y]\), 这里的\(y=\lfloor x/2^m\rfloor\), 这等价于获得\(y=\lfloor x/2^m\rceil\). 在概率截断中, 我们更关注\(\lfloor x/2^m\rceil\)的最佳近似(就近取整). 具体而言, \(y=\lfloor x/2^m\rceil+u\), 其中\(u\in\{0,1\}\)更偏向于正确结果\(\lfloor x/2^m\rceil\), 即若\(x/2^m\)更接近于\(\lceil x/2^m\rceil\), 则\(u=1\); 若\(x/2^m\)更接近于\(\lfloor x/2^m\rfloor\), 则\(u=0\). 换而言之, \(u=1\)的概率为\((x\bmod 2^m)/2^m\). 举个例子, 若\(x=7,m=2\), 此时正确的结果应为\(7/2^2=1.75\), 概率截断协议给出的可能结果为\(\lfloor 7/4\rfloor=1\), 或\(\lfloor7/4\rfloor+1=2\), 后者即\(u=1\)的概率为\((7\bmod 2^2)/2^2=0.75\), 刚好是正确结果的小数部分.</p>
<p>为说明协议5的正确性, 令\(x\)是正数, 即\(\mathsf{MSB}(x)=0\), 则有\(0&lt;x&lt;2^{k-1}, x\bmod2^{k-1}=x\), 这意味着我们有: \(c=x+r\bmod2^k, c=x+r\bmod2^{k-1}\)成立.  这等价于\(c=x+r-2^ku\), 其中\(u\)是溢出标识比特, 即\(u=(x+r\geq _?2^k)\).  类似地有\(c\bmod 2^{k-1}=x\bmod2^{k-1}+r\bmod2^{k-1}-2^{k-1}v\), 其中\(v=(x+r\geq_?2^{k-1})\). 若记\(r_{k-1}=\mathsf{MSB}(r)\), 则通过分类讨论容易证明\(u=v\cdot r_{k-1}\).</p>
<p>又因为\(c=2^{k-1}\cdot \lfloor c/2^{k-1}\rfloor+(c\bmod2^{k-1})\), 记\(c''=\lfloor c/2^{k-1}\rfloor\). 则有</p>
\[\begin{aligned}
2^{k-1}\cdot c''&amp;=c-(c\bmod2^{k-1})\\
&amp;=(x+r-2^ku)-(x+(r\bmod2^{k-1})-2^{k-1}v)\\
&amp;=2^{k-1}r_{k-1}+2^{k-1}v-2^k\cdot v\cdot r_{k-1}\\
&amp;=2^{k-1}(r_{k-1}\oplus v).
\end{aligned}
\]
<p>有\(c''=r_{k-1}\oplus v\), 或\(v=c''\oplus r_{k-1}\), \(v\)即协议中的\(b\). 这里的最后一步利用了比特运算与算术运算之间的性质: 若\(a,b\)是两个比特, 则有\(a\oplus b=a+b-2ab\). 协议5的第6步也利用了这一性质.</p>
<p>因为\(x\bmod2^{k-1}=x\), 则有\((c\bmod2^{k-1})=x+(r\bmod2^{k-1})-2^{k-1}v\), 因此</p>
\[\lfloor(c\bmod2^{k-1})/2^m\rfloor=\lfloor\dfrac{x+(r\bmod2^{k-1})}{2^m}\rfloor-2^{k-m-1}v.
\]
<p>另一方面, 因为</p>
\[c'=\lfloor(x+(r\bmod2^{k-1}))/2^m\rfloor=\lfloor x/2^m\rfloor+\lfloor(r\bmod2^{k-1})/2^m\rfloor+w, ~~~~w\in\{0,1\}.
\]
<p>而协议中的\(r'=\lfloor(r\bmod2^{k-1})/2^m\rfloor\), 于是协议5的第7步输出为</p>
\[c'-r'+2^{k-m-1}b=\lfloor x/2^m\rfloor+w.
\]
<p>因此, \(w=1\)的概率等于\(\dfrac{x}{2^m}\)的小数部分, 即概率截断输出更倾向于\(\lfloor x/2^m\rceil\).</p>
<h3><a id="random-bit-generation-for-4pc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Random Bit Generation for 4PC</h3>
<p>生成随机比特是多方计算中一个基础原语. 协议6给出了4PC下的具体方案, 总体思想是将参与方分为两组, 每组通过预分享的密钥生成随机比特, 然后再对其进行秘密分享, 通过比特运算与算术运算的关系来生成随机比特\(b\). 因为每组中至少有一个参与方是诚实的, 所以恶参与方可以在INP协议中检测出来, 因此可以保证\(b\)的正确性.</p>
<img src="https://s2.loli.net/2022/04/15/rxVq6yEa7DcS42d.png" style="zoom:50%;" />
<h3><a id="mix-circuit-computation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mix-Circuit Computation</h3>
<p>比较和截断等非线性函数的计算通常在二进制计算(Binary computation)中更高效, 这反过来要求在算术运算(Arithmetic computation)和二进制运算中相互转换, 因为算术运算明显快于点积运算. 有两种方法来实现转换:</p>
<ul>
<li>对于某些秘密共享方案, 可以使用SPDZ, ABY, ABY3的B2A/A2B协议.</li>
<li>使用Rotaru和Wood的double-authenticated bits(daBits)方案, 在两个计算域中共享随机比特份额, 这些随机比特可以盲化(mask)秘密值. 例如, 若\(x\)是计算中的一个比特, \(r\)是秘密随机比特, 在计算域中打开\(x\oplus r\)不会泄漏任何信息, 于是可以在另一个计算域中计算\(x=(x\oplus r)\oplus r\), 因为\(r\)在两个计算域中是通过构造来获得. 由于\(r\)的生成与秘密无关, 因此非常适合于offline-online范式的多方计算协议中.</li>
</ul>
<p>Escudero等人<sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup>将第二种方法从1比特扩展到了\(m\)比特, 提出了extended daBits(edaBits), 并介绍了如何在任意安全模型中生成edaBits. 本文提出了在复制秘密共享模数为二次幂的高效生成预处理edaBits的方案. 构造的关键在于将生成edaBits中的使用的溢出校正(overflow correction)与复制秘密共享的本地份额转换相结合, 文章称之为份额拆分(Share splitting). 具体方案如下图协议7, 其中\(x[j]\)表示\(x\)的第\(j\)比特. 协议7可以扩展到\(n\)方复制秘密共享中.</p>
<p>协议8给出了高效生成edaBits的方法. edaBits是由\(\mathbb Z_{2^k}\)上秘密分享的随机值\([r]_{2^k}\)和它比特\(\{r[i]\}_{i=0}^{k-1}\)的二进制分享\([r]_2\)组成的对\(([r]_{2^k},[r]_2)\).若\(r\in\{0,1\}\)是均匀随机的, 则edaBits即为daBits. 通过daBits可以将\([b]_{2}\)转换为\([b]_{2^k}\): 参与方打开\(c\leftarrow[r]_2+[b]_2\), 然后计算\([b]_{2^k}=[r]_{2^k}+c-2\cdot c\cdot [r]_{2^k}\). 根据这个假设, 可以扩展生成\(m\)比特的edaBits.</p>
<p><img src="https://s2.loli.net/2022/04/15/vHbJsPExAiYwTgQ.png" alt="" /></p>
<h2><a id="%E6%81%B6%E6%84%8F%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%89%E6%96%B9%E8%AE%A1%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>恶意安全的三方计算</h2>
<img align="right"  src="https://s2.loli.net/2022/04/15/K6gX1Gk4sPF8xpb.png" style="zoom:30%;" >
<p>本文实现鲁棒性依赖于三方计算. 与SPDZ类似, Abspoel等人的方案通过加入MAC到秘密份额中使得作弊可以被检测出来, 但他们的方案不支持连续计算, 因为它涉及验证正确性的最后检测阶段, 在此之前的一切都不被信任, 由于检测会泄漏某些防止作弊的秘密信息, 检测后无法进一步计算. 本文通过修改他们的验证协议, 通过献祭(sacrificing)在底层协议中的一个额外的秘密乘法, 使得这些秘密信息被隐藏起来, 以利于连续计算. 连续计算的好处是允许将秘密共享信息保存更长时间. 在实际操作方面, 检测协议将每个乘法的信息保留到检测阶段. 此外, 连续计算可以减少存储要求, 因为它允许定期检查, 从而删除中间信息.</p>
<p>设\(\langle x\rangle=([x]_{2^{k+s}},[r\cdot x]_{2^{k+s}})\)是\(x\)的SPDZ份额, 其中\(r\in\mathbb{Z}_{2^s}\)是全局MAC密钥. 见协议9, 这里直接使用了基于RSS的在模数为二次幂上的Zero-check功能函数\(\mathcal F_\mathsf{CheckZero}\). 这里简单介绍一下协议9中的Zero-check的具体思路<sup class="footnote-ref"><a href="#fn6" id="fnref6">6</a></sup>, 设存在一个随机预言机\(\mathcal H\), 若\(\sum_{i}x_i=0\), 则\(x_{i-1}\equiv_{k+s} -(x_i+x_{i+1})\), 因此\(P_i\)发送\(z_i=\mathcal H(-(x_i+x_{i+1}))\)给\(P_{i+1}\), 而\(P_{i+1}\)和\(P_{i-1}\)都有\(x_{i-1}\), 因此\(P_{i+1}\)可以检测\(z_i=\mathcal H(x_{i-1})\)是否成立, 若不成立, 则直接输出中止(Abort).</p>
<p>复杂度: 协议9底层协议中, 每个点积计算参与方需要发送\(k+s\)比特, 每个输入输入方需要发送\(2(k+s)\)比特. 因此在协议9中, 所有参与方的点积开销为\(6(k+s)\), 输入开销为\(3(k+s)\). 因此, 点积的开销与向量长度\(n\)无关.</p>
</br >
</br >
</br >
<h3><a id="random-bit-generation-for-2pc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Random Bit Generation for 2PC</h3>
<img align="right" src="https://s2.loli.net/2022/04/15/L2jf48wFimySR1b.png" style="zoom:30%;" >
<p>这里考虑的是2PC的情况, 与上面的有所区别.</p>
<p>生成具有半诚实安全性的随机比特的方法是两个不同参与方输入随机比特, 然后计算XOR即可.</p>
<p>然而在恶意安全的情况下, 恶意参与方可能输入的\(b\)可能不是一个比特, 为此在不泄漏\(b\)的前提下, 可以通过计算\(b(1-b)=0\)是否成立来检测是否有\(b\in\{0,1\}\).  本文构造的随机比特生成协议也使用了这一原理, 见协议10. 如果\(b_i=0\), 则最后一步检测将成功. 不失一般性, 假设\(P_0\)是诚实的,  因为</p>
\[b_i=b_i^0\oplus b_i^1=b_i^0+b_i^1-2\cdot b_i^0\cdot b_i^1=
\begin{cases}
b_i^1, &amp; b_i^0=0 \\
1-b_i^1, &amp; b_i^0=1.
\end{cases}
\]
<p>即, 无关\(b_i^0\),  \(b_i\in\{0,1\}\)当且仅当\(b_i^1\in\{0,1\}\). 这种方法排除了对\(b_i^0\)的选择失败攻击.</p>
<h2><a id="%E9%80%9A%E4%BF%A1%E5%A4%8D%E6%9D%82%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通信复杂度</h2>
<p>本文的三方协议比其他工作慢一个数量级, 四方相差大约2倍.</p>
<p><img src="https://s2.loli.net/2022/04/15/gBRnk7m3X2pqYhV.png" alt="" /></p>
<h2><a id="privacy-robustness" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Privacy Robustness</h2>
<p>Slide的这个图很容易理解文章隐私鲁棒性的实现思想, 现在来说明总体的转换思路, 参与方之间约定若JMP输出了恶意参与方的集合, 则优先将索引数小的那个参与方是恶意参与方, 排除该参与方再进行后续计算. 继续背景中的场景, 因为\(P_1\)和\(P_4\)其中必有一方是恶意的, 先假设\(P_1\)是恶意的, 即排除\(P_1\), 剩下的三方将输入的四方秘密分享转化为三方秘密分享, 然后使用中止安全(Security with abort)的三方协议进行隐私计算. 如果在计算中仍然出现了中止信号, 说明\(P_4\)是恶意的, 排除\(P_4\), 剩下的\(P_2,P_3\)使用被动安全的两方计算协议完成隐私计算, 此时可以引入诚实的\(P_1\)生成乘法三元组协助两方进行隐私计算. 这样既可以在不向计算方泄漏用户的隐私信息的前提下完成计算, 又提供了鲁棒性, 达到了预期目标. 文章的JMP协议给出了当出现中止信号时, 检测恶意参与方的方法.</p>
<p><img src="https://s2.loli.net/2022/04/15/MlB5uvXO2wDy7ZT.png" alt="" /></p>
<p>现在说明排除潜在的恶意参与方后, 如何实现份额转换.</p>
<p>设\(x=x_1+x_2+x_3+x_4\), 参与方\(P_i\)拥有的份额为\(\{x_j\}_{j\neq i}\).</p>
<ol>
<li>四方份额转三方份额: 假设\(P_0\)被排除, 则进行如下转换: \(P_1,P_2\)定义\(x'=x_0+x_3\), \(P_3\)丢弃\(x_0\). 这样, \(P_1\)的持有的份额为\((x',x_2)\), \(P_2\)持有的份额为\((x_1,x')\), \(P_3\)的持有份额为\((x_1,x_2)\). 此后计算为恶意安全的三方计算.</li>
<li>三方份额转两方份额: 假设\(P_3\)被排除, 则进行如下转换: \(P_1\)定义\(x''=x'+x_2\), \(P_2\)丢弃\(x'\). 这样\(P_1\)的持有份额为\(x''\), \(P_2\)的持有份额为\(x_1\). 此后计算为半诚实安全的两方计算, 但可以引入诚实方生成乘法三元组协助两方进行计算.</li>
</ol>
<h2><a id="%E5%AE%9E%E9%AA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实验</h2>
<p>文章中的实验仅实现了中止安全性. 表2展示了不同安全模型下3层网络训练MNIST的计算开销和不同epoch下的模型准确率. 此外, 表3中可以看出文章所提出的半诚实安全的3PC和恶意安全的4PC开销基本相近.</p>
<p><img src="https://s2.loli.net/2022/04/15/LerDZkw7tnKUTHQ.png" alt="" /></p>
<h3><a id="%E5%AE%9A%E7%82%B9%E7%B2%BE%E5%BA%A6%E7%9A%84%E5%BD%B1%E5%93%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定点精度的影响</h3>
<p>MPC使用浮点算术(float-point arithmetic)通常可以获得更好的准确性, 但开销也相对较大, 因此通常MPC使用的是效率更高的定点算术(fixed-point arithmetic). 但定点算术的方法由于需要进行概率截断, 可能会导致模型的准确率下降, 先前的工作所选的参数在小型模型上具有较好的准确率, 但大多忽略了在大型模型中的准确性降低的程度. 文章分别对比了不同定点精度与计算域位长导致的准确率和效率之间差异. 结果见表5和表6.</p>
<p>先前的工作大多要求概率截断中的精度比计算域最大长度\(k\)小得多, 误差概率为\(2^{\ell-k}\), 其中\(\ell\)是概率截断输入的长度. 表5表明这个概率大概为\(2^{-20}\). 为训练双层模型, 通常需要将每个数的误差概率限制为\(2^{-40}\).</p>
<p>表6说明虽然低精度截断使得通信量节省了大约1/3, 但较大的模数使得双层模型训练的时间增加了1倍.</p>
<p>此外, 文章还指出64比特模数和13比特定点精度不能满足大型模型训练要求, 表5双层模型定点精度为12时, 随着epoch增大, 模型的准确度反而下降.</p>
<p><img src="https://s2.loli.net/2022/04/15/DYGjVrCN3eHh65W.png" alt="" /></p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>本文提出了Privacy robustness, 在不泄漏任何参与方输入隐私的前提下, 实现了输出可达性. 提出的协议不需要预处理阶段, 但安全性保证的前提是假设诚实方只存储预期信息, 即协议执行完后诚实方不能恢复隐私输入, 为此本文设计的协议不含让诚实参与方恢复信息的步骤. 如果诚实方长期存储所有的输入信息, 则本文提出的方案不适用, 安全性假设较强.</p>
<h2><a id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考文献</h2>
<section class="footnotes">
<ol>
<li id="fn1">
<p>Nishat Koti, Mahak Pancholi, Arpita Patra, and Ajith Suresh. Swift: Super-fast and robust privacy-preserving machine learning. Cryptology ePrint Archive, Report 2020/592, 2020. <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2">
<p>Byali, Megha et al. “FLASH: Fast and Robust Framework for Privacy-preserving Machine Learning.” <em>Proceedings on Privacy Enhancing Technologies</em> 2020 (2019): 459 - 480. <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3">
<p>Arpita Patra and Ajith Suresh. BLAZE: Blazing fast privacy-preserving machine learning. In NDSS 2020. The Internet Society, February 2020. <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4">
<p>Anders P. K. Dalskov, Daniel Escudero, and Marcel Keller. Secure evaluation of quantized neural networks. PoPETs, 2020(4):355–375, October 2020. <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
<li id="fn5">
<p>Escudero, D., Ghosh, S., Keller, M., Rachuri, R. &amp; Scholl, P. Improved Primitives for MPC over Mixed Arithmetic-Binary Circuits. CRYPTO 2020. <a href="#fnref5" class="footnote-backref">↩</a></p>
</li>
<li id="fn6">
<p>Mark Abspoel, Anders Dalskov, Daniel Escudero, and Ariel Nof. An efficient passive-to-active compiler for honest-majority MPC over rings. Cryptology ePrint Archive, Report 2019/1298, 2019. <a href="#fnref6" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>


	    <p class="post-info" style="color: #BCBDB6">
			<br>本文标题: <a style="color: #4690cc" href="#">Fantastic Four: 具有恶意安全的诚实大多数四方安全计算</a>
			<br>本文作者: <a style="color: #4690cc" href="#">云中雨雾</a>
			<br>本文链接: <a style="color: #4690cc" href="#">https://weiviming.github.io/16337773581295.html
				</a>
				<br>本站文章采用 <a style="color: #4690cc" href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external nofollow">知识共享署名4.0</a> 国际许可协议进行许可<br>除注明转载/出处外，均为本站原创或翻译，转载前请务必署名<br>最后编辑时间: 2021-10-09T19:02:38+08:00
		</p>

                                </div><!-- / .chat-messages -->
                            </div>

                        </div>
                    </div><!-- / .row -->

                </div><!-- / .card -->

            </div><!-- / .chat-wrapper -->
        </div>
        <!-- / Content -->
    </div>
    <!-- Layout content -->

</div>
<!-- / Layout container -->


  </div>

<!-- Layout footer -->
<nav class="layout-footer footer bg-footer-theme border-top">
   <div class="container-fluid d-flex flex-wrap justify-content-between text-center container-p-x pb-3">
       <div class="pt-3">
           <!-- <span class="footer-text font-weight-bolder text-muted">Copyright &copy; 2020 | 粤ICP备18038345号-1</span> -->
           <span class="footer-text font-weight-bolder text-muted">There is always only one truth！</span>
       </div>
       <div>
           
           <a href="index.html" class="footer-link pt-3 ml-4">主页</a>
           
           <a href="archives.html" class="footer-link pt-3 ml-4">分类</a>
           
           <a href="about.html" class="footer-link pt-3 ml-4">关于</a>
           
           <a href="https://gitee.com/hongtu1993/mao-mweb-theme" target="_blank" class="footer-link pt-3 ml-4">Theme</a>
           <a href="#post-header" class="footer-link pt-3 ml-4">Top</a>
       </div>
   </div>
</nav>
<!-- / Layout footer -->

<!-- Overlay -->
<div class="layout-overlay layout-sidenav-toggle"></div>
</div>
<!-- / Layout wrapper -->

<!-- Load polyfills -->
<script src="asset/vendor/js/layout-helpers.js"></script>

<!-- Core scripts -->
<script src="asset/vendor/js/pace.js"></script>
<!--<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>-->

<!-- Core scripts -->
<script src="asset/vendor/libs/popper/popper.js"></script>
<!--<script src="asset/vendor/js/bootstrap.js"></script>-->
<script src="asset/vendor/js/sidenav.js"></script>

<!-- Libs -->
<script src="asset/vendor/libs/perfect-scrollbar/perfect-scrollbar.js"></script>

<!-- Demo -->
<script src="asset/js/demo.js"></script>

<script src="asset/pages_chat.js"></script>

<script type="text/javascript">
  $(function () {

    // todo
    // https://www.cnblogs.com/wicub/p/3449833.html
    // https://www.jb51.net/article/102370.htm
    $("a.sidenav-link").on("click", ev => {

      let url = $(ev.currentTarget).data("url");
      if (url) {
        console.log(url)
        window.location.href = url + "?s=" + $("#sidenav-inner").scrollTop()
      }

    })



    let currentURL = window.location.href.substr(window.location.href.lastIndexOf("/") + 1);
    let $sideNavArray = $('.sidenav-inner > .sidenav-item');
    $sideNavArray.each(sideNavItemIndex => {
      let sideNavItem = $sideNavArray.eq(sideNavItemIndex);

      let sideNavMenu = $(sideNavItem).find(".sidenav-menu");


      let getQueryString = function(name) {
        var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
        var r = window.location.search.substr(1).match(reg);
        if (r != null) {
          return unescape(r[2]);
        }
        return null;
      }

      if (sideNavMenu && sideNavMenu.length > 0) {

        let $sideHrefItemArray = $(sideNavMenu).find("li a")
        $sideHrefItemArray.each(index => {
          let linkString = $($sideHrefItemArray[index]).data('url');
          if (linkString) {
            if (currentURL.startsWith(linkString.toString())) {
              $($sideHrefItemArray[index]).parent().addClass('active');
              $($(sideNavMenu).parent("li")).addClass('open')
              // console.log("offset", $($sideHrefItemArray[index]).offset().top)
              // console.log("offset", $("#sidenav-inner").height())
              setTimeout(() => {
                let sTop = getQueryString("s")
                if (sTop && !isNaN(sTop)) {
                  $("#sidenav-inner").scrollTop(Number(sTop))
                }
              }, 0)
            }
          }

        });
      } else {
        let $sideHrefItemArray = $(sideNavItem).find("a");
        $sideHrefItemArray.each(index => {
          let linkString = $($sideHrefItemArray[index]).data('url');
          if (linkString) {
            if (currentURL.startsWith(linkString.toString())) {
              $($sideHrefItemArray[index]).parent().addClass('active');
              // console.log("offset", $($sideHrefItemArray[index]).offset().top)
              // console.log("offset", $("#sidenav-inner").height())
              setTimeout(() => {
                let sTop = getQueryString("s")
                if (sTop && !isNaN(sTop)) {
                  $("#sidenav-inner").scrollTop(Number(sTop))
                }
              }, 0)


            }
          }
        });
      }
    });
  });
</script>

<script type="text/javascript">
  $(document).ready(function() {
      //为超链接加上target='_blank'属性
    $('a[href^="http"]').each(function() {
      $(this).attr('target', '_blank');
    });
  });
</script>




<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true }, displayAlign : "center", TeX: { equationNumbers: { autoNumber: "all", useLabelIds: true } }, "HTML-CSS": { availableFonts: ["TeX"], showMathMenu: false, linebreaks: { automatic: false }, scale: 100, styles: { ".MathJax_Display": { "text-align": "left", "width" : "auto", "margin": "10px 0px 10px 0px !important", "border-radius": "3px !important", border: "1px solid #ccc !important", padding: "5px 5px 5px 5px !important" }, ".MathJax": { padding: "2px 2px 2px 2px !important" } } }, SVG: { linebreaks: { automatic: false } } }); </script> 
<!-- <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script> -->

<!-- <script type="text/x-mathjax-config">MathJax.Hub.Config({
jax: ['input/TeX','output/HTML-CSS'], TeX: { equationNumbers: { autoNumber: "AMS" } }});</script> -->


<!-- <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> -->















<script src="asset/prism.js"></script>


</body>

</html>
